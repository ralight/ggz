.TH "ggz.h" 3 "21 May 2005" "Version 0.0.11" "LibGGZ" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ggz.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <sys/types.h>\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBLIBGGZ_VERSION_MAJOR\fP   0"
.br
.ti -1c
.RI "#define \fBLIBGGZ_VERSION_MINOR\fP   0"
.br
.ti -1c
.RI "#define \fBLIBGGZ_VERSION_MICRO\fP   11"
.br
.ti -1c
.RI "#define \fBLIBGGZ_VERSION_IFACE\fP   '3:1:1'"
.br
.ti -1c
.RI "#define \fBggz__attribute\fP(att)"
.br
.RI "\fIAllow easy use of GCC's 'attribute' macro for debugging. \fP"
.ti -1c
.RI "#define \fB_GGZFUNCTION_\fP   __FUNCTION__"
.br
.ti -1c
.RI "#define \fBGGZ_MEM_DEBUG\fP   'ggz_mem'"
.br
.RI "\fIDebugging type for memory debugging. \fP"
.ti -1c
.RI "#define \fBggz_malloc\fP(size)   _ggz_malloc(size, _GGZFUNCTION_ ' in ' __FILE__, __LINE__)"
.br
.RI "\fIMacro for memory allocation. \fP"
.ti -1c
.RI "#define \fBggz_realloc\fP(mem, size)   _ggz_realloc(mem, size, _GGZFUNCTION_ ' in ' __FILE__, __LINE__)"
.br
.RI "\fIMacro for resizing previously allocated memory. \fP"
.ti -1c
.RI "#define \fBggz_free\fP(mem)   _ggz_free(mem, _GGZFUNCTION_ ' in ' __FILE__,  __LINE__)"
.br
.RI "\fIMacro for freeing memory previously allocated. \fP"
.ti -1c
.RI "#define \fBggz_strdup\fP(string)   _ggz_strdup(string, _GGZFUNCTION_ ' in ' __FILE__,  __LINE__)"
.br
.RI "\fIMacro for duplicating string. \fP"
.ti -1c
.RI "#define \fBGGZ_CONF_DEBUG\fP   'ggz_conf'"
.br
.RI "\fIDebugging type for config-file debugging. \fP"
.ti -1c
.RI "#define \fBGGZ_LIST_REPLACE_DUPS\fP   0x00"
.br
.RI "\fIOverwrite duplicate values on insert. \fP"
.ti -1c
.RI "#define \fBGGZ_LIST_ALLOW_DUPS\fP   0x01"
.br
.RI "\fIAllow duplicate data entries to exist in the list. \fP"
.ti -1c
.RI "#define \fBGGZ_SOCKET_DEBUG\fP   'socket'"
.br
.RI "\fIggz_debug debugging type for Easysock debugging. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int(* \fBggzEntryCompare\fP )(const void *a, const void *b)"
.br
.RI "\fIA function type for doing data comparison on two items in a \fBGGZList\fP. \fP"
.ti -1c
.RI "typedef void *(* \fBggzEntryCreate\fP )(void *data)"
.br
.RI "\fIA function type for creating a copy of a data item for insertion into a \fBGGZList\fP. \fP"
.ti -1c
.RI "typedef void(* \fBggzEntryDestroy\fP )(void *data)"
.br
.RI "\fIA function type to destroy an entry in a \fBGGZList\fP. \fP"
.ti -1c
.RI "typedef \fB_GGZListEntry\fP \fBGGZListEntry\fP"
.br
.RI "\fIA single entry in a \fBGGZList\fP. \fP"
.ti -1c
.RI "typedef \fB_GGZList\fP \fBGGZList\fP"
.br
.RI "\fISimple doubly-linked list. \fP"
.ti -1c
.RI "typedef \fB_GGZList\fP \fBGGZStack\fP"
.br
.RI "\fISimple implementation of stacks using \fBGGZList\fP. \fP"
.ti -1c
.RI "typedef \fB_GGZXMLElement\fP \fBGGZXMLElement\fP"
.br
.RI "\fIObject representing a single XML element. \fP"
.ti -1c
.RI "typedef void(* \fBGGZDebugHandlerFunc\fP )(int priority, const char *msg)"
.br
.RI "\fIA callback function to handle debugging output. \fP"
.ti -1c
.RI "typedef _GGZFile \fBGGZFile\fP"
.br
.RI "\fIStructure used internally by \fBggz_read_line()\fP. \fP"
.ti -1c
.RI "typedef void(* \fBggzIOError\fP )(const char *msg, const \fBGGZIOType\fP type, const int fd, const \fBGGZDataType\fP data)"
.br
.RI "\fIAn error function type. \fP"
.ti -1c
.RI "typedef void(* \fBggzIOExit\fP )(int status)"
.br
.RI "\fIAn exit function type. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBGGZConfType\fP { \fBGGZ_CONF_RDONLY\fP =  ((unsigned char) 0x01), \fBGGZ_CONF_RDWR\fP =  ((unsigned char) 0x02), \fBGGZ_CONF_CREATE\fP =  ((unsigned char) 0x04) }"
.br
.RI "\fISpecifies the mode for opening a configuration file. \fP"
.ti -1c
.RI "enum \fBGGZCheckType\fP { \fBGGZ_CHECK_NONE\fP =  0x00, \fBGGZ_CHECK_MEM\fP =  0x01 }"
.br
.RI "\fIWhat memory checks should we do? \fP"
.ti -1c
.RI "enum \fBGGZIOType\fP { \fBGGZ_IO_CREATE\fP, \fBGGZ_IO_READ\fP, \fBGGZ_IO_WRITE\fP, \fBGGZ_IO_ALLOCATE\fP }"
.br
.RI "\fIAn error type for the GGZ socket functions. \fP"
.ti -1c
.RI "enum \fBGGZDataType\fP { \fBGGZ_DATA_NONE\fP, \fBGGZ_DATA_CHAR\fP, \fBGGZ_DATA_INT\fP, \fBGGZ_DATA_STRING\fP, \fBGGZ_DATA_FD\fP }"
.br
.RI "\fIA data type for the GGZ socket function error handler. \fP"
.ti -1c
.RI "enum \fBGGZSockType\fP { \fBGGZ_SOCK_SERVER\fP, \fBGGZ_SOCK_CLIENT\fP }"
.br
.RI "\fIA socket type. \fP"
.ti -1c
.RI "enum \fBGGZTLSType\fP { \fBGGZ_TLS_CLIENT\fP, \fBGGZ_TLS_SERVER\fP }"
.br
.RI "\fITLS operation mode. \fP"
.ti -1c
.RI "enum \fBGGZTLSVerificationType\fP { \fBGGZ_TLS_VERIFY_NONE\fP, \fBGGZ_TLS_VERIFY_PEER\fP }"
.br
.RI "\fITLS verification type. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fB_ggz_malloc\fP (const size_t size, const char *tag, int line)"
.br
.RI "\fIFunction to actually perform memory allocation. \fP"
.ti -1c
.RI "void * \fB_ggz_realloc\fP (const void *ptr, const size_t size, const char *tag, int line)"
.br
.RI "\fIFunction to perform memory reallocation. \fP"
.ti -1c
.RI "int \fB_ggz_free\fP (const void *ptr, const char *tag, int line)"
.br
.RI "\fIFunction to free allocated memory. \fP"
.ti -1c
.RI "char * \fB_ggz_strdup\fP (const char *ptr, const char *tag, int line)"
.br
.RI "\fIFunction to copy a string. \fP"
.ti -1c
.RI "int \fBggz_memory_check\fP (void)"
.br
.RI "\fICheck memory allocated against memory freed and display any discrepancies. \fP"
.ti -1c
.RI "void \fBggz_conf_cleanup\fP (void)"
.br
.RI "\fICloses all open configuration files. \fP"
.ti -1c
.RI "void \fBggz_conf_close\fP (int handle)"
.br
.RI "\fICloses one configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_parse\fP (const char *path, const \fBGGZConfType\fP options)"
.br
.RI "\fIOpens a configuration file and parses the variables so they can be retrieved with the access functions. \fP"
.ti -1c
.RI "int \fBggz_conf_commit\fP (int handle)"
.br
.RI "\fICommits any changed variables to the configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_write_string\fP (int handle, const char *section, const char *key, const char *value)"
.br
.RI "\fIWrites a string value to a section and key in an open configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_write_int\fP (int handle, const char *section, const char *key, int value)"
.br
.RI "\fIWrites an integer value to a section and key in an open configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_write_list\fP (int handle, const char *section, const char *key, int argc, char **argv)"
.br
.RI "\fIWrites a list of string values to a section and key in an open configuration file. \fP"
.ti -1c
.RI "char * \fBggz_conf_read_string\fP (int handle, const char *section, const char *key, const char *def)"
.br
.RI "\fIReads a string value from an open configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_read_int\fP (int handle, const char *section, const char *key, int def)"
.br
.RI "\fIReads an integer value from an open configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_read_list\fP (int handle, const char *section, const char *key, int *argcp, char ***argvp)"
.br
.RI "\fIReads a list of string values from an open configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_remove_section\fP (int handle, const char *section)"
.br
.RI "\fIThis will remove an entire section and all its associated keys from a configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_remove_key\fP (int handle, const char *section, const char *key)"
.br
.RI "\fIThis will remove a single key from a configuration file. \fP"
.ti -1c
.RI "int \fBggz_conf_get_sections\fP (int handle, int *argcp, char ***argvp)"
.br
.RI "\fIThis function returns a list of all sections in a config file. \fP"
.ti -1c
.RI "int \fBggz_conf_get_keys\fP (int handle, const char *section, int *argcp, char ***argvp)"
.br
.RI "\fIThis function returns a list of all keys within a section in a config file. \fP"
.ti -1c
.RI "\fBGGZList\fP * \fBggz_list_create\fP (\fBggzEntryCompare\fP compare_func, \fBggzEntryCreate\fP create_func, \fBggzEntryDestroy\fP destroy_func, int options)"
.br
.RI "\fICreate a new \fBGGZList\fP. \fP"
.ti -1c
.RI "int \fBggz_list_insert\fP (\fBGGZList\fP *list, void *data)"
.br
.RI "\fIInsert data into a list. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_head\fP (\fBGGZList\fP *list)"
.br
.RI "\fIGet the first node of a list. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_tail\fP (\fBGGZList\fP *list)"
.br
.RI "\fIGet the last node of a list. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_next\fP (\fBGGZListEntry\fP *entry)"
.br
.RI "\fIGet the next node of a list. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_prev\fP (\fBGGZListEntry\fP *entry)"
.br
.RI "\fIGet the previous node of a list. \fP"
.ti -1c
.RI "void * \fBggz_list_get_data\fP (\fBGGZListEntry\fP *entry)"
.br
.RI "\fIRetrieve the data stored in a list entry. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_search\fP (\fBGGZList\fP *list, void *data)"
.br
.RI "\fISearch for a specified data item in the list. \fP"
.ti -1c
.RI "\fBGGZListEntry\fP * \fBggz_list_search_alt\fP (\fBGGZList\fP *list, void *data, \fBggzEntryCompare\fP compare_func)"
.br
.RI "\fISearch for a specified data item in the list using a provided comparison function. \fP"
.ti -1c
.RI "void \fBggz_list_delete_entry\fP (\fBGGZList\fP *list, \fBGGZListEntry\fP *entry)"
.br
.RI "\fIRemoves an entry from a list, calling a destructor if registered. \fP"
.ti -1c
.RI "void \fBggz_list_free\fP (\fBGGZList\fP *list)"
.br
.RI "\fIFree all resources associated with a list. \fP"
.ti -1c
.RI "int \fBggz_list_count\fP (\fBGGZList\fP *list)"
.br
.RI "\fIGet the length of the list. \fP"
.ti -1c
.RI "int \fBggz_list_compare_str\fP (void *a, void *b)"
.br
.RI "\fICompare two character strings. \fP"
.ti -1c
.RI "void * \fBggz_list_create_str\fP (void *data)"
.br
.RI "\fICopy a character string. \fP"
.ti -1c
.RI "void \fBggz_list_destroy_str\fP (void *data)"
.br
.RI "\fIFree a character string. \fP"
.ti -1c
.RI "\fBGGZStack\fP * \fBggz_stack_new\fP (void)"
.br
.RI "\fICreate a new stack. \fP"
.ti -1c
.RI "void \fBggz_stack_push\fP (\fBGGZStack\fP *stack, void *data)"
.br
.RI "\fIPush a data item onto the top of the stack. \fP"
.ti -1c
.RI "void * \fBggz_stack_pop\fP (\fBGGZStack\fP *stack)"
.br
.RI "\fIPop the top item off of the stack. \fP"
.ti -1c
.RI "void * \fBggz_stack_top\fP (\fBGGZStack\fP *stack)"
.br
.RI "\fIGet the top item on the stack without popping it. \fP"
.ti -1c
.RI "void \fBggz_stack_free\fP (\fBGGZStack\fP *stack)"
.br
.RI "\fIFree the stack. \fP"
.ti -1c
.RI "\fBGGZXMLElement\fP * \fBggz_xmlelement_new\fP (const char *tag, const char *const *attrs, void(*process)(), void(*free)())"
.br
.RI "\fICreate a new \fBGGZXMLElement\fP element. \fP"
.ti -1c
.RI "void \fBggz_xmlelement_init\fP (\fBGGZXMLElement\fP *element, const char *tag, const char *const *attrs, void(*process)(), void(*free)())"
.br
.RI "\fIInitialize a \fBGGZXMLElement\fP. \fP"
.ti -1c
.RI "void \fBggz_xmlelement_set_data\fP (\fBGGZXMLElement\fP *element, void *data)"
.br
.RI "\fISet ancillary data on a \fBGGZXMLElement\fP object. \fP"
.ti -1c
.RI "const char * \fBggz_xmlelement_get_tag\fP (\fBGGZXMLElement\fP *element)"
.br
.RI "\fIGet an XML element's name. \fP"
.ti -1c
.RI "const char * \fBggz_xmlelement_get_attr\fP (\fBGGZXMLElement\fP *element, const char *attr)"
.br
.RI "\fIGet the value of an attribute on XML element. \fP"
.ti -1c
.RI "void * \fBggz_xmlelement_get_data\fP (\fBGGZXMLElement\fP *element)"
.br
.RI "\fIGet the user-supplied data associated with an XML element. \fP"
.ti -1c
.RI "char * \fBggz_xmlelement_get_text\fP (\fBGGZXMLElement\fP *element)"
.br
.RI "\fIGet an XML element's content text. \fP"
.ti -1c
.RI "void \fBggz_xmlelement_add_text\fP (\fBGGZXMLElement\fP *element, const char *text, int len)"
.br
.RI "\fIAppend a string to the element's content text. \fP"
.ti -1c
.RI "void \fBggz_xmlelement_free\fP (\fBGGZXMLElement\fP *element)"
.br
.RI "\fIFree the memory associated with an XML element. \fP"
.ti -1c
.RI "void \fBggz_debug_init\fP (const char **types, const char *file)"
.br
.RI "\fIInitialize and configure debugging for the program. \fP"
.ti -1c
.RI "\fBGGZDebugHandlerFunc\fP \fBggz_debug_set_func\fP (\fBGGZDebugHandlerFunc\fP func)"
.br
.RI "\fISet the debug handler function. \fP"
.ti -1c
.RI "void \fBggz_debug_enable\fP (const char *type)"
.br
.RI "\fIEnable a specific type of debugging. \fP"
.ti -1c
.RI "void \fBggz_debug_disable\fP (const char *type)"
.br
.RI "\fIDisable a specific type of debugging. \fP"
.ti -1c
.RI "void \fBggz_debug\fP (const char *type, const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog a debugging message. \fP"
.ti -1c
.RI "void void \fBggz_log\fP (const char *type, const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog a notice message. \fP"
.ti -1c
.RI "void void void \fBggz_error_sys\fP (const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog a syscall error. \fP"
.ti -1c
.RI "void void void void \fBggz_error_sys_exit\fP (const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog a fatal syscall error. \fP"
.ti -1c
.RI "void void void void \fBggz__attribute\fP ((noreturn))"
.br
.ti -1c
.RI "void \fBggz_error_msg\fP (const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog an error message. \fP"
.ti -1c
.RI "void void \fBggz_error_msg_exit\fP (const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fILog a fatal error message. \fP"
.ti -1c
.RI "void \fBggz_debug_cleanup\fP (\fBGGZCheckType\fP check)"
.br
.RI "\fICleans up debugging state and prepares for exit. \fP"
.ti -1c
.RI "char * \fBggz_xml_escape\fP (const char *str)"
.br
.RI "\fIEscape XML characters in a text string. \fP"
.ti -1c
.RI "char * \fBggz_xml_unescape\fP (const char *str)"
.br
.RI "\fIRestore escaped XML characters into a text string. \fP"
.ti -1c
.RI "\fBGGZFile\fP * \fBggz_get_file_struct\fP (int fdes)"
.br
.RI "\fISetup a file structure to use with \fBggz_read_line()\fP. \fP"
.ti -1c
.RI "char * \fBggz_read_line\fP (\fBGGZFile\fP *file)"
.br
.RI "\fIRead a line of arbitrary length from a file. \fP"
.ti -1c
.RI "void \fBggz_free_file_struct\fP (\fBGGZFile\fP *file)"
.br
.RI "\fIDeallocate a file structure allocated via \fBggz_get_file_struct()\fP. \fP"
.ti -1c
.RI "int \fBggz_strcmp\fP (const char *s1, const char *s2)"
.br
.RI "\fIString comparison function that is safe with NULLs. \fP"
.ti -1c
.RI "int \fBggz_strcasecmp\fP (const char *s1, const char *s2)"
.br
.RI "\fICase-insensitive string comparison function that is safe with NULLs The function returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2. \fP"
.ti -1c
.RI "int \fBggz_set_io_error_func\fP (\fBggzIOError\fP func)"
.br
.RI "\fISet the ggz/easysock error handling function. \fP"
.ti -1c
.RI "\fBggzIOError\fP \fBggz_remove_io_error_func\fP (void)"
.br
.RI "\fIRemove the ggz/easysock error handling function. \fP"
.ti -1c
.RI "int \fBggz_set_io_exit_func\fP (\fBggzIOExit\fP func)"
.br
.RI "\fISet the ggz/easysock exit function. \fP"
.ti -1c
.RI "\fBggzIOExit\fP \fBggz_remove_io_exit_func\fP (void)"
.br
.RI "\fIRemove the ggz/easysock exit function. \fP"
.ti -1c
.RI "unsigned int \fBggz_get_io_alloc_limit\fP (void)"
.br
.RI "\fIGet libggz's limit on memory allocation. \fP"
.ti -1c
.RI "unsigned int \fBggz_set_io_alloc_limit\fP (const unsigned int limit)"
.br
.RI "\fISet libggz's limit on memory allocation. \fP"
.ti -1c
.RI "int \fBggz_init_network\fP (void)"
.br
.RI "\fIInitialize the network. \fP"
.ti -1c
.RI "int \fBggz_make_socket\fP (const \fBGGZSockType\fP type, const unsigned short port, const char *server)"
.br
.RI "\fIMake a socket connection. \fP"
.ti -1c
.RI "int \fBggz_make_socket_or_die\fP (const \fBGGZSockType\fP type, const unsigned short port, const char *server)"
.br
.RI "\fIMake a socket connection, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_make_unix_socket\fP (const \fBGGZSockType\fP type, const char *name)"
.br
.RI "\fIConnect to a unix domain socket. \fP"
.ti -1c
.RI "int \fBggz_make_unix_socket_or_die\fP (const \fBGGZSockType\fP type, const char *name)"
.br
.RI "\fIConnect to a unix domain socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_write_char\fP (const int sock, const char data)"
.br
.RI "\fIWrite a character value to the given socket. \fP"
.ti -1c
.RI "void \fBggz_write_char_or_die\fP (const int sock, const char data)"
.br
.RI "\fIWrite a character value to the given socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_read_char\fP (const int sock, char *data)"
.br
.RI "\fIRead a character value from the given socket. \fP"
.ti -1c
.RI "void \fBggz_read_char_or_die\fP (const int sock, char *data)"
.br
.RI "\fIRead a character value from the given socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_write_int\fP (const int sock, const int data)"
.br
.RI "\fIWrite an integer to the socket in network byte order. \fP"
.ti -1c
.RI "void \fBggz_write_int_or_die\fP (const int sock, const int data)"
.br
.RI "\fIWrite an integer to the socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_read_int\fP (const int sock, int *data)"
.br
.RI "\fIRead an integer from the socket in network byte order. \fP"
.ti -1c
.RI "void \fBggz_read_int_or_die\fP (const int sock, int *data)"
.br
.RI "\fIRead an integer from the socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_write_string\fP (const int sock, const char *data)"
.br
.RI "\fIWrite a string to the given socket. \fP"
.ti -1c
.RI "void \fBggz_write_string_or_die\fP (const int sock, const char *data)"
.br
.RI "\fIWrite a string to the given socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_va_write_string\fP (const int sock, const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fIWrite a printf-style formatted string to the given socket. \fP"
.ti -1c
.RI "int void \fBggz_va_write_string_or_die\fP (const int sock, const char *fmt,...) ggz__attribute((format(printf"
.br
.RI "\fIWrite a formatted string to the socket, exiting on error. \fP"
.ti -1c
.RI "int void int \fBggz_read_string\fP (const int sock, char *data, const unsigned int len)"
.br
.RI "\fIRead a string from the given socket. \fP"
.ti -1c
.RI "void \fBggz_read_string_or_die\fP (const int sock, char *data, const unsigned int len)"
.br
.RI "\fIRead a string from the given socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_read_string_alloc\fP (const int sock, char **data)"
.br
.RI "\fIRead and allocate a string from the given socket. \fP"
.ti -1c
.RI "void \fBggz_read_string_alloc_or_die\fP (const int sock, char **data)"
.br
.RI "\fIRead and allocate string from the given socket, exiting on error. \fP"
.ti -1c
.RI "int \fBggz_write_fd\fP (const int sock, int sendfd)"
.br
.RI "\fIWrite a file descriptor to the given (local) socket. \fP"
.ti -1c
.RI "int \fBggz_read_fd\fP (const int sock, int *recvfd)"
.br
.RI "\fIRead a file descriptor from the given (local) socket. \fP"
.ti -1c
.RI "int \fBggz_writen\fP (const int sock, const void *vdata, size_t n)"
.br
.RI "\fIWrite a sequence of bytes to the socket. \fP"
.ti -1c
.RI "int \fBggz_readn\fP (const int sock, void *data, size_t n)"
.br
.RI "\fIRead a sequence of bytes from the socket. \fP"
.ti -1c
.RI "\fBhash_t\fP \fBggz_hash_create\fP (const char *algo, const char *text)"
.br
.RI "\fICreate a hash over a text. \fP"
.ti -1c
.RI "\fBhash_t\fP \fBggz_hmac_create\fP (const char *algo, const char *text, const char *secret)"
.br
.RI "\fICreate a HMAC hash over a text. \fP"
.ti -1c
.RI "char * \fBggz_base64_encode\fP (const char *text, int length)"
.br
.RI "\fIEncodes text to base64. \fP"
.ti -1c
.RI "char * \fBggz_base64_decode\fP (const char *text, int length)"
.br
.RI "\fIDecodes text from base64. \fP"
.ti -1c
.RI "void \fBggz_tls_init\fP (const char *certfile, const char *keyfile, const char *password)"
.br
.RI "\fIInitialize TLS support on the server side. \fP"
.ti -1c
.RI "int \fBggz_tls_support_query\fP (void)"
.br
.RI "\fICheck TLS support. \fP"
.ti -1c
.RI "int \fBggz_tls_enable_fd\fP (int fdes, \fBGGZTLSType\fP whoami, \fBGGZTLSVerificationType\fP verify)"
.br
.RI "\fIEnable TLS for a file descriptor. \fP"
.ti -1c
.RI "int \fBggz_tls_disable_fd\fP (int fdes)"
.br
.RI "\fIDisable TLS for a file descriptor. \fP"
.ti -1c
.RI "size_t \fBggz_tls_write\fP (int fd, void *ptr, size_t n)"
.br
.RI "\fIWrite some bytes to a secured file descriptor. \fP"
.ti -1c
.RI "size_t \fBggz_tls_read\fP (int fd, void *ptr, size_t n)"
.br
.RI "\fIRead from a secured file descriptor. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBAuthor:\fP
.RS 4
Brent M. Hendricks 
.RE
.PP
\fBDate:\fP
.RS 4
Fri Nov 2 23:32:17 2001 
.PP
\fBId\fP.RS 4
\fBggz.h\fP,v 1.59 2005/05/21 10:19:22 josef Exp 
.RE
.PP
.RE
.PP
Header file for ggz components lib
.PP
Copyright (C) 2001 Brent Hendricks.
.PP
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
.PP
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA 
.SH "Define Documentation"
.PP 
.SS "#define ggz__attribute(att)"
.PP
Allow easy use of GCC's 'attribute' macro for debugging. 
.PP
Under gcc, we use the __attribute__ macro to check variadic arguments, for instance to printf-style functions. Other compilers may be able to do something similar, but this is generally unnecessary since it's only realy purpose is to give warning messages when the developer compiles the code. 
.SH "Author"
.PP 
Generated automatically by Doxygen for LibGGZ from the source code.
