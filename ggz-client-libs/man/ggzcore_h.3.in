.TH "ggzcore.h" 3 "1 Oct 2002" "GGZCore" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ggzcore.h \- The interface for the ggzcore library used by GGZ clients. 
.SH SYNOPSIS
.br
.PP
\fC#include <sys/types.h>\fP
.br
\fC#include <stdarg.h>\fP
.br
\fC#include <poll.h>\fP
.br
\fC#include <ggz_common.h>\fP
.br
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_GGZOptions\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fB_GGZOptions\fP \fBGGZOptions\fP"
.br
.ti -1c
.RI "typedef \fBGGZHookReturn\fP(* \fBGGZHookFunc\fP )(unsigned int id, void *event_data, void *user_data)"
.br
.ti -1c
.RI "typedef void(* \fBGGZDestroyFunc\fP )(void *data)"
.br
.RI "\fIGGZ object destroy function type.\fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBGGZHookReturn\fP "
.br
.ti -1c
.RI "enum \fBGGZLoginType\fP { \fBGGZ_LOGIN\fP, \fBGGZ_LOGIN_GUEST\fP, \fBGGZ_LOGIN_NEW\fP }"
.br
.ti -1c
.RI "enum \fBGGZPlayerType\fP { \fBGGZ_PLAYER_NONE\fP, \fBGGZ_PLAYER_NORMAL\fP, \fBGGZ_PLAYER_GUEST\fP, \fBGGZ_PLAYER_ADMIN\fP }"
.br
.ti -1c
.RI "enum \fBGGZServerEvent\fP { \fBGGZ_CONNECTED\fP, \fBGGZ_CONNECT_FAIL\fP, \fBGGZ_NEGOTIATED\fP, \fBGGZ_NEGOTIATE_FAIL\fP, \fBGGZ_LOGGED_IN\fP, \fBGGZ_LOGIN_FAIL\fP, \fBGGZ_MOTD_LOADED\fP, \fBGGZ_ROOM_LIST\fP, \fBGGZ_TYPE_LIST\fP, \fBGGZ_ENTERED\fP, \fBGGZ_ENTER_FAIL\fP, \fBGGZ_LOGOUT\fP, \fBGGZ_NET_ERROR\fP, \fBGGZ_PROTOCOL_ERROR\fP, \fBGGZ_CHAT_FAIL\fP, \fBGGZ_STATE_CHANGE\fP, \fBGGZ_CHANNEL_CONNECTED\fP, \fBGGZ_CHANNEL_READY\fP, \fBGGZ_CHANNEL_FAIL\fP }"
.br
.ti -1c
.RI "enum \fBGGZRoomEvent\fP { \fBGGZ_PLAYER_LIST\fP, \fBGGZ_TABLE_LIST\fP, \fBGGZ_CHAT\fP, \fBGGZ_ANNOUNCE\fP, \fBGGZ_PRVMSG\fP, \fBGGZ_BEEP\fP, \fBGGZ_ROOM_ENTER\fP, \fBGGZ_ROOM_LEAVE\fP, \fBGGZ_TABLE_UPDATE\fP, \fBGGZ_TABLE_LAUNCHED\fP, \fBGGZ_TABLE_LAUNCH_FAIL\fP, \fBGGZ_TABLE_JOINED\fP, \fBGGZ_TABLE_JOIN_FAIL\fP, \fBGGZ_TABLE_LEFT\fP, \fBGGZ_TABLE_LEAVE_FAIL\fP, \fBGGZ_PLAYER_LAG\fP }"
.br
.ti -1c
.RI "enum \fBGGZGameEvent\fP { \fBGGZ_GAME_LAUNCHED\fP, \fBGGZ_GAME_LAUNCH_FAIL\fP, \fBGGZ_GAME_NEGOTIATED\fP, \fBGGZ_GAME_NEGOTIATE_FAIL\fP, \fBGGZ_GAME_PLAYING\fP, \fBGGZ_GAME_OVER\fP, \fBGGZ_GAME_IO_ERROR\fP, \fBGGZ_GAME_PROTO_ERROR\fP }"
.br
.ti -1c
.RI "enum \fBGGZChatOp\fP { \fBGGZ_CHAT_NORMAL\fP =  	0x40, \fBGGZ_CHAT_ANNOUNCE\fP = 	0x60, \fBGGZ_CHAT_BEEP\fP =  	0x80, \fBGGZ_CHAT_PERSONAL\fP = 	0xC0 }"
.br
.RI "\fIChat subops.\fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBggzcore_init\fP (\fBGGZOptions\fP options)"
.br
.ti -1c
.RI "void \fBggzcore_destroy\fP (void)"
.br
.ti -1c
.RI "GGZServer * \fBggzcore_server_new\fP (void)"
.br
.RI "\fICreate a new server object.\fP"
.ti -1c
.RI "int \fBggzcore_server_reset\fP (GGZServer *server)"
.br
.RI "\fIReset the server object.\fP"
.ti -1c
.RI "int \fBggzcore_server_add_event_hook\fP (GGZServer *server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func)"
.br
.RI "\fIRegister a callback handler for a server event.\fP"
.ti -1c
.RI "int \fBggzcore_server_add_event_hook_full\fP (GGZServer *server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func, void *data)"
.br
.RI "\fIRegister a callback handler for a server event.\fP"
.ti -1c
.RI "int \fBggzcore_server_remove_event_hook\fP (GGZServer *server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func)"
.br
.RI "\fIRemove a single hook function from an event's hook list.\fP"
.ti -1c
.RI "int \fBggzcore_server_remove_event_hook_id\fP (GGZServer *server, const \fBGGZServerEvent\fP event, const unsigned int hook_id)"
.br
.RI "\fIRemove a hook function with given ID from the event's hook list.\fP"
.ti -1c
.RI "int \fBggzcore_server_set_hostinfo\fP (GGZServer *server, const char *host, const unsigned int port)"
.br
.RI "\fISet host info for connecting to the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_set_logininfo\fP (GGZServer *server, const \fBGGZLoginType\fP type, const char *handle, const char *password)"
.br
.RI "\fISet login info for logging in to the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_log_session\fP (GGZServer *server, const char *filename)"
.br
.RI "\fIInitiate logging of ggzcore events.\fP"
.ti -1c
.RI "char * \fBggzcore_server_get_host\fP (GGZServer *server)"
.br
.RI "\fIGet the hostname of the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_get_port\fP (GGZServer *server)"
.br
.RI "\fIGet the port of the server.\fP"
.ti -1c
.RI "\fBGGZLoginType\fP \fBggzcore_server_get_type\fP (GGZServer *server)"
.br
.RI "\fIGet the login type being used for this server.\fP"
.ti -1c
.RI "char * \fBggzcore_server_get_handle\fP (GGZServer *server)"
.br
.RI "\fIGet the handle being used for this server.\fP"
.ti -1c
.RI "char * \fBggzcore_server_get_password\fP (GGZServer *server)"
.br
.RI "\fIGet the password being used for this server.\fP"
.ti -1c
.RI "int \fBggzcore_server_get_fd\fP (GGZServer *server)"
.br
.RI "\fIGet the socket used for connection with the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_get_channel\fP (GGZServer *server)"
.br
.RI "\fIGet the socket used for direct gane connections.\fP"
.ti -1c
.RI "GGZStateID \fBggzcore_server_get_state\fP (GGZServer *server)"
.br
.RI "\fIGet the state of the server connection.\fP"
.ti -1c
.RI "int \fBggzcore_server_get_num_rooms\fP (GGZServer *server)"
.br
.RI "\fIReturn the number of rooms on the server, or -1 on error.\fP"
.ti -1c
.RI "GGZRoom * \fBggzcore_server_get_cur_room\fP (GGZServer *server)"
.br
.RI "\fIReturn the current room, or NULL if there is none.\fP"
.ti -1c
.RI "GGZRoom * \fBggzcore_server_get_nth_room\fP (GGZServer *server, const unsigned int num)"
.br
.RI "\fIReturn the nth room on the server, or NULL on error.\fP"
.ti -1c
.RI "int \fBggzcore_server_get_num_gametypes\fP (GGZServer *server)"
.br
.RI "\fIReturn the overall number of game types on the server.\fP"
.ti -1c
.RI "GGZGameType * \fBggzcore_server_get_nth_gametype\fP (GGZServer *server, const unsigned int num)"
.br
.RI "\fIGet the nth gametype, or NULL on error.\fP"
.ti -1c
.RI "int \fBggzcore_server_connect\fP (GGZServer *server)"
.br
.RI "\fIConnect to the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_create_channel\fP (GGZServer *server)"
.br
.RI "\fIEstablish a direct connection.\fP"
.ti -1c
.RI "int \fBggzcore_server_login\fP (GGZServer *server)"
.br
.RI "\fILog in to the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_motd\fP (GGZServer *server)"
.br
.RI "\fIRequest the MOTD from the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_list_rooms\fP (GGZServer *server, const int type, const char verbose)"
.br
.RI "\fIRequest room list.\fP"
.ti -1c
.RI "int \fBggzcore_server_list_gametypes\fP (GGZServer *server, const char verbose)"
.br
.RI "\fIRequest game type list.\fP"
.ti -1c
.RI "int \fBggzcore_server_join_room\fP (GGZServer *server, const unsigned int room)"
.br
.RI "\fIJoin a room on the server.\fP"
.ti -1c
.RI "int \fBggzcore_server_logout\fP (GGZServer *server)"
.br
.RI "\fILog out of a server.\fP"
.ti -1c
.RI "int \fBggzcore_server_disconnect\fP (GGZServer *server)"
.br
.RI "\fIDisconnect from a server after having logged out.\fP"
.ti -1c
.RI "GGZRoom * \fBggzcore_room_new\fP (void)"
.br
.ti -1c
.RI "int \fBggzcore_room_init\fP (GGZRoom *room, const GGZServer *server, const unsigned int id, const char *name, const unsigned int game, const char *desc)"
.br
.ti -1c
.RI "void \fBggzcore_room_free\fP (GGZRoom *room)"
.br
.ti -1c
.RI "int \fBggzcore_table_set_seat\fP (GGZTable *table, const unsigned int seat, GGZSeatType type, char *name)"
.br
.RI "\fISet a seat type at a table, pre-launch.\fP"
.ti -1c
.RI "int \fBggzcore_table_get_seat_count\fP (GGZTable *table, GGZSeatType type)"
.br
.RI "\fICount the seats of the given type.\fP"
.ti -1c
.RI "char * \fBggzcore_table_get_nth_player_name\fP (GGZTable *table, const unsigned int num)"
.br
.RI "\fIReturn the name of a player at the table, or NULL on error.\fP"
.ti -1c
.RI "GGZSeatType \fBggzcore_table_get_nth_player_type\fP (GGZTable *table, const unsigned int num)"
.br
.RI "\fIReturn the type of a player at the table, or GGZ_PLAYER_NONE on error.\fP"
.ti -1c
.RI "int \fBggzcore_conf_write_string\fP (const char *section, const char *key, const char *value)"
.br
.ti -1c
.RI "int \fBggzcore_conf_write_int\fP (const char *section, const char *key, int value)"
.br
.ti -1c
.RI "int \fBggzcore_conf_write_list\fP (const char *section, const char *key, int argc, char **argv)"
.br
.ti -1c
.RI "char * \fBggzcore_conf_read_string\fP (const char *section, const char *key, const char *def)"
.br
.ti -1c
.RI "int \fBggzcore_conf_read_int\fP (const char *section, const char *key, int def)"
.br
.ti -1c
.RI "int \fBggzcore_conf_read_list\fP (const char *section, const char *key, int *argcp, char ***argvp)"
.br
.ti -1c
.RI "int \fBggzcore_conf_remove_section\fP (const char *section)"
.br
.ti -1c
.RI "int \fBggzcore_conf_remove_key\fP (const char *section, const char *key)"
.br
.ti -1c
.RI "int \fBggzcore_conf_commit\fP (void)"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
The interface for the ggzcore library used by GGZ clients.
.PP
.PP
.SH "TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef void(* GGZDestroyFunc)(void* data)"
.PP
GGZ object destroy function type.
.PP
\fBTodo: \fP
.in +1c
 This is not currently used.  
.SS "typedef \fBGGZHookReturn\fP(* GGZHookFunc)(unsigned int id, void* event_data, void* user_data)"
.PP
GGZ Event hook function type, used as a vallback for events 
.SS "typedef struct \fB_GGZOptions\fP  GGZOptions"
.PP
Options structure for ggzcore library 
.SH "ENUMERATION TYPE DOCUMENTATION"
.PP 
.SS "enum GGZChatOp"
.PP
Chat subops.
.PP
Each time we send a chat to the server, it will have one of these types associated with it. 
.PP
\fBSee also: \fP
.in +1c
ggzcore_room_chat 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_CHAT_NORMAL\fP \fP\fP
A normal chat, just a message sent to the current room. 
.TP
\fB\fI\fIGGZ_CHAT_ANNOUNCE\fP \fP\fP
An announcement, usually triggered with /wall. Only admins can do this, and it is announced in all rooms. 
.TP
\fB\fI\fIGGZ_CHAT_BEEP\fP \fP\fP
A beep. We beep a player, and their client will run the beep. 
.TP
\fB\fI\fIGGZ_CHAT_PERSONAL\fP \fP\fP
A personal message to another player. It consists of both a message and a target player. 
.SS "enum GGZGameEvent"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_GAME_LAUNCHED\fP \fP\fP
A game was launched by the player. 
.TP
\fB\fI\fIGGZ_GAME_LAUNCH_FAIL\fP \fP\fP
Game launch failed. 
.TP
\fB\fI\fIGGZ_GAME_NEGOTIATED\fP \fP\fP
Negotiation with server was successful. 
.TP
\fB\fI\fIGGZ_GAME_NEGOTIATE_FAIL\fP \fP\fP
Negotiation was not successful, game launch failed. 
.TP
\fB\fI\fIGGZ_GAME_PLAYING\fP \fP\fP
Game reached the 'playing' state. 
.TP
\fB\fI\fIGGZ_GAME_OVER\fP \fP\fP
A game is over. The player is going to leave the table. 
.TP
\fB\fI\fIGGZ_GAME_IO_ERROR\fP \fP\fP
Error: An input/output error happened. 
.TP
\fB\fI\fIGGZ_GAME_PROTO_ERROR\fP \fP\fP
Error: Protocol error caused by the game. 
.SS "enum GGZHookReturn"
.PP
GGZ Hook function return types 
.SS "enum GGZLoginType"
.PP
This controls the type of login a user chooses. A different value will require different information to be sent to the server. 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_LOGIN\fP \fP\fP
Standard login; uname and correct passwd needed. 
.TP
\fB\fI\fIGGZ_LOGIN_GUEST\fP \fP\fP
Guest login; only a uname is required. 
.TP
\fB\fI\fIGGZ_LOGIN_NEW\fP \fP\fP
New user login; only a uname is required. Password will be assigned by the server. 
.SS "enum GGZPlayerType"
.PP
The type of a player logged in. This is partially determined by the type of login. 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_PLAYER_NONE\fP \fP\fP
Not logged in. 
.TP
\fB\fI\fIGGZ_PLAYER_NORMAL\fP \fP\fP
Normal registered login. 
.TP
\fB\fI\fIGGZ_PLAYER_GUEST\fP \fP\fP
Login as guest. 
.TP
\fB\fI\fIGGZ_PLAYER_ADMIN\fP \fP\fP
Special case: Player has administrative privileges. 
.SS "enum GGZRoomEvent"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_PLAYER_LIST\fP \fP\fP
The list of players in a room has arrived. 
.TP
\fB\fI\fIGGZ_TABLE_LIST\fP \fP\fP
Received the list of active tables. 
.TP
\fB\fI\fIGGZ_CHAT\fP \fP\fP
Received a normal chat message, sent to all players. 
.TP
\fB\fI\fIGGZ_ANNOUNCE\fP \fP\fP
A chat announcement of a player, sent to all players. 
.TP
\fB\fI\fIGGZ_PRVMSG\fP \fP\fP
Private message from a player to the receiver. 
.TP
\fB\fI\fIGGZ_BEEP\fP \fP\fP
Beep message to the receiver. 
.TP
\fB\fI\fIGGZ_ROOM_ENTER\fP \fP\fP
Attempt to enter a room has been successful. 
.TP
\fB\fI\fIGGZ_ROOM_LEAVE\fP \fP\fP
A room could not be entered. 
.TP
\fB\fI\fIGGZ_TABLE_UPDATE\fP \fP\fP
Update at one of the tables. 
.TP
\fB\fI\fIGGZ_TABLE_LAUNCHED\fP \fP\fP
A new table has been launched successfully. 
.TP
\fB\fI\fIGGZ_TABLE_LAUNCH_FAIL\fP \fP\fP
Table could not be launched by the player. 
.TP
\fB\fI\fIGGZ_TABLE_JOINED\fP \fP\fP
Successfully joined an existing table. 
.TP
\fB\fI\fIGGZ_TABLE_JOIN_FAIL\fP \fP\fP
Joining a table did not succeed. 
.TP
\fB\fI\fIGGZ_TABLE_LEFT\fP \fP\fP
The player successfully left a table. 
.TP
\fB\fI\fIGGZ_TABLE_LEAVE_FAIL\fP \fP\fP
Failure leaving a table. 
.TP
\fB\fI\fIGGZ_PLAYER_LAG\fP \fP\fP
Lag message from the server to measure the connection speed. 
.SS "enum GGZServerEvent"
.PP
A GGZServerEvent is an event triggered by a communication from the server. Each time an event occurs, the associated event handler will be called. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_add_event_hook\fP 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIGGZ_CONNECTED\fP \fP\fP
We have just made a connection to the server. 
.PP
\fBNote: \fP
.in +1c
This just means we've established a connection socket. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_connect\fP 
.TP
\fB\fI\fIGGZ_CONNECT_FAIL\fP \fP\fP
Error: we have failed to connect to the server. 
.TP
\fB\fI\fIGGZ_NEGOTIATED\fP \fP\fP
We have negotiated a connection to the server. 
.PP
\fBNote: \fP
.in +1c
This just means we've determined ggzd is at the other end. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_connect\fP 
.TP
\fB\fI\fIGGZ_NEGOTIATE_FAIL\fP \fP\fP
Error: negotiation failure. Could be the wrong version... 
.TP
\fB\fI\fIGGZ_LOGGED_IN\fP \fP\fP
We have successfully logged in. We can now start doing stuff. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_login\fP 
.TP
\fB\fI\fIGGZ_LOGIN_FAIL\fP \fP\fP
Error: login failure 
.TP
\fB\fI\fIGGZ_MOTD_LOADED\fP \fP\fP
The MOTD has been read from the server and can be displayed. 
.TP
\fB\fI\fIGGZ_ROOM_LIST\fP \fP\fP
The room list arrived. It is very likely followed by the game type list. 
.TP
\fB\fI\fIGGZ_TYPE_LIST\fP \fP\fP
The list of game types is available. 
.TP
\fB\fI\fIGGZ_ENTERED\fP \fP\fP
We have successfully entered a room. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_join_room\fP 
.TP
\fB\fI\fIGGZ_ENTER_FAIL\fP \fP\fP
Error: we have tried to enter a room and failed. 
.TP
\fB\fI\fIGGZ_LOGOUT\fP \fP\fP
Logged out of the server. 
.TP
\fB\fI\fIGGZ_NET_ERROR\fP \fP\fP
Error: a network error occurred. 
.TP
\fB\fI\fIGGZ_PROTOCOL_ERROR\fP \fP\fP
Error: a communication protocol error occured. 
.TP
\fB\fI\fIGGZ_CHAT_FAIL\fP \fP\fP
Error: A chat message could not be sent. 
.TP
\fB\fI\fIGGZ_STATE_CHANGE\fP \fP\fP
The internal state of ggzcore has changed. 
.TP
\fB\fI\fIGGZ_CHANNEL_CONNECTED\fP \fP\fP
Status event: a requested direct game connection has been established. 
.TP
\fB\fI\fIGGZ_CHANNEL_READY\fP \fP\fP
Game channel is ready for read/write operations. 
.TP
\fB\fI\fIGGZ_CHANNEL_FAIL\fP \fP\fP
Error: Failure during setup of direct connection to game server. 
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "int ggzcore_conf_commit (void)"
.PP
\fBggzcore_conf_commit()\fP - Commits the core user config file to disk
.PP
@return: int : 0 if successful, -1 on error 
.SS "int ggzcore_conf_read_int (const char * section, const char * key, int def)"
.PP
\fBggzcore_conf_read_int()\fP - Read a integer from the configuration file(s)
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to get value from 
.TP
\fB\fIkey\fP\fP
key value was stored under 
.TP
\fB\fIdef\fP\fP
default value to return if none is found
.PP
\fBReturns: \fP
.in +1c
 an integer from the configuration file OR the default value
.PP
\fBNote: \fP
.in +1c
There is no guaranteed way to find if the call failed. If you must know, call ggzcore_conf_read_string with a NULL default value and check for the NULL return. 
.SS "int ggzcore_conf_read_list (const char * section, const char * key, int * argcp, char *** argvp)"
.PP
\fBggzcore_conf_read_list()\fP - Read a list from the configuration file(s)
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to get value from 
.TP
\fB\fIkey\fP\fP
key value was stored under 
.TP
\fB\fIargcp\fP\fP
ptr to int which will receive the list entry count 
.TP
\fB\fIargvp\fP\fP
a pointer to a dynamically allocated array that \fBggzcore_conf_read_list()\fP will build
.PP
\fBReturns: \fP
.in +1c
int : 0 if successful, -1 on error 
.SS "char* ggzcore_conf_read_string (const char * section, const char * key, const char * def)"
.PP
\fBggzcore_conf_read_string()\fP - Read a string from the configuration file(s)
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to get value from 
.TP
\fB\fIkey\fP\fP
key value was stored under 
.TP
\fB\fIdef\fP\fP
default value to return if none is found
.PP
\fBReturns: \fP
.in +1c
 a dynamically allocated string from the configuration file OR a dynamically allocated copy of the default string
.PP
\fBNote: \fP
.in +1c
The default may be set to NULL, in which case a NULL will be returned if the value could not be found in either configuration file. 
.SS "int ggzcore_conf_remove_key (const char * section, const char * key)"
.PP
\fBggzcore_conf_remove_key()\fP - Removes a key entry from the user config file
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to remove 
.TP
\fB\fIkey\fP\fP
key entry to remove
.PP
\fBReturns: \fP
.in +1c
 int : 0 if success, -1 on error, 1 on soft error (section/key didn't exist) 
.SS "int ggzcore_conf_remove_section (const char * section)"
.PP
\fBggzcore_conf_remove_section()\fP - Removes a section from the user config file
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to remove
.PP
\fBReturns: \fP
.in +1c
 int : 0 if successful, -1 on error, 1 on soft error (section did not exist) 
.SS "int ggzcore_conf_write_int (const char * section, const char * key, int value)"
.PP
\fBggzcore_conf_write_int()\fP - Write a integer to the user config file
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to store value in 
.TP
\fB\fIkey\fP\fP
key to store value under 
.TP
\fB\fIvalue\fP\fP
value to store
.PP
\fBReturns: \fP
.in +1c
int : 0 if successful, -1 on error 
.SS "int ggzcore_conf_write_list (const char * section, const char * key, int argc, char ** argv)"
.PP
\fBggzcore_conf_write_list()\fP - Write a list to the user config file
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to store value in 
.TP
\fB\fIkey\fP\fP
key to store value under 
.TP
\fB\fIargc\fP\fP
count of string arguments in list 
.TP
\fB\fIargv\fP\fP
array of NULL terminated strings
.PP
\fBReturns: \fP
.in +1c
int : 0 if successful, -1 on error 
.SS "int ggzcore_conf_write_string (const char * section, const char * key, const char * value)"
.PP
\fBggzcore_conf_write_string()\fP - Write a string to the user config file
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsection\fP\fP
section to store value in 
.TP
\fB\fIkey\fP\fP
key to store value under 
.TP
\fB\fIvalue\fP\fP
value to store
.PP
\fBReturns: \fP
.in +1c
int : 0 if successful, -1 on error 
.SS "void ggzcore_destroy (void)"
.PP
\fBggzcore_destroy()\fP - Cleanup function for ggzcore lib. 
.SS "int ggzcore_init (\fBGGZOptions\fP options)"
.PP
\fBggzcore_init()\fP - Initializtion function for ggzcore lib.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIoptions\fP\fP
options structure
.PP
\fBReturns: \fP
.in +1c
int : 0 if successful, -1 on failure 
.SS "void ggzcore_room_free (GGZRoom * room)"
.PP
De-allocate room object and its children 
.SS "int ggzcore_room_init (GGZRoom * room, const GGZServer * server, const unsigned int id, const char * name, const unsigned int game, const char * desc)"
.PP
Initialize room object 
.SS "GGZRoom* ggzcore_room_new (void)"
.PP
Allocate space for a new room object 
.SS "int ggzcore_server_add_event_hook (GGZServer * server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func)"
.PP
Register a callback handler for a server event.
.PP
Call this function to register the given GGZHookFunc as a handler for the given event. Then any time that event happens the handler function will be called. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIevent\fP\fP
The server event to be handled. 
.TP
\fB\fIfunc\fP\fP
The handler function to be called when the event occurs. 
.PP
\fBReturns: \fP
.in +1c
A hook ID value to identify this handler. 
.PP
\fBNote: \fP
.in +1c
Equivalent to ggzcore_server_add_event_hook_full with data==NULL. 
.in -1c
.in +1c
More than one handler can be registered for each event. 
.SS "int ggzcore_server_add_event_hook_full (GGZServer * server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func, void * data)"
.PP
Register a callback handler for a server event.
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_add_event_hook\fP 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIdata\fP\fP
An arbitrary pointer that will be passed to the hook function. 
.SS "int ggzcore_server_connect (GGZServer * server)"
.PP
Connect to the server.
.PP
Call this function to initially connect to a GGZ server. Connection info is set using the ggzcore_server_set_hostinfo function.
.PP
The function is asynchronous and will return very quickly. After the connection is (hopefully) established we will receive either a GGZ_CONNECTED or GGZ_CONNECT_FAIL server event. If the connection succeeds, negotiations with the GGZ server will begin automatically. Once this is complete, we will receive either a GGZ_NEGOTIATED or GGZ_NEGOTIATE_FAIL event.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure. 
.PP
\fBNote: \fP
.in +1c
On success a GGZ_CONNECTED event will be generated. 
.in -1c
.in +1c
On failure a GGZ_CONNECT_FAIL event may or may not be generated. 
.SS "int ggzcore_server_create_channel (GGZServer * server)"
.PP
Establish a direct connection.
.PP
Direct connections are requested for games. They are similar to connections, instead of that no login takes place, but a channel for arbitrary game data is created.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure. 
.SS "int ggzcore_server_get_channel (GGZServer * server)"
.PP
Get the socket used for direct gane connections.
.PP
This returns the file descriptor of the socket for the TCP game connection. This will be handed off to a game module  when it is ready.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The file descriptor of the connection socket. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_create_channel\fP 
.SS "int ggzcore_server_get_fd (GGZServer * server)"
.PP
Get the socket used for connection with the server.
.PP
This returns the file descriptor of the primary socket for the TCP connection to the server. All GGZ data goes across this socket.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The file descriptor of the connection socket. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_connect\fP 
.SS "char* ggzcore_server_get_handle (GGZServer * server)"
.PP
Get the handle being used for this server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
A string containing the handle, or NULL on error. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_set_logininfo\fP 
.SS "char* ggzcore_server_get_host (GGZServer * server)"
.PP
Get the hostname of the server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
A string containing the host name, or NULL on error. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_set_hostinfo\fP 
.SS "int ggzcore_server_get_num_gametypes (GGZServer * server)"
.PP
Return the overall number of game types on the server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The number of game types on this server, or -1 on error. 
.PP
\fBNote: \fP
.in +1c
This number is 0 until 
.PP
\fBSee also: \fP
.in +1c
\fBGGZ_TYPE_LIST\fP. 
.SS "int ggzcore_server_get_num_rooms (GGZServer * server)"
.PP
Return the number of rooms on the server, or -1 on error.
.PP
\fBNote: \fP
.in +1c
Until we retrieve the list of rooms, this will return 0. 
.SS "char* ggzcore_server_get_password (GGZServer * server)"
.PP
Get the password being used for this server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
A string containing the password, or NULL on error. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_set_logininfo\fP 
.SS "int ggzcore_server_get_port (GGZServer * server)"
.PP
Get the port of the server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The port number of the server, or -1 on error. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_set_hostinfo\fP 
.SS "GGZStateID ggzcore_server_get_state (GGZServer * server)"
.PP
Get the state of the server connection.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The state of the connection, or -1 on error. 
.SS "\fBGGZLoginType\fP ggzcore_server_get_type (GGZServer * server)"
.PP
Get the login type being used for this server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
The login type set for the server, or -1 on error. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_set_logininfo\fP 
.SS "int ggzcore_server_join_room (GGZServer * server, const unsigned int room)"
.PP
Join a room on the server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIroom\fP\fP
The number of the room to join. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure (e.g. non-existing room number). 
.SS "int ggzcore_server_list_gametypes (GGZServer * server, const char verbose)"
.PP
Request game type list.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIverbose\fP\fP
Receive detailed gametype information or not. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure. 
.PP
\fBNote: \fP
.in +1c
A GGZ_TYPE_LIST event will be the asynchronous response on success. 
.SS "int ggzcore_server_list_rooms (GGZServer * server, const int type, const char verbose)"
.PP
Request room list.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fItype\fP\fP
Not used yet. 
.TP
\fB\fIverbose\fP\fP
Receive all information about a room or only the essentials. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure. 
.PP
\fBNote: \fP
.in +1c
A GGZ_ROOM_LIST might be generated thereafter. 
.SS "int ggzcore_server_log_session (GGZServer * server, const char * filename)"
.PP
Initiate logging of ggzcore events.
.PP
Normally, ggzcore traffic is not logged anywhere. With this functions, such output can be directed into a file. It contains all the network messages received from the server.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIfilename\fP\fP
The file the messages are written to. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on error. 
.SS "int ggzcore_server_login (GGZServer * server)"
.PP
Log in to the server.
.PP
Call this function to log in to the server once a connection has been established. Typically you must first connect to the server, then wait to receive the GGZ_CONNECTED and GGZ_NEGOTIATED events before attempting to log in. Login info is set using the ggzcore_server_set_logininfo function.
.PP
The function is asynchronous and will return immediately. After the login request is sent, we will wait to receive either a GGZ_LOGGED_IN or GGZ_LOGIN_FAIL server event.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on failure. 
.PP
\fBNote: \fP
.in +1c
On failure no events will be generated. 
.SS "GGZServer* ggzcore_server_new (void)"
.PP
Create a new server object.
.PP
Call this function to create a server object. This object holds all state data for communicating with a ggz server. It is necessary for any kind of connection. 
.SS "int ggzcore_server_remove_event_hook (GGZServer * server, const \fBGGZServerEvent\fP event, const \fBGGZHookFunc\fP func)"
.PP
Remove a single hook function from an event's hook list.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIevent\fP\fP
The server event the hook is associated with. 
.TP
\fB\fIfunc\fP\fP
The function to be removed from the hook list. 
.PP
\fBReturns: \fP
.in +1c
0 on success (hook removed); -1 on failure (no hook removed) 
.PP
\fBNote: \fP
.in +1c
At most one copy of the function will be removed. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_remove_event_hook_id\fP 
.SS "int ggzcore_server_remove_event_hook_id (GGZServer * server, const \fBGGZServerEvent\fP event, const unsigned int hook_id)"
.PP
Remove a hook function with given ID from the event's hook list.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIevent\fP\fP
The server event the hook is associated with. 
.TP
\fB\fIhook_id\fP\fP
The ID of the hook event. 
.PP
\fBReturns: \fP
.in +1c
0 on success (hook removed); -1 on failure (no hook removed) 
.PP
\fBNote: \fP
.in +1c
The hook ID is given by ggzcore_server_add_event_hook 
.SS "int ggzcore_server_reset (GGZServer * server)"
.PP
Reset the server object.
.PP
After you've disconnected, call this function to discard all state data and reset the state of the server object. You can then connect again. 
.PP
\fBNote: \fP
.in +1c
You should disconnect before resetting. 
.SS "int ggzcore_server_set_hostinfo (GGZServer * server, const char * host, const unsigned int port)"
.PP
Set host info for connecting to the server.
.PP
Call this function to set host info for the GGZ server before trying to connect to it.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fIhost\fP\fP
A string containing the hostname. 
.TP
\fB\fIport\fP\fP
The port to connect to. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on error. 
.PP
\fBNote: \fP
.in +1c
Should never fail when given valid input. 
.PP
\fBSee also: \fP
.in +1c
\fBggzcore_server_connect\fP 
.SS "int ggzcore_server_set_logininfo (GGZServer * server, const \fBGGZLoginType\fP type, const char * handle, const char * password)"
.PP
Set login info for logging in to the server.
.PP
Call this function to set login info for the GGZ server before trying to login.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIserver\fP\fP
The GGZ server object. 
.TP
\fB\fItype\fP\fP
The type of login to attempt. 
.TP
\fB\fIhandle\fP\fP
The username to use with the server. 
.TP
\fB\fIpassword\fP\fP
The password to use (may be NULL with some login types). 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on error. 
.SS "int ggzcore_table_get_seat_count (GGZTable * table, GGZSeatType type)"
.PP
Count the seats of the given type.
.PP
Given a table and a seat type, this function returns the number of seats at the table that match the type.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A GGZ table. 
.TP
\fB\fItype\fP\fP
A GGZSeatType. 
.PP
\fBReturns: \fP
.in +1c
The number of seats matching the type, or -1 on error. 
.SS "int ggzcore_table_set_seat (GGZTable * table, const unsigned int seat, GGZSeatType type, char * name)"
.PP
Set a seat type at a table, pre-launch.
.PP
When launching a table, call this function to set up a particular seat at the table. It can also be used to fiddle with already existing tables, but that would be extremely unwise.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
The table object to change. 
.TP
\fB\fIseat\fP\fP
The seat number at the table to change. 
.TP
\fB\fItype\fP\fP
The type of seat to make it (open, reserved, or bot). 
.TP
\fB\fIname\fP\fP
The name of the seat (must be valid for reserved seats). 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 on error. 
.PP
\fBTodo: \fP
.in +1c
 How do we stop the GGZ client from fiddling with random tables?  
.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for GGZCore from the source code.
