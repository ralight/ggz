? common.c
? common.h
? protocol.c
? protocol.h
Index: Makefile.am
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/Makefile.am,v
retrieving revision 1.12
diff -u -r1.12 Makefile.am
--- Makefile.am	2001/07/14 03:59:45	1.12
+++ Makefile.am	2001/12/13 14:16:01
@@ -28,8 +28,11 @@
 	cb_bid.c cb_bid.h \
 	dlg_about.c dlg_about.h \
 	cards-b1.xpm cards-b2.xpm cards-b3.xpm cards-b4.xpm \
-	cards.xpm
+	cards.xpm \
+	\
+	common.c common.h \
+	protocol.c protocol.h
 
 CFLAGS = @GTK_CFLAGS@ @CFLAGS@
-ggz_lapocha_LDADD = @GTK_LIBS@ $(LDADD)
+ggz_lapocha_LDADD = @GTK_LIBS@ $(LDADD) -lggz
 
Index: cb_main.c
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/cb_main.c,v
retrieving revision 1.4
diff -u -r1.4 cb_main.c
--- cb_main.c	2000/08/20 22:03:36	1.4
+++ cb_main.c	2001/12/13 14:16:01
@@ -30,6 +30,7 @@
 
 #include "cb_main.h"
 #include "dlg_main.h"
+#include "dlg_main.h"
 #include "dlg_about.h"
 #include "support.h"
 #include "table.h"
Index: dlg_bid.h
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/dlg_bid.h,v
retrieving revision 1.2
diff -u -r1.2 dlg_bid.h
--- dlg_bid.h	2000/08/15 03:28:51	1.2
+++ dlg_bid.h	2001/12/13 14:16:01
@@ -22,6 +22,8 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
 
+#include <gtk/gtk.h>
+
 extern void dlg_bid_setup(GtkWidget *);
 extern void dlg_bid_display(int);
 
Index: game.c
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/game.c,v
retrieving revision 1.5
diff -u -r1.5 game.c
--- game.c	2000/08/15 03:28:51	1.5
+++ game.c	2001/12/13 14:16:01
@@ -28,6 +28,8 @@
 
 #include <gtk/gtk.h>
 
+#include "common.h"
+
 #include "main.h"
 #include "game.h"
 #include "easysock.h"
@@ -37,10 +39,9 @@
 
 void game_send_bid(int bid)
 {
-	es_write_int(game.fd, LP_SND_BID);
-	es_write_char(game.fd, bid);
+	client_send_bid(bid);
 
-	game.bid[game.me] = bid;
+	game.bid[0] = bid;
 
 	statusbar_message("Sending bid to server");
 }
@@ -48,8 +49,7 @@
 
 void game_play_card(int card)
 {
-	es_write_int(game.fd, LP_SND_PLAY);
-	es_write_char(game.fd, (char)card);
+	client_send_play(ggzcards.players[0].hand.card[card]);
 
 	statusbar_message("Sending play to server");
 }
@@ -71,8 +71,7 @@
 		trump = 3;
 
 	/* Send out our choice of trump */
-	es_write_int(game.fd, LP_SND_TRUMP);
-	es_write_char(game.fd, trump);
+	client_send_bid(trump);
 
 	statusbar_message("Sending trump selection to server");
 }
Index: game.h
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/game.h,v
retrieving revision 1.11
diff -u -r1.11 game.h
--- game.h	2001/12/11 07:18:13	1.11
+++ game.h	2001/12/13 14:16:01
@@ -22,21 +22,21 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
 
+#include "protocol.h"
+
 struct game_t {
-	int fd;
-	int me;
-	int seats[4];
-	int score[4];
-	int bid[4];
-	int tricks[4];
-	int num_cards[4];
-	char names[4][17];
-	char state;
+	int score[4]; /* scores of each player */
+	int bid[4]; /* what each player has bid */
+	int tricks[4]; /* how many tricks each has taken */
+	
+	char state; /* the current game state */
 	char move;
 	char trump_suit;
-	char got_players;
+	/* char got_players; */
 	char dealer;
 	char lead;
+	
+	int selected_card;
 };
 extern struct game_t game;
 
@@ -44,25 +44,6 @@
 extern void game_play_card(int);
 extern void game_handle_table_click(char);
 
-/* LaPocha protocol */
-/* Messages from server */
-#define LP_MSG_SEAT     0
-#define LP_MSG_PLAYERS  1
-#define LP_MSG_GAMEOVER 2
-#define LP_MSG_HAND     3
-#define LP_REQ_BID	4
-#define LP_RSP_BID	5
-#define LP_MSG_BID	6
-#define LP_REQ_PLAY     7
-#define LP_RSP_PLAY     8
-#define LP_MSG_PLAY	9
-#define LP_SND_SYNC     10
-#define LP_MSG_TRUMP	11
-#define LP_REQ_TRUMP	12
-#define LP_MSG_TRICK	13
-#define LP_MSG_SCORES	14
-#define LP_RSP_TRUMP    15
-
 /* Play errors */
 #define LP_ERR_STATE       -2
 #define LP_ERR_TURN        -3
@@ -70,13 +51,6 @@
 #define LP_ERR_FOLLOW_SUIT -5
 #define LP_ERR_MUST_TRUMP  -6
 
-/* Messages from client */
-#define LP_SND_PLAY     0
-#define LP_SND_BID      1
-#define LP_REQ_SYNC     2
-#define LP_REQ_NEWGAME  3
-#define LP_SND_TRUMP	4
-
 /* LaPocha game states */
 #define LP_STATE_INIT		0
 #define LP_STATE_WAIT		1
@@ -87,15 +61,6 @@
 #define LP_STATE_OPPONENT	6
 #define LP_STATE_CHOOSE		7
 #define LP_STATE_TRUMP		8
-
-/* LaPocha server states (for resync) */
-#define LP_SERVER_INIT		0
-#define LP_SERVER_WAIT		1
-#define LP_SERVER_NEW_HAND	2
-#define LP_SERVER_GET_TRUMP	3
-#define LP_SERVER_BIDDING	4
-#define LP_SERVER_PLAYING	5
-#define LP_SERVER_DONE		6
 
 /* LaPocha game events */
 #define LP_EVENT_LAUNCH      0
Index: hand.c
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/hand.c,v
retrieving revision 1.4
diff -u -r1.4 hand.c
--- hand.c	2000/08/15 03:28:51	1.4
+++ hand.c	2001/12/13 14:16:01
@@ -21,47 +21,3 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <gtk/gtk.h>
-
-#include <easysock.h>
-
-#include "game.h"
-#include "table.h"
-#include "hand.h"
-
-struct hand_t hand;
-
-/* hand_read_hand()
- *   Sets the cards in our hand based on a server message
- */
-int hand_read_hand(void)
-{
-	int i;
-
-	/* Zap our hand */
-	for(i=0; i<10; i++)
-		hand.card[i] = -1;
-	hand.selected_card = -1;
-
-	/* First find out how many cards in this hand */
-	if(es_read_char(game.fd, &hand.hand_size) < 0)
-		return -1;
-
-	/* Read in all the card values */
-	for(i=0; i<hand.hand_size; i++)
-		if(es_read_char(game.fd, &hand.card[i]) < 0)
-			return -1;
-
-	/* Everyone got dealt this many cards */
-	for(i=0; i<4; i++)
-		game.num_cards[i] = hand.hand_size;
-
-	table_display_hand();
-
-	return 0;
-}
Index: hand.h
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/hand.h,v
retrieving revision 1.4
diff -u -r1.4 hand.h
--- hand.h	2000/08/15 03:28:51	1.4
+++ hand.h	2001/12/13 14:16:01
@@ -21,15 +21,3 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
-
-struct hand_t {
-	char hand_size;
-	char card[13];
-	char selected_card;
-	char in_play_card_num;
-	char in_play_card_val;
-};
-
-extern struct hand_t hand;
-
-extern int hand_read_hand(void);
Index: main.c
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/main.c,v
retrieving revision 1.18
diff -u -r1.18 main.c
--- main.c	2001/08/25 20:13:38	1.18
+++ main.c	2001/12/13 14:16:02
@@ -32,12 +32,15 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <assert.h>
 #include <stdio.h>
 #include <unistd.h>
 
 #include <easysock.h>
-#include <ggz_client.h>
+#include <ggz.h>
 
+#include "common.h"
+
 #include "support.h"
 #include "main.h"
 #include "dlg_main.h"
@@ -50,212 +53,50 @@
 
 /* Private functions */
 static void game_handle_io(gpointer data, gint source, GdkInputCondition cond);
-static void game_init(void);
-static int get_seat(void);
-static int get_players(void);
-static int get_gameover_status(void);
-static int get_sync_info(void);
-static int get_bid_status(void);
-static int get_player_bid(void);
-static int get_trump_suit(void);
-static int get_play_status(void);
-static int get_opponent_play(void);
-static int get_trick_winner(void);
-static int get_current_scores(void);
-static int get_trump_status(void);
-static int get_dealer(void);
+// static int get_sync_info(void);
 
 
 int main(int argc, char *argv[])
 {
+	int fd;
+#ifdef DEBUG
+	const char *debugging_types[] = { "main", "table", NULL };
+#else
+	const char *debugging_types[] = { NULL };
+#endif
+
+	ggz_debug_init(debugging_types, NULL);
+	ggz_debug("main", "Starting GGZCards client.");
+
 	gtk_init(&argc, &argv);
 
-	game.fd = ggz_connect();
-	if (game.fd < 0) return -1;
+	fd = client_initialize();
+	if (fd < 0)
+		return -1;
 
-	gdk_input_add(game.fd, GDK_INPUT_READ, game_handle_io, NULL);
+	gdk_input_add(fd, GDK_INPUT_READ, game_handle_io, NULL);
 
 	dlg_main = create_dlg_main();
 
 	gtk_widget_show(dlg_main);
 
 	table_initialize();
-	game_init();
+	table_get_newgame();
 
 	gtk_main();
 
-	if (ggz_disconnect() < 0)
-		return -2;
+	client_quit();
 
 	return 0;
 }
 
-
-#ifdef DEBUG
-char *opstr[] = { "LP_MSG_SEAT",    "LP_MSG_PLAYERS",    "LP_MSG_GAMEOVER",
-		  "LP_MSG_HAND",    "LP_REQ_BID",        "LP_RSP_BID",
-                  "LP_MSG_BID",     "LP_REQ_PLAY",       "LP_RSP_PLAY",
-                  "LP_MSG_PLAY",    "LP_SND_SYNC",       "LP_MSG_TRUMP",
-		  "LP_REQ_TRUMP",   "LP_MSG_TRICK",      "LP_MSG_SCORES",
-		  "LP_RSP_TRUMP" };
-#endif
-
 static void game_handle_io(gpointer data, gint source, GdkInputCondition cond)
-{
-	int op, status;
-	int i;
-
-	if(es_read_int(game.fd, &op) < 0) {
-		/* FIXME: do something here... */
-		return;
-	}
-
-	status = 0;
-#ifdef DEBUG
-	fprintf(stderr, "%s\n", opstr[op]);
-#endif
-	switch(op) {
-		case LP_MSG_SEAT:
-			status = get_seat();
-			break;
-		case LP_MSG_PLAYERS:
-			status = get_players();
-			if(game.state != LP_STATE_CHOOSE)
-				game.state = LP_STATE_WAIT;
-			break;
-		case LP_MSG_GAMEOVER:
-			status = get_gameover_status();
-			break;
-		case LP_MSG_HAND:
-			game.trump_suit = -1;
-			table_set_trump();
-			status = get_dealer();
-			if(status == 0)
-				status = hand_read_hand();
-			break;
-		case LP_REQ_BID:
-			for(i=0; i<4; i++)
-				game.tricks[i] = 0;
-			game.state = LP_STATE_BID;
-			dlg_bid_display(hand.hand_size);
-			status = 0;
-			break;
-		case LP_RSP_BID:
-			status = get_bid_status();
-			break;
-		case LP_MSG_BID:
-			status = get_player_bid();
-			break;
-		case LP_REQ_PLAY:
-			if(game.state == LP_STATE_ANIM)
-				table_animation_zip(TRUE);
-			game.state = LP_STATE_PLAY;
-			statusbar_message("Your turn to play a card");
-			status = 0;
-			break;
-		case LP_RSP_PLAY:
-			status = get_play_status();
-			break;
-		case LP_MSG_PLAY:
-			status = get_opponent_play();
-			break;
-		case LP_SND_SYNC:
-			status = get_sync_info();
-			break;
-		case LP_MSG_TRUMP:
-			status = get_trump_suit();
-			break;
-		case LP_REQ_TRUMP:
-			status = 0;
-			table_show_cards(0, 13, 39, 26);
-			game.state = LP_STATE_TRUMP;
-			statusbar_message("Please choose the trump suit");
-			break;
-		case LP_MSG_TRICK:
-			status = get_trick_winner();
-			break;
-		case LP_MSG_SCORES:
-			status = get_current_scores();
-			break;
-		case LP_RSP_TRUMP:
-			status = get_trump_status();
-			break;
-		default:
-			fprintf(stderr, "Unknown opcode received %d\n", op);
-			status = -1;
-			break;
-	}
-
-	if(status == -1) {
-		fprintf(stderr, "Lost connection to server?!\n");
-		close(game.fd);
-		exit(-1);
-	}
-}
-
-
-static void game_init(void)
-{
-	statusbar_message("Waiting for server");
-	game.state = LP_STATE_INIT;
-}
-
-
-static int get_seat(void)
 {
-	if(es_read_int(game.fd, &game.me) < 0)
-		return -1;
-	return 0;
+	client_handle_server();
 }
 
-
-static int get_players(void)
-{
-	int i, left=0;
-	char *temp;
-	char t_name[17];
-
-	for(i=0; i<4; i++) {
-		if(es_read_int(game.fd, &game.seats[i]) < 0)
-			return -1;
-		if(game.seats[i] != GGZ_SEAT_OPEN) {
-			if(es_read_string(game.fd, (char *)&t_name, 17) < 0)
-				return -1;
-			if(i != game.me && game.got_players
-			   &&  strcmp(t_name, game.names[i])) {
-				temp = g_strdup_printf("%s joined the table",
-							t_name);
-				statusbar_message(temp);
-				g_free(temp);
-			}
-			strcpy(game.names[i], t_name);
-			table_set_name(i, game.names[i]);
-		} else {
-			table_set_name(i, "Empty Seat");
-			if(game.names[i][0] != '\0' && game.got_players) {
-				temp = g_strdup_printf("%s left the table",
-							game.names[i]);
-				game.names[i][0] = '\0';
-				statusbar_message(temp);
-				g_free(temp);
-				left++;
-			}
-		}
-	}
-
-	game.got_players++;
-
-	if(left && game.state == LP_STATE_BID)
-		gtk_widget_hide(dlg_bid_fixed);
-	if(left && game.state == LP_STATE_TRUMP)
-		table_clear_table();
-	if(left)
-		game.state = LP_STATE_WAIT;
-
-	return 0;
-}
 
-
+#if 0 /* Disabled for now */
 static int get_sync_info(void)
 {
 	int i;
@@ -337,7 +178,7 @@
 					return -1;
 
 			/* Display the cards on the table */
-			table_show_cards_pnum(cur_table[0], cur_table[1],
+			table_show_cards(cur_table[0], cur_table[1],
 					      cur_table[2], cur_table[3]);
 
 			game.state = LP_STATE_WAIT;
@@ -348,33 +189,7 @@
 
 	return 0;
 }
-
-
-static int get_gameover_status(void)
-{
-	char winner;
-	char *t_str;
-
-	if(es_read_char(game.fd, &winner) < 0)
-		return -1;
-
-	t_str = g_strdup_printf("%s won the game", game.names[(int)winner]);
-	statusbar_message(t_str);
-	g_free(t_str);
-	game.state = LP_STATE_DONE;
-
-	return 0;
-}
-
-
-static void handle_req_newgame(void)
-{
-	/* Reinitialize the game data and board */
-	game_init();
-
-	/* Send a game request to the server */
-	es_write_int(game.fd, LP_REQ_NEWGAME);
-}
+#endif
 
 
 void statusbar_message(char *msg)
@@ -392,162 +207,141 @@
 }
 
 
-static int get_bid_status(void)
-{
-	char status;
+/*
+ * GGZCards client-common callback functions
+ */
 
-	if(es_read_char(game.fd, &status) < 0)
-		return -1;
-
-	if(status == 0) {
-		table_set_bid(game.me, game.bid[game.me]);
-		statusbar_message("Your bid was accepted");
-		game.state = LP_STATE_WAIT;
-		table_set_bidder(game.me);
-	} else if(status == LP_ERR_INVALID) {
-		dlg_bid_display(hand.hand_size);
-		statusbar_message("Invalid bid, please resubmit");
-	}
-
-	return status;
+ void table_get_newgame(void)
+{
+	client_send_newgame();
 }
-
 
-static int get_trump_status(void)
+void table_alert_newgame(void)
 {
-	char status;
-
-	if(es_read_char(game.fd, &status) < 0)
-		return -1;
-
-	if(status == 0) {
-		statusbar_message("Your trump was accepted");
-		game.state = LP_STATE_WAIT;
-		table_clear_table();
-	} else if(status == LP_ERR_INVALID)
-		statusbar_message("Invalid trump, this shouldn't happen");
-
-	return status;
+	/* Reinitialize the game data and board */
+	statusbar_message("Waiting for server");
+	game.state = LP_STATE_INIT;
 }
-
 
-static int get_player_bid(void)
+void table_handle_gameover(int num_winners, int *winners)
 {
-	char cnum;
-	int num;
-	char bid;
 	char *t_str;
-
-	if(es_read_char(game.fd, &cnum) < 0
-	   || es_read_char(game.fd, &bid) < 0)
-		return -1;
-	num = cnum;
-
-	game.bid[num] = bid;
-	table_set_bid(num, bid);
-
-	t_str = g_strdup_printf("%s bid %d", game.names[num], game.bid[num]);
+	int winner;
+	
+	assert(num_winners >= 1);
+	winner = winners[0]; /* FIXME: we discard the rest! */
+	
+	t_str = g_strdup_printf("%s won the game", ggzcards.players[winner].name);
 	statusbar_message(t_str);
 	g_free(t_str);
-
-	table_set_bidder(cnum);
+	
+	game.state = LP_STATE_DONE;
+}
 
-	return 0;
+void table_alert_player(int player, GGZSeatType status, const char *name)
+{	
+	char *temp;
+	
+	/* FIXME: this shouldn't always happen */
+	if(game.state != LP_STATE_CHOOSE)
+		game.state = LP_STATE_WAIT;
+	
+	if (status == GGZ_SEAT_OPEN) {
+		table_set_name(player, "Empty Seat");
+		if (ggzcards.players[player].status == GGZ_SEAT_PLAYER) {
+			temp = g_strdup_printf("%s left the table",
+							ggzcards.players[player].name);
+			statusbar_message(temp);
+			g_free(temp);
+		}
+	} else {
+		temp = g_strdup_printf("%s joined the table", name);
+		statusbar_message(temp);
+		g_free(temp);
+		table_set_name(player, (char*)name);
+
+		if(game.state == LP_STATE_BID)
+			gtk_widget_hide(dlg_bid_fixed);
+		if(game.state == LP_STATE_TRUMP)
+			table_clear_table();
+		game.state = LP_STATE_WAIT;
+	}
 }
 
 
-static int get_trump_suit(void)
+void table_setup(void)
 {
-	if(es_read_char(game.fd, &game.trump_suit) < 0)
-		return -1;
 
-	table_set_trump();
-	return 0;
 }
-
 
-static int get_play_status(void)
+void table_alert_hand_size(int max_hand_size)
 {
-	char status;
-	char *msg;
-	int card;
-
-	if(es_read_char(game.fd, &status) < 0)
-		return -1;
-
-	if(status == 0) {
-		statusbar_message("Waiting for next play");
-		table_set_turn(game.me);
-	} else {
-		/* Restore the cards the way they should be */
-		card = hand.in_play_card_num;
-		hand.card[card] = hand.in_play_card_val;
-		table_animation_abort();
-
-		switch((int)status) {
-			case LP_ERR_FOLLOW_SUIT:
-				msg = "You must follow the led suit";
-				game.state = LP_STATE_PLAY;
-				break;
-			case LP_ERR_MUST_TRUMP:
-				msg = "You must play a trump card";
-				game.state = LP_STATE_PLAY;
-				break;
-			case LP_ERR_TURN:
-				msg = "Wait for your turn to play";
-				game.state = LP_STATE_WAIT;
-				break;
-			case LP_ERR_INVALID:
-			default:
-				/* Should resynch at this point */
-				/* but we return -1 below for now */
-				game.state = LP_STATE_WAIT;
-				msg = "Internal error, ack puke";
-				break;
-		}
-		statusbar_message(msg);
-	}
-
-	if(status == LP_ERR_INVALID)
-		return -1;
-
-	return 0;
+	assert(max_hand_size <= 10);
 }
 
+/* Used to be hand_read_hand().
+ */
+void table_display_hand(int player)
+{
+	table_display_hands();
+}
 
-static int get_opponent_play(void)
+void table_get_bid(int possible_bids, char **bid_choices)
 {
-	char p_num, card;
 
-	if(es_read_char(game.fd, &p_num) < 0
-	   || es_read_char(game.fd, &card) < 0)
-		return -1;
+}
 
+void table_get_play(int hand)
+{
+	assert(hand == 0);
 	if(game.state == LP_STATE_ANIM)
 		table_animation_zip(TRUE);
+		
+	game.state = LP_STATE_PLAY;
+	statusbar_message("Your turn to play a card");
+}
 
-	table_animation_opponent(p_num, card);
+void table_alert_badplay(char *err_msg)
+{
+	/* Restore the cards the way they should be */
+	table_animation_abort();
 
-	table_set_turn(p_num);
+	game.state = LP_STATE_PLAY;
+	statusbar_message(err_msg);
+}
 
-	return 0;
+void table_alert_play(int player, card_t card)
+{
+	if (player == 0) { /* me */
+		statusbar_message("Waiting for next play");
+		table_set_turn(0);
+	} else {
+		/* FIXME: I don't think this is quite right. */
+		if(game.state == LP_STATE_ANIM)
+			table_animation_zip(TRUE);
+
+		table_animation_opponent(player, card);
+
+		table_set_turn(player);
+	}
+	table_display_hands();
 }
 
+void table_alert_table(void)
+{
+	table_show_cards(ggzcards.players[0].table_card, ggzcards.players[1].table_card, ggzcards.players[2].table_card, ggzcards.players[3].table_card);
+}
 
-static int get_trick_winner(void)
+void table_alert_trick(int player)
 {
-	char p_num;
 	char *t_str;
 
 	if(game.state == LP_STATE_ANIM)
 		table_animation_zip(TRUE);
-
-	if(es_read_char(game.fd, &p_num) < 0)
-		return -1;
 
-	table_set_tricks(p_num, ++game.tricks[(int)p_num]);
+	table_set_tricks(player, ++game.tricks[(int)player]);
 
-	t_str = g_strdup_printf("%s won the trick", game.names[(int)p_num]);
+	t_str = g_strdup_printf("%s won the trick", ggzcards.players[player].name);
 	statusbar_message(t_str);
 	g_free(t_str);
 
@@ -555,35 +349,98 @@
 
 	/* This will set next player, which causes an anomaly at     */
 	/* the end of a hand, but one that won't keep me up at night */
-	game.lead = p_num + 1;
-	table_set_turn((p_num + 3) % 4);
-	game.lead = p_num;
-
-	return 0;
+	game.lead = player + 1;
+	table_set_turn((player + 3) % 4);
+	game.lead = player;
 }
-
 
-static int get_current_scores(void)
+int table_get_options(int option_cnt, int *choice_cnt, int *defaults, char ***option_choices)
 {
-	int i;
+	return -1;
+}
 
-	for(i=0; i<4; i++) {
-		if(es_read_int(game.fd, &game.score[i]) < 0)
-			return -1;
-		table_set_score(i, game.score[i]);
-	}
+void table_set_text_message(const char *mark, const char *msg)
+{
 
-	return 0;
 }
 
+void table_set_cardlist_message(const char *mark, int *lengths,  card_t ** cardlist)
+{
+
+}
 
-static int get_dealer(void)
+void table_set_player_message(int player, const char *msg)
 {
-	if(es_read_char(game.fd, &game.dealer) < 0)
-		return -1;
+
+}
 
-	table_set_dealer();
-	game.lead = (game.dealer + 1) % 4;
+int table_handle_game_message(int fd, int game_num, int size)
+{
 
-	return 0;
+	char opcode;
+	int dealer, p, bid;
+	card_t a_c = {ACE_HIGH, CLUBS, 0};
+	card_t a_d = {ACE_HIGH, DIAMONDS, 0};
+	card_t a_h = {ACE_HIGH, HEARTS, 0};
+	card_t a_s = {ACE_HIGH, SPADES, 0};
+	char *t_str;
+	
+	assert(size >= 1);
+	if (es_read_char(fd, &opcode) < 0)
+		return -1;
+		
+	switch (opcode) {
+		case LAP_REQ_TRUMP:
+			table_show_cards(a_c, a_d, a_s, a_h);
+			game.state = LP_STATE_TRUMP;
+			statusbar_message("Please choose the trump suit");
+			return 1;
+		case LAP_REQ_BID:		
+			for(p=0; p<4; p++)
+				game.tricks[p] = 0;
+			game.state = LP_STATE_BID;
+			dlg_bid_display(ggzcards.players[0].hand.hand_size);
+			return 1;
+		case LAP_MSG_DEALER:
+			if (es_read_int(fd, &dealer) < 0)
+				return 1;
+			assert(dealer >= 0 && dealer < 4);
+			game.dealer = dealer;
+			return 5;
+		case LAP_MSG_TRUMP:
+			if (es_read_char(fd, &game.trump_suit) < 0)
+				return -1;
+			if (0) /* FIXME */
+				statusbar_message("Your trump was accepted");
+			table_set_trump();
+			return 2;
+		case LAP_MSG_BID:
+			if (es_read_int(fd, &p) < 0 ||
+			    es_read_int(fd, &bid) < 0)
+			    	return -1;
+
+			game.bid[p] = bid;
+			table_set_bid(p, bid);
+
+			t_str = g_strdup_printf("%s bid %d", ggzcards.players[p].name, game.bid[p]);
+			statusbar_message(t_str);
+			g_free(t_str);
+
+			table_set_bidder(p);
+			return 9;
+		case LAP_MSG_SCORES:
+			for (p=0; p<4; p++) {
+				if (es_read_int(fd, &game.score[p]) < 0)
+					return -1;
+				table_set_score(p, game.score[p]);
+			}
+			
+			/* This is a hack so it's only done at the end of a hand.  We should
+			   have a hand-over message instead. */
+			game.trump_suit = -1;
+			table_set_trump();
+	
+			return 17;
+	}
+	return 1;
 }
Index: main.h
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/main.h,v
retrieving revision 1.3
diff -u -r1.3 main.h
--- main.h	2000/08/15 03:28:51	1.3
+++ main.h	2001/12/13 14:16:02
@@ -22,6 +22,58 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
 
+#include "gtk/gtk.h"
+#include "common.h"
+
 extern GtkWidget *dlg_main;
 
 extern void statusbar_message(char *msg);
+
+
+/* GGZCards client-common callback functions. */
+void table_get_newgame(void);
+void table_alert_newgame(void);
+void table_handle_gameover(int num_winners, int *winners);
+void table_alert_player(int player, GGZSeatType status, const char *name);
+void table_setup(void);
+void table_alert_hand_size(int max_hand_size);
+void table_display_hand(int player);
+void table_get_bid(int possible_bids, char **bid_choices);
+void table_get_play(int hand);
+void table_alert_badplay(char *err_msg);
+void table_alert_play(int player, card_t card);
+void table_alert_table(void);
+void table_alert_trick(int player);
+int table_get_options(int option_cnt, int *choice_cnt, int *defaults, char ***option_choices);
+void table_set_text_message(const char *mark, const char *msg);
+void table_set_cardlist_message(const char *mark, int *lengths,  card_t ** cardlist);
+void table_set_player_message(int player, const char *msg);
+int table_handle_game_message(int fd, int game_num, int size);
+
+
+/* Copied from server. */
+
+/* Each of these opcodes is used for a GAME_MESSAGE_GAME.  The opcode is sent
+   as a 1-byte char. */
+enum {
+	/* Requests a trump bid.  No extra data. */
+	LAP_REQ_TRUMP,
+
+	/* Requests a normal bid.  No extra data. */
+	LAP_REQ_BID,
+
+	/* Tells who the dealer is.  Followed by an int for the dealer's
+	   seat. */
+	LAP_MSG_DEALER,
+
+	/* Tells what trump is.  Followed by a char for the trump suit. */
+	LAP_MSG_TRUMP,
+
+	/* Tells of a player's bid.  Followed by an int for the player and an
+	   int for the bid. */
+	LAP_MSG_BID,
+	
+	/* Give the scores of the game.  Followed by one int per player for
+	   that player's score. */
+	LAP_MSG_SCORES,
+};
Index: module.dsc.in
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/module.dsc.in,v
retrieving revision 1.3
diff -u -r1.3 module.dsc.in
--- module.dsc.in	2001/07/14 20:05:00	1.3
+++ module.dsc.in	2001/12/13 14:16:02
@@ -5,6 +5,6 @@
 Frontend = gtk
 Homepage = http://ggz.sourceforge.net/
 Name = LaPocha
-ProtocolEngine = LaPocha
-ProtocolVersion = 1
+ProtocolEngine = GGZCards
+ProtocolVersion = devel-4
 Version = 0.0.1
Index: table.c
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/table.c,v
retrieving revision 1.14
diff -u -r1.14 table.c
--- table.c	2000/08/27 23:23:05	1.14
+++ table.c	2001/12/13 14:16:02
@@ -26,9 +26,12 @@
 #  include <config.h>
 #endif
 
+#include <assert.h>
 #include <gtk/gtk.h>
 #include <stdio.h>
 
+#include "common.h"
+
 #include "main.h"
 #include "game.h"
 #include "table.h"
@@ -51,22 +54,24 @@
 static GtkWidget *l_name[4], *l_bid[4], *l_tricks[4], *l_score[4], *l_trump;
 static gboolean table_initialized = FALSE;
 static struct {
-	int	card;
+	card_t	card;
 	int	dest_x, dest_y;
 	int	card_x, card_y;
 	float	cur_x, cur_y;
 	float	step_x, step_y;
 	gint	cb_tag;
 } anim;
-static char table_c1=-1, table_c2=-1, table_c3=-1, table_c4=-1;
 
 static void table_card_clicked(int);
 static void table_card_select(int);
 static void table_card_play(int);
 static gint table_animation_callback(gpointer);
-static void table_animation_trigger(int, int, int, int, int);
+static void table_animation_trigger(card_t card, int, int, int, int);
 static void table_handle_table_click(int, int);
 
+#define CARD_GET_X(card) ((card).suit * CARDWIDTH)
+#define CARD_GET_Y(card) (((card).face == ACE_HIGH ? 0 : (card).face-1) * CARDHEIGHT)
+
 
 /* table_initialize()
  *   Setup and draw the table areas on the fixed1 dialog item
@@ -337,8 +342,8 @@
 		table_animation_zip(FALSE);
 
 	/* Redisplay any cards on table and in hands */
-	table_display_hand();
-	table_show_cards(table_c1, table_c2, table_c3, table_c4);
+	table_display_hands();
+	table_show_cards(ggzcards.players[0].table_card, ggzcards.players[1].table_card, ggzcards.players[2].table_card, ggzcards.players[3].table_card);
 
 	/* There has GOT to be a better way to force the redraw! */
 	gdk_window_hide(f1->window);
@@ -368,6 +373,7 @@
 {
 	int target;
 	int x;
+	hand_t *hand = &ggzcards.players[0].hand;
 
 	/* Real quick, see if we even care */
 	if(game.state == LP_STATE_TRUMP) {
@@ -380,19 +386,26 @@
 		return;
 
 	/* Calculate our card target */
-	for(target=0; target<9; target++) {
+	for(target=0; target<hand->hand_size; target++) {
 		x = 116.5 + ((target+1) * CARDWIDTH/4.0);
 		if(event->x <= x)
 			break;
 	}
+	
+	//assert(target < hand->hand_size);
+	
+	while (target >= hand->hand_size)
+		target--;
+#if 0 /* No longer needed? */
 	/* This checks cards to the left if the clicked card isn't there */
-	while(hand.card[target] == -1) {
+	while(hand->card[target] == -1) {
 		if(--target < 0)
 			return;
 		x = 167.5 + ((target+1) * CARDWIDTH/4.0);
 		if(event->x > x)
 			return;
 	}
+#endif
 
 	table_card_clicked(target);
 }
@@ -404,22 +417,18 @@
  */
 static void table_card_clicked(int card)
 {
-	if(card == hand.selected_card) {
+	if(card == game.selected_card) {
 		/* Play this card */
 		table_card_play(card);
 
-		/* We save these values in case the server rejects the card */
-		hand.in_play_card_num = card;
-		hand.in_play_card_val = hand.card[card];
-		hand.card[card] = -1;
-		hand.selected_card = -1;
+		game.selected_card = -1;
 
 		/* Call the game function to notify server of play */
 		game_play_card(card);
 	} else {
 		/* Pop the card forward and select it */
 		table_card_select(card);
-		hand.selected_card = card;
+		game.selected_card = card;
 	}
 }
 
@@ -431,8 +440,9 @@
 static void table_card_select(int card)
 {
 	int i, x1, y1, x2, y2;
+	hand_t *hand = &ggzcards.players[0].hand;
 
-	if(hand.selected_card >= 0)
+	if(game.selected_card >= 0)
 		/* Restore the table image */
 		gdk_draw_pixmap(table_buf,
 				f1_style->fg_gc[GTK_WIDGET_STATE(f1)],
@@ -457,11 +467,12 @@
 		   	239, 104);
 
 	/* Draw the cards, with our selected card popped forward */
-	for(i=0; i<hand.hand_size; i++) {
-		if(hand.card[i] < 0)
+	for(i=0; i<hand->hand_size; i++) {
+		if(hand->card[i].face == ggzcards.players[0].table_card.face &&
+		   hand->card[i].suit == ggzcards.players[0].table_card.suit)
 			continue;
-		x1 = (hand.card[i] / 13) * CARDWIDTH;
-		y1 = (hand.card[i] % 13) * CARDHEIGHT;
+		x1 = CARD_GET_X(hand->card[i]);
+		y1 = CARD_GET_Y(hand->card[i]);
 		x2 = 116.5 + (i * CARDWIDTH/4.0);
 		y2 = 363;
 		if(i == card)
@@ -490,6 +501,7 @@
 static void table_card_play(int card)
 {
 	int i, x1, y1, x2, y2;
+	hand_t *hand = &ggzcards.players[0].hand;
 
 	/* Start by restoring gfx to a clean state */
 	gdk_draw_pixmap(table_buf,
@@ -507,11 +519,11 @@
 		   	239, 104);
 
 	/* Draw the cards, eliminating the card in play */
-	for(i=0; i<hand.hand_size; i++) {
-		if(hand.card[i] < 0)
+	for(i=0; i<hand->hand_size; i++) {
+		if(hand->card[i].face == ggzcards.players[0].table_card.face && hand->card[i].suit == ggzcards.players[0].table_card.suit)
 			continue;
-		x1 = (hand.card[i] / 13) * CARDWIDTH;
-		y1 = (hand.card[i] % 13) * CARDHEIGHT;
+		x1 = CARD_GET_X(hand->card[i]);
+		y1 = CARD_GET_Y(hand->card[i]);
 		x2 = 116.5 + (i * CARDWIDTH/4.0);
 		y2 = 363;
 		if(i == card)
@@ -533,8 +545,8 @@
 			f1->allocation.width, f1->allocation.height);
 
 	/* Now draw the card on the table */
-	x1 = (hand.card[card] / 13) * CARDWIDTH;
-	y1 = (hand.card[card] % 13) * CARDHEIGHT;
+	x1 = CARD_GET_X(hand->card[card]);
+	y1 = CARD_GET_Y(hand->card[card]);
 	x2 = 116.5 + (card * CARDWIDTH/4.0);
 	y2 = 363;
 	gdk_draw_pixmap(table_buf,
@@ -553,24 +565,24 @@
 			239, 114);
 
 	/* Setup and trigger the card animation */
-	table_animation_trigger(hand.card[card], x2, y2, 199, 242);
+	table_animation_trigger(hand->card[card], x2, y2, 199, 242);
 
-	table_c1 = hand.card[card];
+	ggzcards.players[0].table_card = hand->card[card];
 }
 
 
 /* table_animation_trigger()
  *   Function to setup and trigger a card animation
  */
-void table_animation_trigger(int card, int x1, int y1, int x2, int y2)
+static void table_animation_trigger(card_t card, int x1, int y1, int x2, int y2)
 {
 	#define FRAMES		15
 	#define DURATION	500	/* In milliseconds */
 
 	/* Store all our info */
 	anim.card = card;
-	anim.card_x = (card / 13) * CARDWIDTH;
-	anim.card_y = (card % 13) * CARDHEIGHT;
+	anim.card_x = CARD_GET_X(card);
+	anim.card_y = CARD_GET_Y(card);
 	anim.cur_x = x1;
 	anim.cur_y = y1;
 	anim.dest_x = x2;
@@ -659,6 +671,7 @@
 void table_animation_abort(void)
 {
 	int i, x1, y1, x2, y2;
+	hand_t *hand = &ggzcards.players[0].hand;
 
 	/* First, kill off the animation callback */
 	if(game.state == LP_STATE_ANIM) {
@@ -682,11 +695,9 @@
 
 	/* The caller is assumed to have restored the card to the hand */
 	/* so we can redraw the full hand and should be done */
-	for(i=0; i<hand.hand_size; i++) {
-		if(hand.card[i] < 0)
-			continue;
-		x1 = (hand.card[i] / 13) * CARDWIDTH;
-		y1 = (hand.card[i] % 13) * CARDHEIGHT;
+	for(i=0; i<hand->hand_size; i++) {
+		x1 = CARD_GET_X(hand->card[i]);
+		y1 = CARD_GET_Y(hand->card[i]);
 		x2 = 116.5 + (i * CARDWIDTH/4.0);
 		y2 = 363;
 		gdk_draw_pixmap(table_buf,
@@ -750,9 +761,9 @@
 
 
 /* Convenience macro, wraps a player number to a visual seat position */
-#define SEAT_POS(x)	((4 + x - game.me) % 4)
+#define SEAT_POS(x)	(x)
 /* Vice versa, maps position to seat number */
-#define POS_SEAT(x)	((x + game.me) % 4)
+#define POS_SEAT(x)	(x)
 
 /* table_set_name()
  *   Exposed function to set name on display
@@ -771,14 +782,17 @@
 {
 	int i;
 	char *name_temp;
+	
+	/* This wasn't here before */
+	game.lead = (game.dealer + 1) % 4;
 
 	for(i=0; i<4; i++) {
 		if(i == game.dealer)
-			name_temp = g_strdup_printf("%s (D)", game.names[i]);
+			name_temp = g_strdup_printf("%s (D)", ggzcards.players[i].name);
 		else if(i == (game.dealer + 1) % 4)
-			name_temp = g_strdup_printf("%s (B)", game.names[i]);
+			name_temp = g_strdup_printf("%s (B)", ggzcards.players[i].name);
 		else
-			name_temp = g_strdup(game.names[i]);
+			name_temp = g_strdup(ggzcards.players[i].name);
 		gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(i)]), name_temp);
 		g_free(name_temp);
 	}
@@ -797,13 +811,13 @@
 
 	/* Clear previous bidder flag */
 	gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(bidder)]),
-			   game.names[bidder]);
+			   ggzcards.players[bidder].name);
 
 	/* If last bid was by dealer, then we are done bidding */
 	/* Display the current turn for first trick */
 	if(bidder == game.dealer) {
 		seat = (bidder + 1) % 4;
-		name_temp = g_strdup_printf("* %s *", game.names[seat]);
+		name_temp = g_strdup_printf("* %s *", ggzcards.players[seat].name);
 		gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(seat)]),name_temp);
 		g_free(name_temp);
 
@@ -813,9 +827,9 @@
 	/* Set current bidder flag */
 	seat = (bidder + 1) % 4;
 	if(seat == game.dealer)
-		name_temp = g_strdup_printf("%s (DB)", game.names[seat]);
+		name_temp = g_strdup_printf("%s (DB)", ggzcards.players[seat].name);
 	else
-		name_temp = g_strdup_printf("%s (B)", game.names[seat]);
+		name_temp = g_strdup_printf("%s (B)", ggzcards.players[seat].name);
 	gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(seat)]), name_temp);
 	g_free(name_temp);
 }
@@ -832,7 +846,7 @@
 	char *name_temp;
 
 	/* Clear previous players flag */
-	gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(turn)]), game.names[turn]);
+	gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(turn)]), ggzcards.players[turn].name);
 
 	/* If last turn was by "leader-1", then we are done */
 	if(turn == (game.lead + 3) % 4)
@@ -840,7 +854,7 @@
 
 	/* Set current player flag */
 	seat = (turn + 1) % 4;
-	name_temp = g_strdup_printf("* %s *", game.names[seat]);
+	name_temp = g_strdup_printf("* %s *", ggzcards.players[seat].name);
 	gtk_label_set_text(GTK_LABEL(l_name[SEAT_POS(seat)]), name_temp);
 	g_free(name_temp);
 }
@@ -899,7 +913,7 @@
 	char *suits[] = { "Clubs", "Diamonds", "Hearts", "Spades" };
 
 	if(game.trump_suit != -1) {
-		t_str = g_strdup_printf("Trump is %s", suits[game.trump_suit]);
+		t_str = g_strdup_printf("Trump is %s", suits[(int)game.trump_suit]);
 		gtk_label_set_text(GTK_LABEL(l_trump), t_str);
 		g_free(t_str);
 	} else
@@ -907,12 +921,13 @@
 }
 
 
-/* table_display_hand()
+/* table_display_hands()
  *   Exposed function to show the players' hands
  */
-void table_display_hand(void)
+void table_display_hands(void)
 {
 	int i, x1, y1, x2, y2;
+	hand_t *hand = &ggzcards.players[0].hand;
 
 	/* Clean the card areas */
 	gdk_draw_rectangle(table_buf,
@@ -937,11 +952,12 @@
 			   104, 239);
 
 	/* Draw my cards, skipping any missing cards (syncing player) */
-	for(i=0; i<hand.hand_size; i++) {
-		if(hand.card[i] < 0)
+	for(i=0; i<hand->hand_size; i++) {
+		if(hand->card[i].suit == ggzcards.players[0].table_card.suit &&
+		   hand->card[i].face == ggzcards.players[0].table_card.face)
 			continue;
-		x1 = (hand.card[i] / 13) * CARDWIDTH;
-		y1 = (hand.card[i] % 13) * CARDHEIGHT;
+		x1 = CARD_GET_X(hand->card[i]);
+		y1 = CARD_GET_Y(hand->card[i]);
 		x2 = 116.5 + (i * CARDWIDTH/4.0);
 		y2 = 363;
 		gdk_draw_pixmap(table_buf,
@@ -953,7 +969,7 @@
 	}
 
 	/* Left Player card backs */
-	for(i=0; i<game.num_cards[POS_SEAT(1)]; i++) {
+	for(i=0; i<ggzcards.players[POS_SEAT(1)].hand.hand_size; i++) {
 		x1 = 10;
 		y1 = 116.5 + (i * CARDWIDTH/4.0);
 		gdk_draw_pixmap(table_buf,
@@ -964,7 +980,7 @@
 				CARDHEIGHT, CARDWIDTH);
 	}
 	/* Across Player */
-	for(i=9; i>(9-game.num_cards[POS_SEAT(2)]); i--) {
+	for(i=9; i>(9-ggzcards.players[POS_SEAT(2)].hand.hand_size); i--) {
 		x1 = 121.5 + (i * CARDWIDTH/4.0);
 		y1 = 10;
 		gdk_draw_pixmap(table_buf,
@@ -975,7 +991,7 @@
 				CARDWIDTH, CARDHEIGHT);
 	}
 	/* Right Player */
-	for(i=9; i>(9-game.num_cards[POS_SEAT(3)]); i--) {
+	for(i=9; i>(9-ggzcards.players[POS_SEAT(3)].hand.hand_size); i--) {
 		x1 = 363;
 		y1 = 121.5 + (i * CARDWIDTH/4.0);
 		gdk_draw_pixmap(table_buf,
@@ -1017,21 +1033,20 @@
 /* table_animation_opponent()
  *   Exposed function to setup an opponent animation
  */
-void table_animation_opponent(char p_num, char card)
+void table_animation_opponent(char p_num, card_t card)
 {
 	int i, x1, y1, x2, y2, xc, yc;
 
 	/* Calculate start and final position */
 	switch(SEAT_POS(p_num)) {
 		case 1:
-			table_c2 = card;
+			ggzcards.players[1].table_card = card;
 			gdk_draw_rectangle(table_buf,
 				   f1_style->bg_gc[GTK_WIDGET_STATE(f1)],
 				   TRUE,
 				   6, 112,
 				   104, 239);
-			game.num_cards[POS_SEAT(1)]--;
-			for(i=0; i<game.num_cards[POS_SEAT(1)]; i++) {
+			for(i=0; i<ggzcards.players[POS_SEAT(1)].hand.hand_size; i++) {
 				x1 = 10;
 				y1 = 116.5 + (i * CARDWIDTH/4.0);
 				gdk_draw_pixmap(table_buf,
@@ -1053,14 +1068,13 @@
 			y2 = 186;
 			break;
 		case 2:
-			table_c3 = card;
+			ggzcards.players[2].table_card = card;
 			gdk_draw_rectangle(table_buf,
 				   f1_style->bg_gc[GTK_WIDGET_STATE(f1)],
 				   TRUE,
 				   117, 6,
 				   239, 104);
-			game.num_cards[POS_SEAT(2)]--;
-			for(i=9; i>(9-game.num_cards[POS_SEAT(2)]); i--) {
+			for(i=9; i>(9-ggzcards.players[POS_SEAT(2)].hand.hand_size); i--) {
 				x1 = 121.5 + (i * CARDWIDTH/4.0);
 				y1 = 10;
 				gdk_draw_pixmap(table_buf,
@@ -1083,14 +1097,13 @@
 			break;
 		case 3:
 		default:
-			table_c4 = card;
+			ggzcards.players[3].table_card = card;
 			gdk_draw_rectangle(table_buf,
 				   f1_style->bg_gc[GTK_WIDGET_STATE(f1)],
 				   TRUE,
 				   358, 117,
 				   104, 239);
-			game.num_cards[POS_SEAT(3)]--;
-			for(i=9; i>(9-game.num_cards[POS_SEAT(3)]); i--) {
+			for(i=9; i>(9-ggzcards.players[POS_SEAT(3)].hand.hand_size); i--) {
 				x1 = 363;
 				y1 = 121.5 + (i * CARDWIDTH/4.0);
 				gdk_draw_pixmap(table_buf,
@@ -1122,8 +1135,8 @@
 			f1->allocation.width, f1->allocation.height);
 
 	/* Draw the card on the table */
-	xc = (hand.card[(int)card] / 13) * CARDWIDTH;
-	yc = (hand.card[(int)card] % 13) * CARDHEIGHT;
+	xc = CARD_GET_X(card);
+	yc = CARD_GET_Y(card);
 	gdk_draw_pixmap(table_buf,
 			f1_style->fg_gc[GTK_WIDGET_STATE(f1)],
 			cards,
@@ -1157,44 +1170,21 @@
 			120, 130,
 			120, 130,
 			231, 208);
-	table_c1 = table_c2 = table_c3 = table_c4 = -1;
-}
-
-
-/* table_show_cards_pnum()
- *   Exposed function to call table_show_cards with proper ordering
- *   for cards in player order rather than position order
- */
-void table_show_cards_pnum(char c1, char c2, char c3, char c4)
-{
-	switch(game.me) {
-		case 0:
-			table_show_cards(c1, c2, c3, c4);
-			break;
-		case 1:
-			table_show_cards(c2, c3, c4, c1);
-			break;
-		case 2:
-			table_show_cards(c3, c4, c1, c2);
-			break;
-		case 3:
-			table_show_cards(c4, c1, c2, c3);
-			break;
-	}
+	ggzcards.players[0].table_card = ggzcards.players[1].table_card = ggzcards.players[2].table_card = ggzcards.players[3].table_card = UNKNOWN_CARD;
 }
 
 
 /* table_show_cards()
  *   Exposed function to show four cards on the table area
  */
-void table_show_cards(char c1, char c2, char c3, char c4)
+void table_show_cards(card_t c1, card_t c2, card_t c3, card_t c4)
 {
 	int xc, yc, x, y;
 
 	/* Pos 0 (bottom) */
-	if(c1 != -1) {
-		xc = (c1 / 13) * CARDWIDTH;
-		yc = (c1 % 13) * CARDHEIGHT;
+	if(c1.face != -1) {
+		xc = CARD_GET_X(c1);
+		yc = CARD_GET_Y(c1);
 		x = 199;
 		y = 242;
 		gdk_draw_pixmap(table_buf,
@@ -1212,9 +1202,9 @@
 	}
 
 	/* Left player */
-	if(c2 != -1) {
-		xc = (c2 / 13) * CARDWIDTH;
-		yc = (c2 % 13) * CARDHEIGHT;
+	if(c2.face != -1) {
+		xc = CARD_GET_X(c2);
+		yc = CARD_GET_Y(c2);
 		x = 120;
 		y = 186;
 		gdk_draw_pixmap(table_buf,
@@ -1232,9 +1222,9 @@
 	}
 
 	/* Across player */
-	if(c3 != -1) {
-		xc = (c3 / 13) * CARDWIDTH;
-		yc = (c3 % 13) * CARDHEIGHT;
+	if(c3.face != -1) {
+		xc = CARD_GET_X(c3);
+		yc = CARD_GET_Y(c3);
 		x = 199;
 		y = 130;
 		gdk_draw_pixmap(table_buf,
@@ -1252,9 +1242,9 @@
 	}
 
 	/* Right player */
-	if(c4 != -1) {
-		xc = (c4 / 13) * CARDWIDTH;
-		yc = (c4 % 13) * CARDHEIGHT;
+	if(c4.face != -1) {
+		xc = CARD_GET_X(c4);
+		yc = CARD_GET_Y(c4);
 		x = 280;
 		y = 186;
 		gdk_draw_pixmap(table_buf,
Index: table.h
===================================================================
RCS file: /cvsroot/ggz/ggz/game_clients/lapocha/table.h,v
retrieving revision 1.10
diff -u -r1.10 table.h
--- table.h	2000/08/27 21:52:27	1.10
+++ table.h	2001/12/13 14:16:02
@@ -22,6 +22,10 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
 
+#include "protocol.h"
+
+#include "gtk/gtk.h"
+
 extern void table_initialize(void);
 extern void table_handle_expose_event(GdkEventExpose *);
 extern void table_handle_click_event(GdkEventButton *);
@@ -29,15 +33,14 @@
 extern void table_set_dealer(void);
 extern void table_set_bidder(int);
 extern void table_set_turn(int);
-extern void table_display_hand(void);
+extern void table_display_hands(void);
 extern void table_set_bid(int, int);
 extern void table_set_tricks(int, int);
 extern void table_set_score(int, int);
 extern void table_set_trump(void);
 extern void table_animation_abort(void);
 extern void table_animation_zip(gboolean);
-extern void table_animation_opponent(char, char);
+extern void table_animation_opponent(char, card_t);
 extern void table_clear_table(void);
-extern void table_show_cards_pnum(char, char, char, char);
-extern void table_show_cards(char, char, char, char);
+extern void table_show_cards(card_t, card_t, card_t, card_t);
 extern void table_style_change(void);
