\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ggz-game-development-guide.info
@settitle The GGZ Gaming Zone 0.0.9 - Game Development Guide
@setchapternewpage odd
@c %**end of header

@c TODO: 
@c nothing

@ifinfo
Copyright (C) 2002 - 2004 Josef Spillner
@end ifinfo

@c Frontpage
@titlepage
@title The GGZ Game Development Guide
@subtitle Development of games for the GGZ Gaming Zone 0.0.9
@author GGZ Development Team

@c Copyright page
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002 - 2004 Josef Spillner
Published under the GNU Free Documentation License.
@end titlepage

@c Index (Top)
@node Top, Foreword, (dir), (dir)
@c @top Foreword

@ifinfo
This file is the info format of the GGZ Gaming Zone Game Development Guide, which is
also available in postscript and HTML format.
It describes how to develop game clients and servers which run over GGZ.
See http://www.ggzgamingzone.org/docs/guides/gamedev/ for the latest edition.
@end ifinfo

@menu
* Foreword:: General notes about this document
* The GGZ System:: How games can use the GGZ Gaming Zone
* Game Clients:: Get into the player's eye
* Game Servers:: Where the real magic takes place
* Programming Details:: Network, configuration etc.
@end menu

@node Foreword, The GGZ System, Top, Top
@chapter Foreword
@c @cindex Index entry for Chapter Zero

The central element of the GGZ Gaming Zone is, obviously, everything related to
games, especially the games themselves. From the very beginning, games of any
kind have been a part of GGZ. After a long time of premature development, a lot
of experience is present to be shared with the humble reader.

As games are very different from applications, it is not easy to recommend for
this or against that. Instead, a general collection of hints is presented,
divided into the major differences on the client side (frontends) and the
server side (programming languages).

@node The GGZ System, Game Clients, Foreword, Top
@chapter The GGZ System
@c @cindex Index entry for First Chapter

@section Native GGZ Games ("internal")

With more than a dozen games available, which can be played using nearly two
dozen game clients, GGZ offers a solid bunch of different
games by itself. They're all developed based on a client/server model.
So how does that work?

The player, using a GGZ core client to chat with others in a room, launches a
game which he wants to play with some others. Technically, a table is created
to hold that game, and the player is put onto that table, occupying one seat.
The other available seats can be left empty, filled up with bots or used by
other players. The quantity of each type is determined by the game server, for
example, some games might not support bots (AI players) at all, or it might
support an unlimited number of players.

@section Games which want to use GGZ ("external")

External game work no different to internal ones. However, a few assumptions
can be made, for example, most external game have been present before they got
a GGZ mode, and are thus more complex in design.
In the future, some GGZ game servers and clients will most likely also provide
a standalone mode, just like some clients already do for local games,
namely Muehle, KTicTacTux, Geekgame, Escape/SDL and Xadrez Chines.

@node Game Clients, Game Servers, The GGZ System, Top
@chapter Game Clients
@c @cindex Index entry for Second Chapter

@section Introduction

Game clients in a client/server relation should be regarded as the
visualization of the game itself. This is not the traditional view where the
game client was the game itself, but in times of connected entertainment not
every player can be trusted, so it is a general agreement that the server is
the trusted element and the clients are just there to convert the game data to
a more human-friendly format.
However, this shouldn't stop anybody of developing great game clients.
Furthermore, there are some GGZ games which run without a server, or with a
minimal server which leaves all checks to the game clients.

From version 0.0.6 on, game clients request a separate communication channel
from the main client, which is connected to the game server directly. This
leads to a slightly more difficult setup, but allows for higher speed.
The next section has been added to document this.

@section The client base library: libggzmod

This is a short description of ggzmod. Please see the API documentation for
details.

A launched game client gets a control channel on its way, which it connects to
a callback to receive control messages.
Then it requests a direct game connection, which results in the creation of a
game channel, which gets connected to a callback too.
This game channel is then used to communicate with the game server.

A basic ggzmod usage may look like this:

@verbatim
static void handle_ggz(gpointer data, gint source, GdkInputCondition cond)
{
	ggzmod_dispatch(ggzmod);
}

static void handle_ggzmod_server(GGZMod * ggzmod, GGZModEvent e, void *data)
{
	int fd = *(int*)data;
	ggzmod_set_state(ggzmod, GGZMOD_STATE_PLAYING);
	gdk_input_add(fd, GDK_INPUT_READ, game_handle_io, NULL);
}

int main()
{
...
	GGZMod *ggzmod;

	ggzmod = ggzmod_new(GGZMOD_GAME);
	ggzmod_set_handler(ggzmod, GGZMOD_EVENT_SERVER, &handle_ggzmod_server);
...
	ggzmod_connect(ggzmod);
	gdk_input_add(ggzmod_get_fd(ggzmod), GDK_INPUT_READ, handle_ggz, NULL);
...
	ggzmod_disconnect(ggzmod)
	ggzmod_free(game.ggzmod);
...
}
@end verbatim

(Note that this is for a Gtk+ game client written in C. Things will differ for
other toolkits like Qt, and other programming languages like C++. Also, return
values should be checked and such.)

@section Game Registry

Every game client must be registered in order to be found by the GGZ core
clients like KGGZ or GGZ-Gtk. This is done via the ggz-config utily during the
installation step. Basically, every game client has a file called module.dsc,
which is used for this purpose:
@command{ggz-config --install --force --modfile=module.dsc}

The format of this configuration file is defined as follows:
@c @samp{
@verbatim
[ModuleInfo]
Author = <author>
CommandLine = <commandline>
Frontend = <frontend>
Environment = <environment>
Homepage = <url>
Name = <name of the game>
ProtocolEngine = <engine name>
ProtocolVersion = <protoversion>
Version = <version>
@end verbatim
@c }

The entries don't have to have any special values, except that the combination
of protocol engine and protocol version is used to ensure the compatibility
with any game server of this name. The frontend should be a common abbreviation
like kde, gtk, qt or sdl. The environment can be xfullscreen, xwindow,
framebuffer, console or passive. The default (if omitted) is xwindow.

@section Client Toolkits
@subsection KDE or Qt (C++)

See @url{http://games.kde.org} for information about KDE game development.
There is also a mailing list for this topic with information available at
@url{http://mail.kde.org/mailman/listinfo/kde-games-devel}.

The language bindings for KDE are also maturing, so there shouldn't be major
obstacles coding a KDE game client in Ruby, Python, Perl or Java.

You will most likely be interested in using Qt classes for OpenGL or sprite
animations, so get yourself a copy of the Qt documentation.

The GGZ games KReversi, KDots, KTicTacTux, Krosswater, Muehle, Keepalive,
Koenig, Kamikaze, Copenhagen and Fyrdman have been written using KDE/Qt as
development framework.

@subsection Gtk+, Gnome (C), Gtk-- (C++)

There are several useful libraries for Gtk+, including GtkGLArea.
Examples of Gtk+ GGZ games are TicTacToe, NetSpades, LaPocha, Connect the Dots,
Hastings, Reversi, Combat, Chinese Checkers, Chess and GGZCards.
T.E.G. is an example for a Gnome game.

@subsection SDL (C, C++, Python)

SDL is a proven toolkit for game development, with tons of games already
available. See @url{http://www.libsdl.org} for a list of them.
The GGZ games Geekgame and TicTacToe 3D have been written using SDL.
The games Escape/SDL, PyKamikaze and Xadrez Chines are using the Python
wrapper for SDL called Pygame, available at @url{http://www.pygame.org}.
Python games also need to use a wrapper for the ggzmod and ggzdmod libraries,
which exist as pyggzmod and pyggzdmod in the ggz-python package.

@subsection Others

It does really not matter which toolkit one chooses. Therefore, Mesa3D (an
OpenGL implementation), PLib, GLUT, ClanLib and others are worth to have a look
at. Actually TicTacToe 3D uses SDL in combination with OpenGL.

@node Game Servers, Programming Details, Game Clients, Top
@chapter Game Servers
@c @cindex Index entry for Third Chapter

@section Introduction

Game servers are launched by the main GGZ server and receive events on one
dedicated file descriptor. There are different event types:

@itemize @bullet
@item STATE: indicates that the state has changed (see below)
@item JOIN: a player has joined the game
@item LEAVE: player has left the game
@item SEAT: seat occupation has changed
@item SPECTATOR_JOIN: a spectator came to watch the game
@item SPECTATOR_LEAVE: spectator went away
@item SPECTATOR_SEAT: spectator has joined or left
@item PLAYER_DATA: one of the players (clients) sent some data
@item SPECTATOR_DATA: data sent from random spectators
@item LOG: log message has arrived
@item ERROR: an error has occured
@end itemize

The states in which a game server can be are:

@itemize @bullet
@item STATE_CREATED
@item STATE_WAITING
@item STATE_PLAYING
@item STATE_DONE
@end itemize

In order to ease game development, the ggzdmod library has been written, which
comes with extensive documentation.
See @url{http://www.ggzgamingzone.org/docs/api/ggzdmod/html/ggzdmod_8h.html} for the
online documentation, which is also available as man page (man 3 ggzdmod.h).

@section The server base library: libggzdmod

In order to be informed about player joins and leaves, and the status of the
game (running, done, ...), the ggzdmod library is essential to use.

This is how a simple C game server embeds the necessary function calls:

@verbatim
static void callback_state(GGZdMod *ggz, GGZdModEvent event, void *data)
{
	/* Evaluate state */
}

int main()
{
...
	ggzdmod_set_handler(ggzdmod, GGZDMOD_EVENT_STATE, callback_state);
...
}
@end verbatim

@section Game statistics: libggzstats

GGZ game servers can use the ggzstats library which offers various statistic
types. For example, the ELO ranking and win/loss ratios are supported.

A typical scenario is the following one:

@verbatim
GGZStats *stats;

stats = ggzstats_new(ggzmod);
ggzstats_set_game_winner(stats, winner, 1.0);
ggzstats_set_game_winner(stats, (winner + 1) % 2, 0.0);
ggzstats_recalculate_ratings(stats);
ggzstats_free(stats);
@end verbatim

The statistics are saved into the database (next to the list of registered
players), and can be used as data for web-based community sites.

@section Configuration Files

Each game server must supply at least one file for each of main server's lists.
Currently there is a room list and a game list, so a game can be present in
multiple rooms, with either the same or another configuration.

The game file (<name>.dsc) has the following format:

@verbatim
[GameInfo]
Author = <author>
Description = <description>
Homepage = <url>
Name = <name of the game>
Version = <version>

[LaunchInfo]
ExecutablePath = <server executable>

[Protocol]
Engine = <protocol name>
Version = <protocol version>

[TableOptions]
AllowLeave = <0/1>
BotsAllowed = <0 [1 [2 ...]]>
PlayersAllowed = <1 [2 [3 ...]]>
KillWhenEmpty = <0/1>
AllowSpectators = <0/1>

[Statistics]
Records = <0/1>
Ratings = <0/1>
@end verbatim

The room file (<name>.room) has the following format:

@verbatim
[RoomInfo]
Name = <roomname>
Description = <description>
GameType = <name of the game>
MaxPlayers = <maximum of players>
MaxTables = <maximum of tables>
@end verbatim

Have a look at the current game server description files if there are open
questions.

@section Programming Language
@subsection C Development

C programmers can use ggzdmod natively.

@subsection C++ Development

For C++ developers there exist some choices in wrapping the ggzdmod library.
For example, Krosswater uses the Zone library, and Muehle uses the
GGZGameServer class, which are both wrappers for ggzdmod.
In the latter case, you only need to inherit your main server class from
GGZGameServer, and reimplement all of its protected event methods.

@subsection Python Development

There are python wrappers for ggzdmod, ggzmod and ggzcore: pyggzdmod,
pyggzmod and pyggzcore.
They are available as part of the ggz-python package.

@subsection Ruby Development

There is a ruby wrapper for ggzdmod in development: ruggzdmod.
In the future, the GGZ server will also be available as a complete ruby
implementation, which will come with a native game server interface.

@node Programming Details, (dir), Game Servers, Top
@chapter Programming Details
@c @cindex Index entry for Fourth Chapter

@section General purpose wrappers

GGZ from version 0.0.6 on has been providing two wrappers which make life easier for game
developers. Either of these wrappers replaces a game of choice, while the game
itself is kept to be launched by the wrapper then.

@subsection ggzwrap

This one should be used in production code, and it's very suitable for the
server, because it is small, has no GUI and supports command line options. Its
arguments are the program to be executed (--exec), the inbound and outbound
file descriptors to be redirected (--fdin, --fdout), and an option whether the
received strings should be converted between 'traditional GGZ' easysock order
and normal C string order (--convert).
So a sample call may look like this:
@command{ExecutablePath=/usr/local/ggz/lib/ggzwrap
--exec=/usr/local/ggz/lib/tictactoe --fdin=3 --fdout=3}

The GGZ Muehle game uses this one.

@subsection ShadowBridge

The KDE equivalent of ggzwrap can be used to debug network connections
visually. It displays incoming and outgoing traffic between the game and the
game server, which is (technically) between the game client and ggzcore for
most of our games (those without direct connections, anyway).

@subsection Go client/server

The GNU Go integration uses special wrappers both on the client and the
server side, which communicate using stdin/stdout and fifos respectively.
It should be able to use them for any similar games without problem.

@section Network connections

@subsection Easysock (C)

A very easy and convenious library for those who don't need any fancy features
for TCP connections. This library is part of GGZ and therefore always
available. It has been merged into libggz, so all functions are prefixed with
ggz_ now.
See the documentation for libggz for more details.

Usage example:

@verbatim
int fd;

fd = ggzdmod_get_seat(mod, 1).fd;
ggz_write_int(fd, 0);
ggz_write_string(fd, "Hello World.");
@end verbatim

@subsection Qt (C++)

Those game clients which use the Qt toolkit will most likely use the Qt network
code as well. This has mostly to do with QSocket, QSocketNotifier and
QDataStream, which are all very easy and intuitive to use.

Documentation:
@url{http://doc.trolltech.com/3.1/qdatastream.html}

@subsection KDE (C++)

KDE does provide very powerful networking mechanisms. There are not only
classes like KSocket/KExtSocket, but also the DCOP library, and the KDE games
library named libkdegames.

Documentation:
@url{http://developer.kde.org/documentation/library/3.1-api/classref/kdecore/KExtendedSocket.html}

@subsection Net/MNet (C++)

The game Kamikaze, which provides support for GGZ, uses an own set of network
classes which are very convenient to use. Their development was backed by
experiences with the other toolkits.
Net objects provide simple buffered input/output with host/network conversion
equal to easysock. MNet objects are inherited and in addition provide
multicasting.
A sample networking session looks like this:

@verbatim
// The network object
MNet n;

// Send unbuffered and buffered message to player 1
n << Net::channel << fd1;
n << "hello world";
n << Net::begin << arg1 << arg2 << Net::end << Net::flush;

// Setup broadcasting
n << MNet::add << fd1;
n << MNet::add << fd2;

// Broadcast message to both players
n << Mnet::multicast;
n << "hello all";

// Reset to normal behaviour
n << MNet::peer;
@end verbatim

@subsection Network (Python)

The Network class as used in Kamikaze and Escape/SDL is sitting on top of both
the Python Socket module and the ggzmod wrapper.

@verbatim
# Build network object
net = Network()

# query events
ret = net.autonetwork()
if (ret & 1):
    serverevent()
if (ret & 2):
    gameevent()

# send/receive data
opcode = net.getchar()
net.sendbyte(999)
@end verbatim

@section Configuration

@subsection GGZConfIO (ini-Style)

Many GGZ configurations are read and written using GGZConfIO. Formerly located
in the ggzcore library, it is now part of libggz and consists of many
ggz_conf_* functions.
The details are again explained in the libggz documentation.

Usage example:

@verbatim
int conf;
char *value;

conf = ggz_conf_parse("/etc/ggz/games/mygame.conf", GGZ_CONF_RDONLY);
if(conf != -1)
{
	value = ggz_conf_read_string(conf, "SampleSection", "SampleKey", NULL);
	ggz_conf_close(-1);
}
@end verbatim

@subsection Minidom (XML-Style)

If you want to read or write XML data, while avoiding the overhead of a complex
XML library, the GGZ project offers the minidom library, which you can find in
utils/metaserv/minidom.
Currently, both the GGZ meta server and the Copenhagen game server make use of
this library.

Usage example:

@verbatim
DOM *conf;

conf = minidom_load("/etc/ggz/games/mygame.xml");
if((conf) && (conf->valid) && (conf->processed))
{
	printf("Root tag is named %s.\n", conf->el->name);
	printf("Attribute 'version' has value %s.\n", MD_att(conf->el, "version"));
}
minidom_free(conf);
@end verbatim

@c @printindex cp

@contents
@bye


