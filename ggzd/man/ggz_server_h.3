.TH "ggz_server.h" 3 "26 Aug 2001" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ggz_server.h \- The interface for the ggzdmod library used by game servers. 
.SH SYNOPSIS
.br
.PP
.SS Compounds

.in +1c
.ti -1c
.RI "struct \fBggzd_seat_t\fR"
.br
.RI "\fIA GGZ seat; one spot at a table.\fR"
.in -1c
.SS Defines

.in +1c
.ti -1c
.RI "#define \fBMAX_USER_NAME_LEN\fR  16"
.br
.RI "\fIThe maximum length of a player name.\fR"
.in -1c
.SS Typedefs

.in +1c
.ti -1c
.RI "typedef int (* \fBGGZDHandler\fR )(ggzd_event_t event_id, void *handler_data)"
.br
.in -1c
.SS Enumerations

.in +1c
.ti -1c
.RI "enum \fBggzd_assign_t\fR { \fBGGZ_SEAT_OPEN\fR =  -1, \fBGGZ_SEAT_BOT\fR =  -2, \fBGGZ_SEAT_RESV\fR =  -3, \fBGGZ_SEAT_NONE\fR =  -4, \fBGGZ_SEAT_PLAYER\fR =  -5 }"
.br
.RI "\fISeat assignment values.\fR"
.ti -1c
.RI "enum \fBggzd_event_t\fR { \fBGGZ_EVENT_LAUNCH\fR =  0, \fBGGZ_EVENT_JOIN\fR =  1, \fBGGZ_EVENT_LEAVE\fR =  2, \fBGGZ_EVENT_QUIT\fR =  3, \fBGGZ_EVENT_PLAYER\fR =  4, \fBGGZ_EVENT_TICK\fR =  5 }"
.br
.in -1c
.SS Functions

.in +1c
.ti -1c
.RI "int \fBggzd_debug\fR (const char *fmt,...)"
.br
.RI "\fISends a debugging message to ggzd to be logged.\fR"
.ti -1c
.RI "int \fBggzd_seats_num\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_seats_open\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_seats_bot\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_seats_reserved\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_seats_human\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_fd_max\fR (void)"
.br
.ti -1c
.RI "void \fBggzd_set_handler\fR (ggzd_event_t event_id, const \fBGGZDHandler\fR handler)"
.br
.ti -1c
.RI "int \fBggzd_connect\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_disconnect\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_dispatch\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_read_data\fR (void)"
.br
.ti -1c
.RI "int \fBggzd_main\fR (void)"
.br
.in -1c
.SS Variables

.in +1c
.ti -1c
.RI "struct \fBggzd_seat_t\fR* \fBggzd_seats\fR"
.br
.RI "\fIThe array of seats at the table.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
The interface for the ggzdmod library used by game servers.
.PP
.PP
 This file contains all libggzdmod functions used by game servers to interface with GGZD. Just include \fBggz_server.h\fR and make sure your program is linked with libggzmod. Then use the functions below as appropriate.
.PP
GGZDmod currently provides an event-driven interface. Data from GGZD is read in by the library, and a handler function (registered as a callback) is invoked to handle the event. The game server should not read data from the GGZD socket unless it really knows what it is doing.
.PP
That this does not apply to the client sockets: ggzdmod provides one file desriptor for communicating (TCP) to each client. If data is ready to be read by one of these file descriptors ggzdmod may invoke the appropriate handler (see below), but will never actually read any data.
.PP
\fB\fBTodo: \fR\fR
.in +1c
Example code.
.PP
For more information, see the documentation at http://ggz.sf.net/.
.PP
.SH DEFINE DOCUMENTATION
.PP 
.SS #define MAX_USER_NAME_LEN  16
.PP
The maximum length of a player name.
.PP
\fBNote: \fR
.in +1c
Does not include trailing \\0. 
.PP
\fB\fBTodo: \fR\fR
.in +1c
 If ggzd_seats was encapsulated, this wouldn't be necessary.  
.SH TYPEDEF DOCUMENTATION
.PP 
.SS typedef int(* GGZDHandler)(ggzd_event_t event_id, void *handler_data)
.PP
A handler function should correspond to this prototype. 
.SH ENUMERATION TYPE DOCUMENTATION
.PP 
.SS enum ggzd_assign_t
.PP
Seat assignment values.
.PP
Each seat at a game has a status taken from one of these. 
.PP
\fBEnumeration values:\fR
.in +1c
.TP
\fB\fIGGZ_SEAT_OPEN\fR \fR
The seat is open (unoccupied). 
.TP
\fB\fIGGZ_SEAT_BOT\fR \fR
The seat has a bot (AI) in it. 
.TP
\fB\fIGGZ_SEAT_RESV\fR \fR
The seat is reserved for a player. 
.TP
\fB\fIGGZ_SEAT_NONE\fR \fR
This seat does not exist. 
.TP
\fB\fIGGZ_SEAT_PLAYER\fR \fR
The seat has a regular player in it. 
.SS enum ggzd_event_t
.PP
\fBEnumeration values:\fR
.in +1c
.TP
\fB\fIGGZ_EVENT_LAUNCH\fR \fR
a game launch event from ggzd 
.TP
\fB\fIGGZ_EVENT_JOIN\fR \fR
a player join event from ggzd 
.TP
\fB\fIGGZ_EVENT_LEAVE\fR \fR
a player leave event from ggzd 
.TP
\fB\fIGGZ_EVENT_QUIT\fR \fR
a game over event from ggzd 
.TP
\fB\fIGGZ_EVENT_PLAYER\fR \fR
a message from a client/player 
.TP
\fB\fIGGZ_EVENT_TICK\fR \fR
a passed-time event 
.SH FUNCTION DOCUMENTATION
.PP 
.SS int ggzd_connect (void)
.PP
Connects to GGZD. 
.PP
\fBReturns: \fR
.in +1c
The GGZ file descriptor on success, -1 on failure 
.SS int ggzd_debug (const char * fmt, ...)
.PP
Sends a debugging message to ggzd to be logged.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIfmt\fR\fR
a printf-style format string 
.TP
\fB\fI...\fR\fR
a printf-stype list of arguments 
.PP
\fBReturns: \fR
.in +1c
0 on success, -1 on failure 
.SS int ggzd_disconnect (void)
.PP
Disconnects from GGZD. 
.PP
\fBReturns: \fR
.in +1c
0 on success, -1 on failure. 
.SS int ggzd_dispatch (void)
.PP
This function may be called when there's GGZ data ready to be read from GGZD. It calls the appropriate event handler. 
.PP
\fBReturns: \fR
.in +1c
0 normally, 1 on gameover, -1 on failure 
.PP
\fBNote: \fR
.in +1c
This function only covers the GGZ socket, not player sockets. 
.PP
\fBSee also: \fR
.in +1c
\fBggzd_set_handler\fR 
.SS int ggzd_fd_max (void)
.PP
\fBReturns: \fR
.in +1c
The highest file descriptor used by ggzd. 
.PP
\fB\fBTodo: \fR\fR
.in +1c
 Is this even necessary??? 
.SS int ggzd_main (void)
.PP
This should do all of the GGZ work necessary for most games. It repeatedly takes data from GGZD and calls the appropriate event handler. It also connects to GGZD. 
.PP
\fBReturns: \fR
.in +1c
0 on success, -1 on failure 
.PP
\fBNote: \fR
.in +1c
This function will check for data on both GGZ and player sockets. 
.in -1c
.in +1c
This function supercedes ggzd_read_data, ggzd_dispatch, ggzd_connect, and ggzd_disconnect. 
.SS int ggzd_read_data (void)
.PP
This function may be called to read data from GGZD. It will block until GGZ or player data is available, then dispatch the appropriate handler. 
.PP
\fBReturns: \fR
.in +1c
0 normally, 1 on gameover, -1 on failure 
.PP
\fBSee also: \fR
.in +1c
\fBggzd_set_handler\fR 
.PP
\fBNote: \fR
.in +1c
This function supercedes ggzd_dispatch. 
.in -1c
.in +1c
This function will check for data on both GGZ and player sockets. 
.in -1c
.in +1c
This function may not be a part of the final API 
.SS int ggzd_seats_bot (void)
.PP
\fBReturns: \fR
.in +1c
The number of bot-occupied seats at the table. 
.SS int ggzd_seats_human (void)
.PP
\fBReturns: \fR
.in +1c
The number of occupied player seats at the table. 
.SS int ggzd_seats_num (void)
.PP
\fBReturns: \fR
.in +1c
The total number of seats at the table. 
.SS int ggzd_seats_open (void)
.PP
\fBReturns: \fR
.in +1c
The number of open (unoccupied) seats at the table. 
.SS int ggzd_seats_reserved (void)
.PP
\fBReturns: \fR
.in +1c
The number of reserved seats at the table. 
.SS void ggzd_set_handler (ggzd_event_t event_id, const \fBGGZDHandler\fR handler)
.PP
Sets a handler for the specified event. 
.SH VARIABLE DOCUMENTATION
.PP 
.SS struct \fBggzd_seat_t\fR * ggzd_seats
.PP
The array of seats at the table.
.PP
This is a pointer to an array of GGZ seats. The size of the array can be found with ggz_seats_num(). 
.PP
\fBNote: \fR
.in +1c
This array is allocated internally. Do not change it. 
.PP
\fB\fBTodo: \fR\fR
.in +1c
 Should this be encapsulated? 
.SH AUTHOR
.PP 
Generated automatically by Doxygen from the source code.