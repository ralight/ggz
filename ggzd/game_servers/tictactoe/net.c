/* Generated by GGZComm/ruby version 0.2 */
/* Protocol 'tictactoe', version '4' */

#include "net.h"
#include <stdlib.h>
#include <ggz.h>

#define ggz__seat_open 1

static notifier_func_type notifier_func = NULL;
static error_func_type error_func = NULL;
static int fd = -1;
static int ret;
static int requirelink = 0;
static int nextlink;

static void ggzcomm_error(void);

static void ggzcomm_sndmove(void)
{
	ret = ggz_read_int(fd, &variables.move_c);
	if(ret < 0) ggzcomm_error();
	if(notifier_func) (notifier_func)(sndmove);
}

static void ggzcomm_reqsync(void)
{
	if(notifier_func) (notifier_func)(reqsync);
}

void ggzcomm_msgseat(void)
{
	ret = ggz_write_int(fd, msgseat);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_int(fd, variables.num);
	if(ret < 0) ggzcomm_error();
}

void ggzcomm_msgplayers(void)
{
	int i1;

	ret = ggz_write_int(fd, msgplayers);
	if(ret < 0) ggzcomm_error();
	for(i1 = 0; i1 < 2; i1++)
	{
		ret = ggz_write_int(fd, variables.seat[i1]);
		if(ret < 0) ggzcomm_error();
		if((variables.seat[i1] != ggz__seat_open))
		{
			ret = ggz_write_string(fd, variables.name[i1]);
			if(ret < 0) ggzcomm_error();
		}
	}
}

void ggzcomm_reqmove(void)
{
	ret = ggz_write_int(fd, reqmove);
	if(ret < 0) ggzcomm_error();

	requirelink = 1;
	nextlink = sndmove;
}

void ggzcomm_rspmove(void)
{
	ret = ggz_write_int(fd, rspmove);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_char(fd, variables.status);
	if(ret < 0) ggzcomm_error();

	requirelink = 1;
	nextlink = sndmove;
}

void ggzcomm_msgmove(void)
{
	ret = ggz_write_int(fd, msgmove);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_int(fd, variables.player);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_int(fd, variables.move);
	if(ret < 0) ggzcomm_error();
}

void ggzcomm_sndsync(void)
{
	int i1;

	ret = ggz_write_int(fd, sndsync);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_char(fd, variables.turn);
	if(ret < 0) ggzcomm_error();
	for(i1 = 0; i1 < 9; i1++)
	{
		ret = ggz_write_char(fd, variables.space[i1]);
		if(ret < 0) ggzcomm_error();
	}

	requirelink = 1;
	nextlink = reqsync;
}

void ggzcomm_msggameover(void)
{
	ret = ggz_write_int(fd, msggameover);
	if(ret < 0) ggzcomm_error();
	ret = ggz_write_char(fd, variables.winner);
	if(ret < 0) ggzcomm_error();
}

void ggzcomm_network_main(void)
{
	int opcode;
	ggz_read_int(fd, &opcode);

	if(requirelink)
	{
		if(opcode != nextlink) ggzcomm_error();
		requirelink = 0;
	}

	switch(opcode)
	{
		case sndmove:
			ggzcomm_sndmove();
			break;
		case reqsync:
			ggzcomm_reqsync();
			break;
	}
}

void ggzcomm_set_notifier_callback(notifier_func_type f)
{
	notifier_func = f;
}

void ggzcomm_set_error_callback(error_func_type f)
{
	error_func = f;
}

void ggzcomm_set_fd(int usefd)
{
	fd = usefd;
}

int ggzcomm_get_fd(void)
{
	return fd;
}

static void ggzcomm_error(void)
{
	if(error_func) (error_func)();
}

