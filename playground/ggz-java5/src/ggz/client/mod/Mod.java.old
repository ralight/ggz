package ggz.mod;

import ggz.core.ServerListener;
import ggz.core.Server.HookList;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import javax.swing.event.EventListenerList;

public class Mod {
    private static final Logger log = Logger.getLogger(Mod.class.getName());
    ModType type;    /* ggz-end or game-end */
    ModState state;  /* the state of the game */
    int fd;         /* file descriptor */
    //ModHandler handlers[GGZMOD_NUM_HANDLERS];
    Object gamedata;         /* game-specific data */

    int server_fd;
    String server_host;
    int server_port;
    String server_handle;

    String my_name;
    boolean i_am_spectator;
    int my_seat_num;

    /* Seat and spectator seat data. */
    int num_seats;
    ArrayList<Seat> seats;
    List stats;
    List infos;
    int num_spectator_seats;
    List spectator_seats;
    List spectator_stats;

    /* ggz-only data */
//    #ifdef HAVE_FORK
//        pid_t pid;  /* process ID of table */
//    #else
//        HANDLE process;
//    #endif
    String pwd;  /* working directory for game */
    String[] argv;    /* command-line arguments for launching module */
//    GGZModTransactionHandler thandlers[GGZMOD_NUM_TRANSACTIONS];
    private HookList thandlers = new HookList();


    /* Structure for player statistics */
    private static class Stat implements Comparable {
        int number;
        int have_record, have_rating, have_ranking, have_highscore;
        int wins, losses, ties, forfeits;
        int rating, ranking, highscore;
        
        public int compareTo(Object o) {
            return this.number = ((Stat)o).number;
        }
    } 

    /* 
     * Creating/destroying a ggzmod object
     */

//
//    static int infos_compare(const void *p, const void *q)
//    {
//        const GGZPlayerInfo *s_p = p, *s_q = q;
//
//        return s_p->num - s_q->num;
//    }

    /*
     * How a game is launched (incomplete): see ggzmod.c.
     */

    /* Creates a new ggzmod object. */
    public Mod (ModType type)
    {
        int i;

        /* verify parameter */
        if (type != ModType.GGZMOD_GGZ && type != ModType.GGZMOD_GAME)
            throw new IllegalArgumentException("Invalid ModType");

        /* initialize */
        this.type = type;
        this.state = ModState.GGZMOD_STATE_CREATED;
        this.fd = -1;
        this.server_fd = -1;
        this.server_host = null;
        this.server_port = 0;
        this.server_handle = null;
//        for (i = 0; i < GGZMOD_NUM_HANDLERS; i++)
//            this.handlers[i] = null;
        this.gamedata = null;
        this.my_seat_num = -1;

        this.seats = new ArrayList();
        this.spectator_seats = new ArrayList();
        this.num_seats = this.num_spectator_seats = 0;

        this.stats = new ArrayList();
        this.spectator_stats = new ArrayList();

        this.infos = new ArrayList();

//    #ifdef HAVE_FORK
//        this.pid = -1;
//    #else
//        this.process = INVALID_HANDLE_VALUE;
//    #endif
        this.argv = null;
//        for (i = 0; i < GGZMOD_NUM_TRANSACTIONS; i++)
//            this.thandlers[i] = null;
    }



    /* 
     * Accesor functions for GGZMod
     */

    /* The ggzmod FD is the main ggz<->game server communications socket. */
    public int get_fd()
    {
        return this.fd;
    }


    public ModState get_state()
    {
        return this.state;
    }


    public Object get_gamedata()
    {
        return this.gamedata;
    }


    public void set_module( String pwd, String[] argv)
    {
        int i;

        log.fine( "Setting arguments");
        
        if (this.type != ModType.GGZMOD_GGZ) {
            _error("Cannot set module args from module");
            return;
        }
            
        /* Check parameters */
        if (argv == null || argv[0] == null) {
            _error("Bad module arguments");
            return;
        }

        /* Count the number of args so we know how much to allocate */
//        for (i = 0; argv[i]; i++) {}

        log.fine( "Set "+argv.length+" arguments");
        
//        this.argv = ggz_malloc(sizeof(char*)*(i+1));
        this.argv = argv;
        this.pwd = pwd;
        
//        for (i = 0; argv[i]; i++) 
//            this.argv[i] = ggz_strdup(argv[i]);
    }


    public void set_gamedata( Object data)
    {
            this.gamedata = data;
    }


    public void set_server_host(
                    String host, int port,
                    String handle)
    {
        if (this.type == ModType.GGZMOD_GGZ) {
            /* If we're already connected, send the fd */
            if (this.state == ModState.GGZMOD_STATE_CONNECTED)
                _io_ggz_send_server(this.fd, host, port, handle);
            this.server_host = host;
            this.server_port = port;
            this.server_handle = handle;
        }
    }


    void set_server_fd( int fd)
    {
        if (ggzmod && this.type == GGZMOD_GGZ) {
            /* If we're already connected, send the fd */
            if (this.state == GGZMOD_STATE_CONNECTED)
                _io_ggz_send_server_fd(this.fd, fd);
        }
    }


    void set_handler( GGZModEvent e,
                 GGZModHandler func)
    {
        if (!ggzmod || e < 0 || e >= GGZMOD_NUM_HANDLERS) {
            ggz_error_msg("set_handler: "
                      "invalid params");
            return;     /* not very useful */
        }

        this.handlers[e] = func;
    }


    void set_transaction_handler(
                        GGZModTransaction t,
                        GGZModTransactionHandler func)
    {
        if (!ggzmod
            || t < 0 || t >= GGZMOD_NUM_TRANSACTIONS
            || this.type != GGZMOD_GGZ) {
            ggz_error_msg("set_transaction_handler: "
                      "invalid params");
            return;
        }

        this.thandlers[t] = func;
    }

    private void _set_player(
                       String name,
                       boolean is_spectator, int seat_num)
    {
        this.my_name = name;

        this.i_am_spectator = is_spectator;
        this.my_seat_num = seat_num;
    }

    public void set_player(String name,
                  boolean is_spectator, int seat_num)
    {
        if (this.type != ModType.GGZMOD_GGZ)
            throw new IllegalStateException("Cannot set player for this type of module");

        _set_player(name, is_spectator, seat_num);

        if (this.state != GGZMOD_STATE_CREATED)
            _io_ggz_send_player(this.fd, name, is_spectator, seat_num);

    }

    /*
     * Seats and spectator seats.
     */

//    static GGZSeat *seat_copy(GGZSeat *orig)
//    {
//        GGZSeat *seat;
//
//        seat = ggz_malloc(sizeof(*seat));
//
//        seat->num = orig->num;
//        seat->type = orig->type;
//        seat->name = ggz_strdup(orig->name);
//
//        return seat;
//    }
//
//    static int seat_compare(GGZSeat *a, GGZSeat *b)
//    {
//        return a->num - b->num;
//    }
//
//    static void seat_free(GGZSeat *seat)
//    {
//        if (seat->name)
//            ggz_free(seat->name);
//        ggz_free(seat);
//    }

//    static GGZSpectatorSeat* spectator_seat_copy(GGZSpectatorSeat *orig)
//    {
//        GGZSpectatorSeat *seat;
//
//        seat = ggz_malloc(sizeof(*seat));
//
//        seat->num = orig->num;
//        seat->name = ggz_strdup(orig->name);
//
//        return seat;
//    }
//
//    static int spectator_seat_compare(GGZSpectatorSeat *a, GGZSpectatorSeat *b)
//    {
//        return a->num - b->num;
//    }
//
//    static void spectator_seat_free(GGZSpectatorSeat *seat)
//    {
//        if (seat->name)
//            ggz_free(seat->name);
//
//        ggz_free(seat);
//    }

    private void _set_seat(Seat seat)
    {
        if (seat.num >= this.num_seats)
            this.num_seats = seat.num + 1;
        //ggz_list_insert(this.seats, seat);
        assert(seat.num == this.num_seats-1);
        this.seats.add(seat);
    }

    private Seat _get_seat(int num)
    {
//        GGZSeat seat = {num: num,
//                type: GGZ_SEAT_NONE,
//                name: null};
//
//        if (num >= 0 && num < this.num_seats) {
//            GGZListEntry *entry;
//            entry = ggz_list_search(this.seats, &seat);
//            if (entry)
//                seat = *(GGZSeat*)ggz_list_get_data(entry);
//        }

        return this.seats.get(num);
    }

    void set_seat( Seat seat)
    {
        Seat oldseat;

        if (this.type == ModType.GGZMOD_GAME)
            throw UnsupportedOperationException("Cannot set_set for Mod with MotType="+this.type);

        if (seat==null || seat.num < 0) {
//            return -2;
            throw new IllegalArgumentException();
        }

        /* If there is no such seat, return error */
        oldseat = _get_seat(seat.num);

        if (oldseat.type == seat.type
            && oldseat.name.equals(seat.name)) {
            /* No change. */
//            return 0;
        }

        if (this.state != ModState.GGZMOD_STATE_CREATED) {
//            if (_io_ggz_send_seat(this.fd, seat) < 0)
//                _error("Error writing to game");
        }

        _set_seat(seat);

//        return 0;
    }

    static void _set_spectator_seat( GGZSpectatorSeat *seat)
    {
        if (seat->name) {
            if (seat->num >= this.num_spectator_seats)
                this.num_spectator_seats = seat->num + 1;
            ggz_list_insert(this.spectator_seats, seat);
        } else {
            /* Non-occupied seats are just empty entries in the list. */
            GGZListEntry *entry = ggz_list_search(this.spectator_seats,
                                  seat);
            ggz_list_delete_entry(this.spectator_seats, entry);

            /* FIXME: reduce num_spectator_seats */
        }
    }

    static GGZSpectatorSeat _get_spectator_seat( int num)
    {
        GGZSpectatorSeat seat = {num: num, name: null};

        if (num >= 0 && num < this.num_spectator_seats) {
            GGZListEntry *entry;
            entry = ggz_list_search(this.spectator_seats, &seat);
            if (entry)
              seat = *(GGZSpectatorSeat*)ggz_list_get_data(entry);
        }

        return seat;
    }

    int set_spectator_seat( GGZSpectatorSeat *seat)
    {
        if (!seat) return -1;
        if (this.type == GGZMOD_GAME) return -2;
        if (seat->num < 0) return -3;

        if (this.state != GGZMOD_STATE_CREATED) {
            GGZSpectatorSeat old_seat;
            old_seat = _get_spectator_seat(ggzmod, seat->num);
            if (ggz_strcmp(seat->name, old_seat.name)
                && _io_ggz_send_spectator_seat(this.fd, seat) < 0) {
                _error("Error writing to game");
                return -4;
            }
        }

        _set_spectator_seat(ggzmod, seat);

        return 0;
    }

    public void inform_chat( String player, String msg)
    {
        //_io_ggz_send_msg_chat(this.fd, player, msg);
    }


    /* 
     * GGZmod actions
     */

    void connect()
    {
        if (this.type == ModType.GGZMOD_GGZ) {
            /* For the ggz side, we fork the game and then send the launch message */
            
//            if (this.argv != null) {
//                if (game_fork(ggzmod) < 0) {
//                    _error("Error: table fork failed");
//                    return -1;
//                }
//            } else {
//                log.fine( "Running embedded game (no fork)");
//                if (game_embedded(ggzmod) < 0) {
//                    _error("Error: embedded table failed");
//                    return -1;
//                }
//            }
            
            send_game_launch();
//            if (send_game_launch() < 0) {
//                _error("Error sending launch to game");
//                return -1;
//            }
        }
    }


//    int dispatch()
//    {
//        struct timeval timeout;
//        fd_set read_fd_set;
//        int status;
//
//        if (!ggzmod)
//            return -1;
//
//        if (this.fd < 0)
//            return -1;
//
//        FD_ZERO(&read_fd_set);
//        FD_SET(this.fd, &read_fd_set);
//
//        timeout.tv_sec = timeout.tv_usec = 0;   /* is this really portable? */
//        
//        status = select(this.fd + 1, &read_fd_set, null, null, &timeout);
//
//        if (status == 0) {
//            /* Nothing to read. */
//            return 0;
//        } else if (status < 0) {
//            if (errno == EINTR)
//                return 0;
//            return -1;
//        }
//        
//        return _handle_event(read_fd_set);
//    }

//    int disconnect()
//    {
//        if (this.fd < 0) {
//            /* This isn't an error; it usually means
//               we already disconnected.  The invariant is that the
//               process (this.pid) exists iff the socket (this.fd)
//               exists. */
//            return 0;
//        }
//
//        if (this.type == GGZMOD_GGZ) {
//            /* For the ggz side, we kill the game server and close the socket */
//            
//    #ifdef HAVE_KILL
//            /* Make sure game server is dead */
//            if (this.pid > 0) {
//                kill(this.pid, SIGINT);
//                /* This will block waiting for the child to exit.
//                   This could be a problem if there is an error
//                   (or if the child refuses to exit...). */
//                (void) waitpid(this.pid, null, 0);
//            }
//            this.pid = -1;
//    #else
//    #  ifdef HAVE_WINSOCK2_H
//            if (this.process != INVALID_HANDLE_VALUE) {
//                TerminateProcess(this.process, 0);
//                CloseHandle(this.process);
//                this.process = INVALID_HANDLE_VALUE;
//            }
//    #  endif
//    #endif
//            
//            _set_state(ggzmod, GGZMOD_STATE_DONE);
//            /* FIXME: what other cleanups should we do? */
//        }
//        
//        /* We no longer free the seat data here.  It will stick around until
//           free is called or it is used again. */
//
//        /* Clean up the ggzmod object.  In theory it could now reconnect for
//           a new game. */
//    #ifdef HAVE_WINSOCK2_H
//        closesocket(this.fd);
//    #else
//        close(this.fd);
//    #endif
//        this.fd = -1;
//
//        return 0;
//    }



    /* Returns -1 on error, the number of events handled on success. */
//    private int _handle_event( fd_set read_fds)
//    {
//        int status = 0;
//        
//        if (FD_ISSET(this.fd, &read_fds)) {
//            status = _io_ggz_read_data(ggzmod);
//            if (status < 0) {
//                _error("Error reading data");
//                /* FIXME: should be disconnect? */
//                _set_state(ggzmod, GGZMOD_STATE_DONE);
//            }
//        }
//
//        return status;
//    }


    private void _set_state(ModState state)
    {
        ModState old_state = this.state;
        if (state == this.state)
            return;     /* Is this an error? */

        /* The callback function retrieves the state from get_state.
           It could instead be passed as an argument. */
        this.state = state;
        call_handler(ModEvent.GGZMOD_EVENT_STATE, old_state);
    }




    /* 
     * ggz specific actions
     */

    /* Sends a game launch packet to ggzmod-game. A negative return value
       indicates a serious (fatal) error. */
    private void send_game_launch()
    {
//        GGZListEntry *entry;
//
//        if (_io_ggz_send_player(this.fd,
//                    this.my_name,
//                    this.i_am_spectator,
//                    this.my_seat_num) < 0)
//            return -2;
//
//        for (entry = ggz_list_head(this.seats);
//             entry;
//             entry = ggz_list_next(entry)) {
//            GGZSeat *seat = ggz_list_get_data(entry);
//            if (_io_ggz_send_seat(this.fd, seat) < 0)
//                return -3;
//        }
//        for (entry = ggz_list_head(this.spectator_seats);
//             entry;
//             entry = ggz_list_next(entry)) {
//            GGZSpectatorSeat *seat = ggz_list_get_data(entry);
//            if (_io_ggz_send_spectator_seat(this.fd, seat) < 0)
//                return -4;
//        }
//
//        if (_io_ggz_send_launch(this.fd) < 0)
//            return -1;
//
//        /* If the server fd has already been set, send that too */
//        if (this.server_fd != -1)
//            if (_io_ggz_send_server_fd(this.fd, this.server_fd) < 0)
//                return -5;
//
//        if (this.server_host)
//            if (_io_ggz_send_server(this.fd, this.server_host,
//                        this.server_port,
//                        this.server_handle) < 0)
//                return -5;
//
//        return 0;
    }


    /* Common setup for normal mode and embedded mode */
    static int game_prepare(int fd_pair[2], int *sock)
    {
    #ifdef HAVE_SOCKETPAIR
        if (socketpair(PF_LOCAL, SOCK_STREAM, 0, fd_pair) < 0)
            ggz_error_sys_exit("socketpair failed");
        setenv("GGZSOCKET", "103", 1);
        setenv("GGZMODE", "true", 1);
    #else
        /* Winsock implementation: see connect. */
        port = 5898;
        do {
            port++;
            *sock = ggz_make_socket(GGZ_SOCK_SERVER, port, null);
        } while (*sock < 0 && port < 7000);
        if (*sock < 0) {
            ggz_error_msg("Could not bind socket.");
            return -1;
        }
        if (listen(*sock, 1) < 0) {
            ggz_error_msg("Could not listen on socket.");
            return -1;
        }
        snprintf(buf, sizeof(buf), "%d", port);
    #ifdef HAVE_SETENV
        setenv("GGZSOCKET", buf, 1);
        setenv("GGZMODE", "true", 1);
    #else
        SetEnvironmentVariable("GGZSOCKET", buf);
        SetEnvironmentVariable("GGZMODE", "true");
    #endif
    #endif

        return 0;
    }

    /* Forks the game.  A negative return value indicates a serious error. */
    /* No locking should be necessary within this function. */
    static int game_fork()
    {
        int sock;
    #ifdef HAVE_SOCKETPAIR
        int fd_pair[2];     /* socketpair */
    #else
        int sock2, port;
        char buf[100];
    #endif
    #ifdef HAVE_FORK
        int pid;
    #else
        char cmdline[1024] = "";
        int i;
        PROCESS_INFORMATION pi;
        STARTUPINFO si;
    #endif

        /* If there are no args, we don't know what to run! */
        if (this.argv == null || this.argv[0] == null) {
            _error("No arguments");
            return -1;
        }

        if(game_prepare(fd_pair, &sock) < 0)
            return -1;

    #ifdef HAVE_FORK
        if ((pid = fork()) < 0)
            ggz_error_sys_exit("fork failed");
        else if (pid == 0) {
            /* child */
    #ifdef HAVE_SOCKETPAIR
            close(fd_pair[0]);

            /* debugging message??? */

            /* Now we copy one end of the socketpair to fd 103 */
            if (fd_pair[1] != 103) {
                /* We'd like to send an error message if either of
                   these fail, but we can't.  --JDS */
                if (dup2(fd_pair[1], 103) != 103 || close(fd_pair[1]) < 0)
                    ggz_error_sys_exit("dup failed");
            }
    #else
            close(sock);
    #endif

            /* FIXME: Close all other fd's? */
            /* FIXME: Not necessary to close other fd's if we use
               CLOSE_ON_EXEC */

            /* Set working directory */
            if (this.pwd
                && chdir(this.pwd) < 0) {
                /* FIXME: what to do? */
            }

            /* FIXME: can we call log() from here? */
            execv(this.argv[0], this.argv);   /* run game */

            /* We should never get here.  If we do, it's an eror */
            /* we still can't send error messages... */
            ggz_error_sys_exit("exec of %s failed", this.argv[0]);
        } else {
            /* parent */
    #ifdef HAVE_SOCKETPAIR
            close(fd_pair[1]);

            this.fd = fd_pair[0];
    #endif
            this.pid = pid;
            
            /* FIXME: should we delete the argv arguments? */
            
            /* That's all! */
        }
    #else
        for (i = 0; this.argv[i]; i++) {
            snprintf(cmdline + strlen(cmdline),
                 sizeof(cmdline) - strlen(cmdline),
                 "%s ", this.argv[i]);
        }

        ZeroMemory(&si, sizeof(si));
        if (!CreateProcess(null, cmdline, null, null, TRUE,
                   DETACHED_PROCESS | NORMAL_PRIORITY_CLASS,
                   null, null, &si, &pi)) {
            return -1;
        }
        CloseHandle(pi.hThread);
        this.process = pi.hProcess;
    #endif
    #ifndef HAVE_SOCKETPAIR
        /* FIXME: we need to select, with a maximum timeout. */
        /* FIXME: this is insecure; it should be restricted to local
         * connections. */
        sock2 = accept(sock, null, null);
        if (sock2 < 0) {
            ggz_error_sys("Listening to socket failed.");
            return -1;
        }
    #ifdef HAVE_WINSOCK2_H
        closesocket(sock);
    #else
        close(sock);
    #endif
        this.fd = sock2;
    #endif
        return 0;
    }


    /* Similar to game_fork(), but runs the game embedded */
    static int game_embedded()
    {
        int sock;
    #ifdef HAVE_SOCKETPAIR
        int fd_pair[2];     /* socketpair */
    #else
        int sock2, port;
        char buf[100];
    #endif

        if(game_prepare(fd_pair, &sock) < 0)
            return -1;

    #ifdef HAVE_SOCKETPAIR
        if (fd_pair[1] != 103) {
            /* We'd like to send an error message if either of
               these fail, but we can't.  --JDS */
            if (dup2(fd_pair[1], 103) != 103 || close(fd_pair[1]) < 0)
                ggz_error_sys_exit("dup failed");
        }

        this.fd = fd_pair[0];
    #else
        /* FIXME: we need to select, with a maximum timeout. */
        /* FIXME: this is insecure; it should be restricted to local
         * connections. */
        sock2 = accept(sock, null, null);
        if (sock2 < 0) {
            ggz_error_sys("Listening to socket failed.");
            return -1;
        }
    #ifdef HAVE_WINSOCK2_H
        closesocket(sock);
    #else
        close(sock);
    #endif
        this.fd = sock2;
    #endif
    #ifdef HAVE_FORK
        this.pid = -1; /* FIXME: use -1 for embedded ggzcore? getpid()? */
    #else
        this.process = INVALID_HANDLE_VALUE;
    #endif

        return 0;
    }


    /**** Internal library functions ****/

    /* Invokes handlers for the specified event */
    private void call_handler(ModEvent event, Object data)
    {
//        if (this.handlers[event])
//            (this.handlers[event]) (ggzmod, event, data);
    }


    private void call_transaction( ModTransaction t, Object data)
    {
//        if (!this.thandlers[t]) {
//            ggz_error_msg("Unhandled transaction %d.", t);
//            return;
//        }

        if (this.type != ModType.GGZMOD_GGZ) {
            throw new IllegalStateException("The game can't handle transactions!");
        }

//        (*this.thandlers[t])(ggzmod, t, data);
//        switch (t) {
//        case GGZMOD_TRANSACTION_BOOT: thandlers.fire_boot_request(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        case GGZMOD_TRANSACTION_: thandlers.fire_(); break;
//        }
    }


    private void _error(String error)
    {
        call_handler(ModEvent.GGZMOD_EVENT_ERROR, error);
    }


    void _handle_state( ModState state)
    {
        /* There's only certain ones the game is allowed to set it to,
           and they can only change it if the state is currently
           WAITING or PLAYING. */
        switch (state) {
        case GGZMOD_STATE_CREATED:
        case GGZMOD_STATE_CONNECTED:
        case GGZMOD_STATE_WAITING:
        case GGZMOD_STATE_PLAYING:
        case GGZMOD_STATE_DONE:
            /* In contradiction to what I say above, the game
               actually _is_ allowed to change its state from
               CREATED to WAITING.  When ggzmod-ggz sends a
               launch packet to ggzmod-game, ggzmod-game
               automatically changes the state from CREATED
               to WAITING.  When this happens, it tells
               ggzmod-ggz of this change and we end up back
               here.  So, although it's a bit unsafe, we have
               to allow this for now.  The alternative would
               be to have ggzmod-ggz and ggzmod-game both
               separately change states when the launch packet
               is sent. */
            _set_state(state);
            return;
        }
        _error("Game requested incorrect state value");

        /* Is this right? has the gameover happened yet? */
    }

    void _handle_stand_request(Mod ggzmod)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_STAND, null);
    }

    void _handle_sit_request(int seat_num)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_SIT, seat_num);
    }

    void _handle_boot_request(String name)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_BOOT, name);
    }

    void _handle_bot_request(int seat_num)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_BOT, seat_num);
    }

    void _handle_open_request(int seat_num)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_OPEN, seat_num);
    }

    void _handle_chat_request(String chat_msg)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_CHAT, chat_msg);
    }

    void _handle_info_request(int seat_num)
    {
        call_transaction(ModTransaction.GGZMOD_TRANSACTION_INFO, seat_num);
    }

    void set_stats(Stat player_stats,
                 Stat spectator_stats)
    {
        if (player_stats == null
            || (spectator_stats == null && this.num_spectator_seats > 0)
            || this.type != ModType.GGZMOD_GGZ
            || this.state != ModState.GGZMOD_STATE_CREATED) {
            throw new IllegalArgumentException();
        }

        _io_ggz_send_stats(this.fd, this.num_seats, player_stats,
                      this.num_spectator_seats, spectator_stats);
    }

    public void set_info(int num, List infos)
    {
//        return _io_ggz_send_msg_info(this.fd, num, infos);
    }
    
    private class HookList {
        private EventListenerList listeners = new EventListenerList();

        public void addModTransactionHandler(ModTransactionHandler l) {
            listeners.add(ModTransactionHandler.class, l);
        }

        public void removeModTransactionHandler(ModTransactionHandler l) {
            listeners.remove(ModTransactionHandler.class, l);
        }

        public void fire_boot_request(String name) {
            // Java 5 inferred type
            ModTransactionHandler[] listenerArry = listeners
                    .getListeners(ModTransactionHandler.class);
            for (int i = 0; i < listenerArry.length; i++) {
                ModTransactionHandler listener = listenerArry[i];
                listener.handle_boot(name);
            }
        }
    }
