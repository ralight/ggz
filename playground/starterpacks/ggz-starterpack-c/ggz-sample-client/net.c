/* Generated by GGZComm/ruby version 0.4 */
/* Protocol 'ggz_starterpack', version '1.0' */
/* Do NOT edit this file! */

#include "net.h"
#include <stdlib.h>
#include <ggz.h>


typedef struct ggzcommio_t
{
	int fd;
} GGZCommIO;

static notifier_func_type notifier_func = NULL;
static error_func_type error_func = NULL;
static int ret;
static int requirelink = 0;
static int nextlink;
static GGZCommIO *io = NULL;

static void ggzcomm_error(void);

GGZCommIO *ggzcomm_io_allocate(int fd);
void ggzcomm_io_free(GGZCommIO *io);

static void ggzcomm_hello(void)
{
	if(notifier_func)
		(notifier_func)(hello);
}

void ggzcomm_network_main(int fd)
{
	int opcode;

	if(!io)
	{
		io = ggzcomm_io_allocate(fd);
	}

	ggz_read_int(io->fd, &opcode);

	if(requirelink)
	{
		if(opcode != nextlink)
			ggzcomm_error();
		requirelink = 0;
	}

	switch(opcode)
	{
		case hello:
			ggzcomm_hello();
			break;
	}
}

void ggzcomm_set_notifier_callback(notifier_func_type f)
{
	notifier_func = f;
}

void ggzcomm_set_error_callback(error_func_type f)
{
	error_func = f;
}

GGZCommIO *ggzcomm_io_allocate(int fd)
{
	GGZCommIO *io = ggz_malloc(sizeof(GGZCommIO));
	io->fd = fd;
	return io;
}

void ggzcomm_io_free(GGZCommIO *io)
{
	ggz_free(io);
}

static void ggzcomm_error(void)
{
	if(error_func) (error_func)();
}

