/* Generated by GGZComm/ruby version 0.4 */
/* Protocol 'ggz_starterpack', version '1.0' */
/* Do NOT edit this file! */

#include "net.h"
#include <kggznet/kggzpacket.h>
#include <qdatastream.h>


ggz_starterpack::ggz_starterpack()
: QObject()
{
	requirelink = 0;
	fd = -1;
	packet = NULL;
}

void ggz_starterpack::ggzcomm_hello(const hello& message)
{
	*packet->outputstream() << ggz_starterpackOpcodes::message_hello;
	packet->flush();
}

void ggz_starterpack::ggzcomm_network_main()
{
	packet->slotNetwork(fd);
}

void ggz_starterpack::ggzcomm_ready()
{
	int opcode;

	*packet->inputstream() >> opcode;

	if(requirelink)
	{
		if(opcode != nextlink) emit signalError();
		requirelink = 0;
	}

	switch(opcode)
	{
	}
}

void ggz_starterpack::ggzcomm_set_fd(int usefd)
{
	fd = usefd;
	packet = new KGGZPacket();
	connect(packet, SIGNAL(signalError()), SIGNAL(signalError()));
	connect(packet, SIGNAL(signalPacket()), SLOT(ggzcomm_ready()));
}

void ggz_starterpack::ggzcomm_set_socket(KGGZPacket *usepacket)
{
	packet = usepacket;
	connect(packet, SIGNAL(signalError()), SIGNAL(signalError()));
	connect(packet, SIGNAL(signalPacket()), SLOT(ggzcomm_ready()));
}

