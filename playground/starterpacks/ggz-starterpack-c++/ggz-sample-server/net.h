/* Generated by GGZComm/ruby version 0.4 */
/* Protocol 'ggz_starterpack', version '1.0' */
/* Do NOT edit this file! */

#ifndef GGZCOMM_GGZ_STARTERPACK_H
#define GGZCOMM_GGZ_STARTERPACK_H

#include <qobject.h>

class KGGZPacket;

class ggz_starterpackOpcodes
{
	public:
	enum Opcode
	{
		message_hello = 999
	};
};

class msg
{
	public:
	msg(ggz_starterpackOpcodes::Opcode type){m_type = type;}
	ggz_starterpackOpcodes::Opcode type() const{return m_type;}
	private:
	ggz_starterpackOpcodes::Opcode m_type;
};

class hello : public msg
{
	public:
	hello() : msg(ggz_starterpackOpcodes::message_hello){}

};

class ggz_starterpack : public QObject
{
	Q_OBJECT
	public:
	ggz_starterpack();

	void ggzcomm_network_main();

	void ggzcomm_hello(const hello& message);

	void ggzcomm_set_fd(int usefd);
	void ggzcomm_set_socket(KGGZPacket *usepacket);

	signals:
	void signalNotification(ggz_starterpackOpcodes::Opcode messagetype, const msg& message);
	void signalError();

	private slots:
	void ggzcomm_ready();

	private:
	void handle(bool ret);

	int fd;
	int ret;
	int requirelink;
	int nextlink;
	KGGZPacket *packet;
	QDataStream *socket;
};

#endif

