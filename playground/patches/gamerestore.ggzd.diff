Index: ggzdmod++/ggzgameserver.cpp
===================================================================
--- ggzdmod++/ggzgameserver.cpp	(Revision 9802)
+++ ggzdmod++/ggzgameserver.cpp	(Arbeitskopie)
@@ -59,6 +59,10 @@
 				GGZdModEvent event, const void *data);
 			static void handle_spectator_seat(GGZdMod* ggzdmod,
 				GGZdModEvent event, const void *data);
+			static void handle_savedgame(GGZdMod* ggzdmod,
+				GGZdModEvent, const void *data);
+			static void handle_state_changed(GGZdMod *ggzdmod,
+				GGZdModEvent, const void *data);
 			void selfcheck();
 			// Parent object (which is a singleton in 'self')
 			static GGZGameServer *m_parent;
@@ -240,6 +244,16 @@
 	ggzdmod_set_state(m_private->ggzdmod(), (GGZdModState)state);
 }
 
+void GGZGameServer::requestSavedGames()
+{
+	ggzdmod_request_savedgames(m_private->ggzdmod());
+}
+
+void GGZGameServer::reportSave(const char *savedGame)
+{
+	ggzdmod_report_savegame(m_private->ggzdmod(), savedGame);
+}
+
 // Implementation of the internal class
 GGZGameServerPrivate::GGZGameServerPrivate(GGZGameServer *parent)
 {
@@ -259,6 +273,8 @@
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_LEAVE, &handle_spectator_leave);
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_DATA, &handle_spectator_data);
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_SEAT, &handle_spectator_seat);
+	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SAVEDGAME, &handle_savedgame);
+	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED, &handle_state_changed);
 
 	selfcheck();
 }
@@ -282,6 +298,7 @@
 	if((int)Seat::abandoned != (int)GGZ_SEAT_ABANDONED) error = true;
 
 	if((int)GGZGameServer::created != (int)GGZDMOD_STATE_CREATED) error = true;
+	if((int)GGZGameServer::restored != (int)GGZDMOD_STATE_RESTORED) error = true;
 	if((int)GGZGameServer::waiting != (int)GGZDMOD_STATE_WAITING) error = true;
 	if((int)GGZGameServer::playing != (int)GGZDMOD_STATE_PLAYING) error = true;
 	if((int)GGZGameServer::done != (int)GGZDMOD_STATE_DONE) error = true;
@@ -378,3 +395,16 @@
 	m_parent->spectatorEvent(spectator);
 }
 
+void GGZGameServerPrivate::handle_savedgame(GGZdMod *ggzdmod, GGZdModEvent event, const void *data)
+{
+	std::cout << "GGZGameServer: savedgame event." << std::endl;
+	SavedGame savedGame(static_cast<const char *>(data));
+	m_parent->savedgameEvent(&savedGame);
+}
+
+void GGZGameServerPrivate::handle_state_changed(GGZdMod *ggzdmod, GGZdModEvent, const void *data)
+{
+	std::cout << "GGZGameServer: state changed to: ";
+	std::cout << (int)m_parent->state() << std::endl;
+	m_parent->stateEvent();
+}
Index: ggzdmod++/ggzgameserver.h
===================================================================
--- ggzdmod++/ggzgameserver.h	(Revision 9802)
+++ ggzdmod++/ggzgameserver.h	(Arbeitskopie)
@@ -65,6 +65,16 @@
 		SeatType type;
 };
 
+class SavedGame
+{
+	public:
+		SavedGame(const char *_savedgame) : savedgame(_savedgame) {}
+		const std::string& getName() const { return savedgame; };
+
+	private:
+		const std::string savedgame;
+};
+
 /* Class representing a game server module.
  * It is used by reimplementing the virtual methods, and then calling
  * connect().
@@ -91,7 +101,8 @@
 			created,
 			waiting,
 			playing,
-			done
+			done,
+			restored
 		};
 
 		/* Callback for idle events (only in async mode) */
@@ -113,6 +124,9 @@
 		/* A spectator seat change happened */
 		virtual void spectatorEvent(Spectator *spectator);
 
+		/* Got saved game name. This event occurred for each saved game name */
+		virtual void savedgameEvent(SavedGame *savedGames) {};
+
 		/* Current game state */
 		State state();
 		/* Announce a state transition */
@@ -148,6 +162,9 @@
 			return s->client->fd;
 		}
 
+		void requestSavedGames();
+		void reportSave(const char *);
+
 	private:
 		GGZGameServerPrivate *m_private;
 		int m_connected;
Index: game_servers/tictactoe/tictactoe.dsc
===================================================================
--- game_servers/tictactoe/tictactoe.dsc	(Revision 9802)
+++ game_servers/tictactoe/tictactoe.dsc	(Arbeitskopie)
@@ -22,6 +22,7 @@
 BotsAllowed = 1
 PlayersAllowed = 2
 AllowSpectators = 1
+AllowRestore = 1
 
 [Statistics]
 Records = 1
Index: game_servers/tictactoe/Makefile.am
===================================================================
--- game_servers/tictactoe/Makefile.am	(Revision 9802)
+++ game_servers/tictactoe/Makefile.am	(Arbeitskopie)
@@ -13,7 +13,8 @@
 	ttt-ai.c \
 	ttt-ai.h
 
-AM_CPPFLAGS = -I$(top_srcdir)/ggzdmod $(LIBGGZ_INCLUDES)
+AM_CPPFLAGS = -I$(top_srcdir)/ggzdmod $(LIBGGZ_INCLUDES) \
+	-DGGZDSTATEDIR=\"$(ggzdstatedir)\"
 ggzd_tictactoe_LDADD = $(LDADD) $(top_builddir)/ggzdmod/libggzdmod.la
 
 PROTOCOL = tictactoe
Index: game_servers/tictactoe/game.c
===================================================================
--- game_servers/tictactoe/game.c	(Revision 9802)
+++ game_servers/tictactoe/game.c	(Arbeitskopie)
@@ -116,6 +116,8 @@
 #endif
 static void game_handle_ggz_player(GGZdMod *ggz,
                                    GGZdModEvent event, const void *data);
+static void game_handle_gamestatechanged(GGZdMod *ggz,
+                                  GGZdModEvent event, const void *data);
 
 /* Network IO main functions */
 static void game_network_data(int opcode);
@@ -176,6 +178,8 @@
 	ggzdmod_set_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_SEAT,
 	                    &game_handle_ggz_spectator_seat);
 #endif
+	ggzdmod_set_handler(ggzdmod, GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED,
+	                    &game_handle_gamestatechanged);
 
 	/* Setup the network callbacks for GGZComm */
 	ggzcomm_set_notifier_callback(game_network_data);
@@ -183,6 +187,13 @@
 }
 
 
+/* Callback for GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED */
+static void game_handle_gamestatechanged(GGZdMod *ggz, GGZdModEvent event,
+				  const void *data)
+{
+	/* FIXME: what to do here? */
+}
+
 /* Callback for GGZDMOD_EVENT_STATE */
 static void game_handle_ggz_state(GGZdMod *ggz, GGZdModEvent event,
 				  const void *data)
@@ -220,6 +231,10 @@
 	case GGZDMOD_STATE_DONE:
 		/* The game is over and will be destroyed */
 		break;
+	case GGZDMOD_STATE_RESTORED:
+		/* The game is being restored. */
+		/* FIXME: we need to read in a savegame here. */
+		break;
 	}
 }
 
@@ -714,7 +729,7 @@
 	va_list ap;
 
 	if(!ttt_game.savegame) {
-		savegamepath = strdup(GGZDDATADIR "/gamedata/TicTacToe/" TEMPLATE);
+		savegamepath = strdup(GGZDSTATEDIR "/gamedata/TicTacToe/" TEMPLATE);
 		fd = mkstemp(savegamepath);
 		savegamename = strdup(savegamepath + strlen(savegamepath) - strlen(TEMPLATE));
 		free(savegamepath);
Index: ggzdmod/ggzdmod.h
===================================================================
--- ggzdmod/ggzdmod.h	(Revision 9802)
+++ ggzdmod/ggzdmod.h	(Arbeitskopie)
@@ -216,7 +216,9 @@
 	GGZDMOD_STATE_CREATED,	/**< Pre-launch; waiting for ggzdmod */
 	GGZDMOD_STATE_WAITING,	/**< Ready and waiting to play. */
 	GGZDMOD_STATE_PLAYING,	/**< Currently playing a game. */
-	GGZDMOD_STATE_DONE	/**< Table halted, prepping to exit. */
+	GGZDMOD_STATE_DONE,	/**< Table halted, prepping to exit. */
+	GGZDMOD_STATE_RESTORED  /**< Pre-launch if server restore all saved games
+	                             ; waiting for ggzdmod */
 } GGZdModState;
 
 /** @brief Callback events.
@@ -318,6 +320,12 @@
 	 */
 	GGZDMOD_EVENT_SPECTATOR_DATA,
 
+	/** @brief Data about saved games avaiable from ggzd
+         *  This message is answer to saved games request.
+	 */
+	GGZDMOD_EVENT_SAVEDGAME,
+	GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED,
+
 	/** @brief An error has occurred
 	 *  This event occurs when a GGZdMod error has occurred.  An
 	 *  error message (a const char*) will be passed as the event's data.
@@ -700,6 +708,8 @@
  */
 void ggzdmod_report_savegame(GGZdMod *ggzdmod, const char *savegame);
 
+void ggzdmod_request_savedgames(GGZdMod *ggzdmod);
+
 /** @brief Tell GGZ to change the number of seats at this table.
  *  @note This functionality is incomplete, and should not yet be used. */
 void ggzdmod_request_num_seats(GGZdMod * ggzdmod, int num_seats);
@@ -713,6 +723,9 @@
 /** @brief Tell GGZ to change the given seat from BOT/RESERVED to OPEN. */
 void ggzdmod_request_open(GGZdMod * ggzdmod, int seat_num);
 
+/** @brief Tell GGZ to change the given seat to ABANDONED. */
+void ggzdmod_request_abandoned(GGZdMod *ggzdmod, int seat_num, const char *name);
+
 #ifdef __cplusplus
 }
 #endif
Index: ggzdmod/mod.h
===================================================================
--- ggzdmod/mod.h	(Revision 9802)
+++ ggzdmod/mod.h	(Arbeitskopie)
@@ -36,6 +36,12 @@
 /* FIXME: hard-coding this is a sure way to get bugs! */
 #define GGZDMOD_NUM_EVENTS (GGZDMOD_EVENT_ERROR_INTERNAL + 1)
 
+struct GGZdModSave {
+	long date;
+	char *name;
+	char *owner;
+};
+
 /* This is the actual structure, but it's only visible internally. */
 struct GGZdMod {
 	GGZdModType type;	/* ggz-end or game-end */
@@ -67,10 +73,14 @@
 			    int num_players, char **names, GGZSeatType *types,
 			    int *teams, GGZGameResult *results, int *scores);
 void _ggzdmod_handle_savegame(GGZdMod * ggzdmod, char *savegame);
+void _ggzdmod_handle_req_savedgames(GGZdMod *ggzdmod);
 void _ggzdmod_handle_num_seats_request(GGZdMod *ggzdmod, int num_seats);
 void _ggzdmod_handle_boot_request(GGZdMod *ggzdmod, char *name);
 void _ggzdmod_handle_bot_request(GGZdMod *ggzdmod, int seat_num);
 void _ggzdmod_handle_open_request(GGZdMod *ggzdmod, int seat_num);
+void _ggzdmod_handle_abandoned_request(GGZdMod *ggzdmod, int seat_num,
+				       const char *name);
+void _ggzdmod_handle_stage_change_response(GGZdMod *ggzdmod);
 
 /* Game side functions for handling various messages */
 void _ggzdmod_handle_launch_begin(GGZdMod * ggzdmod, const char *game, int num_seats, int num_spectators);
@@ -82,5 +92,7 @@
 			    int new_seat, int is_spectator);
 void _ggzdmod_handle_spectator_seat(GGZdMod * ggzdmod, GGZSeat *seat);
 void _ggzdmod_handle_state_response(GGZdMod * ggzdmod);
+void _ggzdmod_handle_savedgame(GGZdMod *ggzdmod, const char *savedgame);
+void _ggzdmod_handle_state_changed(GGZdMod *ggzdmod, GGZdModState state);
 
 #endif /* GGZDMOD_MOD_H */
Index: ggzdmod/ggzdmod-ggz.h
===================================================================
--- ggzdmod/ggzdmod-ggz.h	(Revision 9802)
+++ ggzdmod/ggzdmod-ggz.h	(Arbeitskopie)
@@ -103,6 +103,10 @@
 	int *scores;
 } GGZdModGameReportData;
 
+/** @brief Send saved game to game module
+ */
+int ggzdmod_send_savedgame(GGZdMod *ggzdmod, const char *savedgame);
+
 /** @brief Callback events (GGZ-side additions).
  *
  *  These events are triggered by the game server and delivered
@@ -116,6 +120,7 @@
 
 	/** @brief For GGZ only.  Reports a savegame. */
 	GGZDMOD_EVENT_SAVEGAMEREPORT,
+	GGZDMOD_EVENT_SAVEDGAMESREQ,
 
 	/** @brief Module log request
 	 *  This event occurs when a log request happens.  This will
@@ -135,6 +140,10 @@
 	/* @brief GGZ-side only.  Requests to open up a seat. */
 	GGZDMOD_EVENT_REQ_OPEN,
 
+	/* @brief GGZ-side only. Request to abandon a seat */
+	GGZDMOD_EVENT_REQ_ABANDONED,
+	GGZDMOD_EVENT_GAME_STATE_CHANGED,
+
 	GGZDMOD_EVENT_ERROR_INTERNAL
 	/* GGZDMOD_EVENT_ERROR_INTERNAL must be the last one! */
 } GGZdModEventInternal;
Index: ggzdmod/protocol.h
===================================================================
--- ggzdmod/protocol.h	(Revision 9802)
+++ ggzdmod/protocol.h	(Arbeitskopie)
@@ -76,7 +76,18 @@
 	 * - an integer with the seat number of the affected seat
 	 */
 	REQ_OPEN,
+	REQ_ABANDONED,
 
+	/** @brief Signals the start of RSP_GAME_STATE_CHANGED
+	 *
+	 *  The packet is composed of:
+	 *    - An integer containing RPS_GAME_STATE_CHANGED.
+	 *  This packet is sent in response to a MSG_GAME_STATE_CHANGED.
+	 *  It's only effect is to let the table know the information
+	 *  has been received.
+	 */
+	RSP_GAME_STATE_CHANGED,
+
 	/* Signals the start of a MSG_GAME_REPORT packet which transmits game
 	 * results and statistics.
 	 * The packet is composed of:
@@ -99,7 +110,11 @@
 	 * - an integer containing MSG_SAVEGAME_REPORT
 	 * - an easysock-formatted string containing the path of the file
 	 */
-	MSG_SAVEGAME_REPORT
+	MSG_SAVEGAME_REPORT,
+    /** @brief Signals the start of a REQ_SAVEDGAMES packet.
+     *  This packet request saved games status data.
+     */
+    REQ_SAVEDGAMES
 } TableToControl;
 
 /** Messages sent from the ggz server to the game server. */
@@ -174,6 +189,25 @@
 	 *  only effect is to let the table know the information has
 	 */
 	RSP_GAME_STATE,
+
+	/** @brief Signals the start of MSG_GAME_STATE_CHANGED packet.
+	 *
+	 * The packet is composed of:
+	 *    - An integer containing MSG_GAME_STATE_CHANGED.
+	 *    - A single byte (char) containing the new game state.
+	 *      The state is a GGZdModState enumerated value.
+	 * This packet is send when server change game state. Used for
+	 * sending GGZMOD_STATE_RESTORED state status.
+	 */
+	MSG_GAME_STATE_CHANGED,
+
+	/** @brief Signals the start of a MSG_SAVEDGAMES packet.
+	 *
+	 *  The packed is composed of:
+	 *    - An integer containing the saved games names count.
+	 *    - An easysock-formated strings for each saved game.
+	 */
+	MSG_SAVEDGAMES
 } ControlToTable;
 
 #endif /* GGZDMOD_SERVER_PROTOCOL_H */
Index: ggzdmod/io.c
===================================================================
--- ggzdmod/io.c	(Revision 9802)
+++ ggzdmod/io.c	(Arbeitskopie)
@@ -43,13 +43,15 @@
 static int _io_read_req_boot(GGZdMod *ggzdmod);
 static int _io_read_req_bot(GGZdMod *ggzdmod);
 static int _io_read_req_open(GGZdMod *ggzdmod);
+static int _io_read_req_abandoned(GGZdMod *ggzdmod);
 
 static int _io_read_req_launch(GGZdMod *ggzdmod);
 static int _io_read_msg_seat_change(GGZdMod * ggzdmod);
 static int _io_read_msg_reseat(GGZdMod * ggzdmod);
 static int _io_read_msg_spectator_seat_change(GGZdMod *ggzdmod);
+static int _io_read_msg_game_state_changed(GGZdMod *ggzdmod);
+static int _io_read_msg_savedgames(GGZdMod *ggzdmod);
 
-
 /* Functions for sending IO messages */
 int _io_send_launch(int fd, const char *name, int seats, int spectators)
 {
@@ -123,7 +125,16 @@
 		return 0;
 }
 
+int _io_send_state_changed(int fd, GGZdModState state)
+{
+	if (ggz_write_int(fd, MSG_GAME_STATE_CHANGED) < 0
+	    || ggz_write_char(fd, state) < 0)
+		return -1;
+	else
+		return 0;
+}
 
+
 int _io_send_seat(int fd, const GGZSeat *seat)
 {
 	if (ggz_write_int(fd, seat->type) < 0)
@@ -189,6 +200,11 @@
 	return 0;
 }
 
+int _io_send_savedgames_request(int fd )
+{
+	return ggz_write_int(fd, REQ_SAVEDGAMES);
+}
+
 int _io_send_req_num_seats(int fd, int num_seats)
 {
 	if (ggz_write_int(fd, REQ_NUM_SEATS) < 0
@@ -221,13 +237,26 @@
 	return 0;
 }
 
+int _io_send_req_abandoned(int fd, int seat_num, const char *name)
+{
+	if (ggz_write_int(fd, REQ_ABANDONED) < 0
+	    || ggz_write_int(fd, seat_num) < 0
+	    || ggz_write_string(fd, name) < 0)
+		return -1;
+	return 0;
+}
 
 int _io_respond_state(int fd)
 {
 	return ggz_write_int(fd, RSP_GAME_STATE);
 }
 
+int _io_send_state_changed_response(int fd)
+{
+	return ggz_write_int(fd, RSP_GAME_STATE_CHANGED);
+}
 
+
 /* Functions for reading messages */
 int _io_read_data(GGZdMod * ggzdmod)
 {
@@ -249,6 +278,10 @@
 		case RSP_GAME_STATE:
 			_ggzdmod_handle_state_response(ggzdmod);
 			return 0;
+		case MSG_GAME_STATE_CHANGED:
+			return _io_read_msg_game_state_changed(ggzdmod);
+		case MSG_SAVEDGAMES:
+			return _io_read_msg_savedgames(ggzdmod);
 		}
 	} else {
 		switch ((TableToControl)op) {
@@ -260,6 +293,9 @@
 			return _io_read_msg_report(ggzdmod);
 		case MSG_SAVEGAME_REPORT:
 			return _io_read_msg_savegame(ggzdmod);
+		case REQ_SAVEDGAMES:
+			_ggzdmod_handle_req_savedgames(ggzdmod);
+			return 0;
 		case REQ_NUM_SEATS:
 			return _io_read_req_num_seats(ggzdmod);
 		case REQ_BOOT:
@@ -268,6 +304,11 @@
 			return _io_read_req_bot(ggzdmod);
 		case REQ_OPEN:
 			return _io_read_req_open(ggzdmod);
+		case REQ_ABANDONED:
+			return _io_read_req_abandoned(ggzdmod);
+		case RSP_GAME_STATE_CHANGED:
+			_ggzdmod_handle_stage_change_response(ggzdmod);
+			return 0;
 		}
 	}
 
@@ -401,13 +442,26 @@
 static int _io_read_req_open(GGZdMod *ggzdmod)
 {
 	int seat_num;
+
 	if (ggz_read_int(ggzdmod->fd, &seat_num) < 0)
 		return -1;
 	_ggzdmod_handle_open_request(ggzdmod, seat_num);
 	return 0;
 }
 
+static int _io_read_req_abandoned(GGZdMod *ggzdmod)
+{
+	int seat_num;
+	char *name;
 
+	if (ggz_read_int(ggzdmod->fd, &seat_num)
+	    || ggz_read_string_alloc(ggzdmod->fd, &name))
+		return -1;
+	_ggzdmod_handle_abandoned_request(ggzdmod, seat_num, name);
+	ggz_free(name);
+	return 0;
+}
+
 static int _io_read_req_launch(GGZdMod * ggzdmod)
 {
 	int seats, spectators, i;
@@ -425,6 +479,7 @@
 
 	for (i = 0; i < seats; i++) {
 		char *name = NULL;
+		int type;
 
 		/* Reset seat */
 		seat.num = i;
@@ -526,3 +581,35 @@
 
 	return 0;
 }
+
+static int _io_read_msg_game_state_changed(GGZdMod *ggzdmod)
+{
+	char state;
+
+	if (ggz_read_char(ggzdmod->fd, &state) < 0)
+		return -1;
+        
+	_ggzdmod_handle_state_changed(ggzdmod, state);
+	return 0;
+}
+
+int _io_send_savedgame(int fd, const char *savedgame)
+{
+	if (ggz_write_int(fd, MSG_SAVEDGAMES) < 0
+	    || (!savedgame
+	    || (savedgame && ggz_write_string(fd, savedgame) < 0)))
+		return -1;
+	return 0;
+}
+
+static int _io_read_msg_savedgames(GGZdMod *ggzdmod)
+{
+	char *savedgame;
+
+	if (ggz_read_string_alloc(ggzdmod->fd, &savedgame) < 0)
+		return -1;
+    
+	_ggzdmod_handle_savedgame(ggzdmod, savedgame);
+	ggz_free(savedgame);
+	return 0;
+}
Index: ggzdmod/ggzdmod.c
===================================================================
--- ggzdmod/ggzdmod.c	(Revision 9802)
+++ ggzdmod/ggzdmod.c	(Arbeitskopie)
@@ -845,7 +845,14 @@
 	return 0;
 }
 
+int ggzdmod_send_savedgame(GGZdMod *ggzdmod, const char *savedgame)
+{
+	if (!CHECK_GGZDMOD(ggzdmod) || ggzdmod->type != GGZDMOD_GGZ)
+		return -1;
+	return _io_send_savedgame(ggzdmod->fd, savedgame);            
+}
 
+
 /* This information could be tracked every time  a player
    leaves/joins, but that's not really necessary at this point. */
 /* Note also that this function doesn't directly access any
@@ -919,16 +926,22 @@
 	/* The callback function retrieves the state from ggzdmod_get_state.
 	   It could instead be passed as an argument. */
 	ggzdmod->state = state;
+
 	call_handler(ggzdmod, GGZDMOD_EVENT_STATE, &old_state);
 
-	/* If we are the game module, send the new state to GGZ */
 	if (ggzdmod->type == GGZDMOD_GAME) {
+
+		/* If we are the game module, send the new state to GGZ */
 		ggzdmod_log(ggzdmod, "GGZDMOD: Game setting state to %d", 
 			    state);
 		if (_io_send_state(ggzdmod->fd, state) < 0)
+			return;
+		/* FIXME: do some sort of error handling? */
+	} else {
+		if (_io_send_state_changed(ggzdmod->fd, state) < 0)
+			return;
 			/* FIXME: do some sort of error handling? */
-			return;
-	}
+    }
 }
 
 /* Returns -1 on error, the number of events handled on success. */
@@ -1106,10 +1119,10 @@
 		else
 			return -1;
 	} else {
-		/* TODO: an extension to the communications protocol will be
-		   needed for this to work ggz-side.  Let's get the rest
-		   of it working first... */
-		return -1;
+		if (state == GGZDMOD_STATE_RESTORED)
+			set_state(ggzdmod, state);
+		else
+			return -1;
 	}
 	return 0;
 }
@@ -1411,6 +1424,7 @@
 		/* Is this right? has the gameover happened yet? */   
 		return;
 	case GGZDMOD_STATE_CREATED:
+	case GGZDMOD_STATE_RESTORED:
 		break;
 	}
 
@@ -1828,7 +1842,14 @@
 	}
 }
 
+void ggzdmod_request_savedgames(GGZdMod *ggzdmod)
+{
+	if (ggzdmod && ggzdmod->type == GGZDMOD_GAME) {
+		_io_send_savedgames_request(ggzdmod->fd);
+	}
+}
 
+
 void ggzdmod_request_num_seats(GGZdMod * ggzdmod, int num_seats)
 {
 	_io_send_req_num_seats(ggzdmod->fd, num_seats);
@@ -1852,7 +1873,12 @@
 	_io_send_req_open(ggzdmod->fd, seat_num);
 }
 
+void ggzdmod_request_abandoned(GGZdMod *ggzdmod, int seat_num, const char *name)
+{
+	_io_send_req_abandoned(ggzdmod->fd, seat_num, name);
+}
 
+
 void _ggzdmod_handle_report(GGZdMod * ggzdmod,
 			    int num_players, char **names, GGZSeatType *types,
 			    int *teams, GGZGameResult *results, int *scores)
@@ -1872,7 +1898,12 @@
 	call_handler(ggzdmod, GGZDMOD_EVENT_SAVEGAMEREPORT, savegame);
 }
 
+void _ggzdmod_handle_req_savedgames(GGZdMod *ggzdmod)
+{
+	call_handler(ggzdmod, GGZDMOD_EVENT_SAVEDGAMESREQ, 0);
+}
 
+
 void _ggzdmod_handle_num_seats_request(GGZdMod * ggzdmod, int num_seats)
 {
 	call_handler(ggzdmod, GGZDMOD_EVENT_REQ_NUM_SEATS, &num_seats);
@@ -1895,3 +1926,30 @@
 {
 	call_handler(ggzdmod, GGZDMOD_EVENT_REQ_OPEN, &seat_num);
 }
+
+void _ggzdmod_handle_savedgame(GGZdMod *ggzdmod, const char *savedgame)
+{
+	call_handler(ggzdmod, GGZDMOD_EVENT_SAVEDGAME, (char *)savedgame);
+}
+
+void _ggzdmod_handle_abandoned_request(GGZdMod *ggzdmod, int seat_num,
+				       const char *name)
+{
+	GGZSeat data = {
+		.num = seat_num,
+		.name = name
+	};
+	call_handler(ggzdmod, GGZDMOD_EVENT_REQ_ABANDONED, &data);
+}
+
+void _ggzdmod_handle_state_changed(GGZdMod *ggzdmod, GGZdModState state)
+{
+	ggzdmod->state = state;
+	call_handler(ggzdmod, GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED, &state);
+	_io_send_state_changed_response(ggzdmod->fd);
+}
+
+void _ggzdmod_handle_stage_change_response(GGZdMod *ggzdmod)
+{
+	call_handler(ggzdmod, GGZDMOD_EVENT_GAME_STATE_CHANGED, NULL);
+}
Index: ggzdmod/io.h
===================================================================
--- ggzdmod/io.h	(Revision 9802)
+++ ggzdmod/io.h	(Arbeitskopie)
@@ -34,10 +34,12 @@
 int _io_send_seat_change(int fd, const GGZSeat *seat);
 int _io_send_spectator_change(int fd, const GGZSeat *spectator);
 int _io_send_state(int fd, GGZdModState state);
+int _io_send_state_changed(int fd, GGZdModState state);
 int _io_send_seat(int fd, const GGZSeat *seat);
 int _io_send_reseat(int fd,
 		    int old_seat, int was_spectator,
 		    int new_seat, int is_spectator);
+int _io_send_savedgame(int fd, const char *savedgame);
 
 int _io_send_log(int fd, const char *msg);
 int _io_send_game_report(int fd, int num_players,
@@ -45,10 +47,13 @@
 			 const int *teams, const GGZGameResult *results,
 			 const int *scores);
 int _io_send_savegame_report(int fd, const char *savegame);
+int _io_send_savedgames_request(int fd);
 int _io_send_req_num_seats(int fd, int num_seats);
 int _io_send_req_boot(int fd, const char *name);
 int _io_send_req_bot(int fd, int seat_num);
 int _io_send_req_open(int fd, int seat_num);
+int _io_send_req_abandoned(int fd, int seat_num, const char *name);
+int _io_send_state_changed_response(int fd);
 
 /* Read and dispatch message */
 int _io_read_data(GGZdMod * ggzdmod);
Index: ggzd/control.c
===================================================================
--- ggzd/control.c	(Revision 9802)
+++ ggzd/control.c	(Arbeitskopie)
@@ -590,6 +590,13 @@
 	signal(TABLE_EVENT_SIGNAL, table_handle_event_signal);
 	pthread_key_create(&table_key, NULL);
 
+	/* Restoring saved games for games with flag AutoRestoreGame */
+	int rooms = room_get_count_rooms();
+	while (!term_signal && --rooms)
+		room_restore(rooms);
+
+	// TODO: Need made cleanup and exit if signal arrived
+
 	/* Setup TLS */
 	ggz_tls_init(opt.tls_cert, opt.tls_key, opt.tls_password);
 
Index: ggzd/database/mysql_schema.sql
===================================================================
--- ggzd/database/mysql_schema.sql	(Revision 9802)
+++ ggzd/database/mysql_schema.sql	(Arbeitskopie)
@@ -78,6 +78,17 @@
 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 
 
+CREATE TABLE `savegameplayers` (
+	`id` int(11) NOT NULL auto_increment,
+	`savegame` int(11) NOT NULL default '0',
+	`seat` int(11) NOT NULL default '0',
+	`handle` text NOT NULL,
+	`seattype` text NOT NULL,
+	PRIMARY KEY  (`id`),
+	CONSTRAINT `savegame` FOREIGN KEY (`savegame`) REFERENCES `savegames` (`id`) ON UPDATE CASCADE ON DELETE CASCADE
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
 CREATE TABLE `teammembers` (
 	`id` int(11) NOT NULL auto_increment,
 	`team_id` int(11) NOT NULL default '0',
Index: ggzd/database/ggzdb.h
===================================================================
--- ggzd/database/ggzdb.h	(Revision 9802)
+++ ggzd/database/ggzdb.h	(Arbeitskopie)
@@ -24,6 +24,7 @@
  */
 
 #include <time.h>
+#include <ggz.h>
 
 #include "ggzd.h"
 
@@ -92,7 +93,6 @@
 	GGZDB_ERR_DB		/* Uh oh.  A database error. */
 } GGZDBResult;
 
-
 /* Exported functions */
 GGZReturn ggzdb_init(ggzdbConnection connection, bool standalone);
 void ggzdb_close(void);
@@ -131,5 +131,14 @@
 /* Recalculate statistics for a certain game type */
 GGZDBResult ggzdb_stats_calcrankings(const char *game);
 
+/* Loading saved games. The list must be deallocated afterwards. */
+GGZList *ggzdb_savegames(const char *game, const char *owner);
+
+/* Loading owners of saved games. The list must be deallocated afterwards. */
+GGZList *ggzdb_savegame_owners(const char *game);
+
+/* Report a table seat change to the database */
+GGZDBResult ggzdb_savegameplayer(int savegame, int seat, const char *name, int type);
+
 #endif
 
Index: ggzd/database/ggzdb_pgsql.c
===================================================================
--- ggzd/database/ggzdb_pgsql.c	(Revision 9802)
+++ ggzd/database/ggzdb_pgsql.c	(Arbeitskopie)
@@ -486,7 +486,7 @@
 			strncpy(pe->email, PQgetvalue(res, 0, 2), sizeof(pe->email));
 			pe->last_login = atol(PQgetvalue(res, 0, 3));
 			pe->perms = atol(PQgetvalue(res, 0, 4));
-			pe->confirmed = atol(PQgetvalue(res, 0, 5));
+			pe->confirmed = (!ggz_strcmp(PQgetvalue(res, 0, 5), "t") ? 1 : 0);
 			rc = GGZDB_NO_ERROR;
 		} else	{
 			/* This is supposed to happen when we look up
@@ -643,7 +643,7 @@
 			strncpy(pe->email, PQgetvalue(iterres, 0, 4), sizeof(pe->email));
 			pe->last_login = atol(PQgetvalue(iterres, 0, 5));
 			pe->perms = atol(PQgetvalue(iterres, 0, 6));
-			pe->confirmed = atol(PQgetvalue(iterres, 0, 7));
+			pe->confirmed = (!ggz_strcmp(PQgetvalue(iterres, 0, 7), "t") ? 1 : 0);
 			rc = GGZDB_NO_ERROR;
 		} else {
 			PQclear(iterres);
@@ -680,7 +680,7 @@
 		strncpy(pe->email, PQgetvalue(iterres, itercount, 4), sizeof(pe->email));
 		pe->last_login = atol(PQgetvalue(iterres, itercount, 5));
 		pe->perms = atol(PQgetvalue(iterres, itercount, 6));
-		pe->confirmed = atol(PQgetvalue(iterres, itercount, 7));
+		pe->confirmed = (!ggz_strcmp(PQgetvalue(iterres, 0, 7), "t") ? 1 : 0);
 
 		return GGZDB_NO_ERROR;
 	} else {
@@ -948,7 +948,7 @@
 	owner_quoted = _ggz_sql_escape(owner);
 
 	snprintf(query, sizeof(query),
-		"INSERT INTO savegames"
+		"INSERT INTO savegames "
 		"(date, game, owner, savegame) VALUES "
 		"(%li, '%s', '%s', '%s')",
 		time(NULL), game, owner, savegame);
@@ -1037,3 +1037,131 @@
 	return GGZDB_NO_ERROR;
 }
 
+static void strfree(void *str)
+{
+	ggz_free(str);
+}
+
+GGZList *_ggzdb_savegame_owners(const char *game)
+{
+	PGconn *conn;
+	PGresult *res;
+	GGZList *owners = NULL;
+
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("ggzdb_savegame_owners: couldn't claim connection");
+		return NULL;
+	} else {
+		char query[4096];
+		char *game_quoted;
+		char *owner;
+		int i;
+
+		game_quoted = _ggz_sql_escape(game);
+		snprintf(query, sizeof(query),
+			"SELECT owner FROM savegames WHERE game='%s'",
+			game_quoted);
+		ggz_free(game_quoted);
+
+		res = PQexec(conn, query);
+		if (PQresultStatus(res) != PGRES_TUPLES_OK) {
+			err_msg("couldn't read savegame owners");
+		} else {
+			owners = ggz_list_create(NULL, NULL, (ggzEntryDestroy)strfree, GGZ_LIST_ALLOW_DUPS);
+			for(i = 0; i < PQntuples(res); i++) {
+				owner = ggz_strdup(PQgetvalue(res, i, 0));
+				ggz_list_insert(owners, owner);
+			}
+		}
+	}
+
+	return owners;
+}
+
+GGZList *_ggzdb_savegames(const char *game, const char *owner)
+{
+	PGconn *conn;
+	PGresult *res;
+	GGZList *savegames = NULL;
+	
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("ggzdb_savegames: couldn't claim connection");
+		return NULL;
+	} else {
+		char query[4096];
+		char *game_quoted;
+		char *owner_quoted;
+		char *savegame;
+		int i;
+
+		game_quoted = _ggz_sql_escape(game);
+		owner_quoted = _ggz_sql_escape(owner);
+		snprintf(query, sizeof(query),
+			"SELECT savegame FROM savegames "
+			"WHERE game='%s' AND owner='%s'",
+			game_quoted, owner_quoted);
+		ggz_free(game_quoted);
+		ggz_free(owner_quoted);
+
+		res = PQexec(conn, query);
+		if (PQresultStatus(res) != PGRES_TUPLES_OK) {
+			err_msg("couldn't read savegames");
+		} else {
+			savegames = ggz_list_create(NULL, NULL, (ggzEntryDestroy)strfree, GGZ_LIST_ALLOW_DUPS);
+			for(i = 0; i < PQntuples(res); i++) {
+				savegame = ggz_strdup(PQgetvalue(res, i, 0));
+				ggz_list_insert(savegames, savegame);
+			}
+		}
+	}
+
+	return savegames;
+}
+
+GGZDBResult _ggzdb_savegame_player(int savegame, int seat, const char *name, int type)
+{
+	PGconn *conn;
+	PGresult *res;
+	char query[4096];
+	int rc = GGZDB_ERR_DB;
+	char *name_quoted;
+
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("_ggzdb_savegame_player: couldn't claim connection");
+		return rc;
+	}
+
+	snprintf(query, sizeof(query),
+		"DELETE FROM savegameplayers "
+		"WHERE savegame = %i AND seat = %i",
+		savegame, seat);
+
+	res = PQexec(conn, query);
+
+	name_quoted = _ggz_sql_escape(name);
+
+	snprintf(query, sizeof(query),
+		"INSERT INTO savegameplayers "
+		"(savegame, seat, handle, seattype) VALUES "
+		"(%i, %i, '%s', '%s')",
+		savegame, seat, name_quoted, ggz_seattype_to_string(type));
+
+	if(name_quoted)
+		ggz_free(name_quoted);
+
+	res = PQexec(conn, query);
+
+	if (PQresultStatus(res) != PGRES_COMMAND_OK) {
+		err_msg("couldn't insert savegame player");
+	}
+	else rc = GGZDB_NO_ERROR;
+	PQclear(res);
+
+	releaseconnection(conn);
+
+	return rc;
+}
+
Index: ggzd/database/ggz.sql
===================================================================
--- ggzd/database/ggz.sql	(Revision 9802)
+++ ggzd/database/ggz.sql	(Arbeitskopie)
@@ -57,3 +57,11 @@
 	"savegame" character varying(256)
 );
 
+CREATE TABLE "%PREFIX%savegameplayers" (
+	"id" serial NOT NULL,
+	"savegame" bigint,
+	"seat" bigint,
+	"handle" character varying(256),
+	"seattype" character varying(256)
+);
+
Index: ggzd/database/ggzdb_proto.h
===================================================================
--- ggzd/database/ggzdb_proto.h	(Revision 9802)
+++ ggzd/database/ggzdb_proto.h	(Arbeitskopie)
@@ -135,3 +135,9 @@
 GGZDBResult _ggzdb_stats_calcrankings(const char *game);
 
 unsigned int _ggzdb_player_next_uid(void);
+
+GGZList *_ggzdb_savegames(const char *game, const char *owner);
+GGZList *_ggzdb_savegame_owners(const char *game);
+
+GGZDBResult _ggzdb_savegame_player(int savegame, int seat, const char *name, int type);
+
Index: ggzd/database/ggzdb_functions.h
===================================================================
--- ggzd/database/ggzdb_functions.h	(Revision 9802)
+++ ggzd/database/ggzdb_functions.h	(Arbeitskopie)
@@ -44,3 +44,8 @@
 GGZDBResult (*_ggzdb_stats_toprankings)(const char *game, int number, ggzdbPlayerGameStats **rankings);
 GGZDBResult (*_ggzdb_stats_calcrankings)(const char *game);
 
+GGZList* (*_ggzdb_savegames)(const char *game, const char *owner);
+GGZList* (*_ggzdb_savegame_owners)(const char *game);
+
+GGZDBResult (*_ggzdb_savegame_player)(int savegame, int seat, const char *name, int type);
+
Index: ggzd/database/ggzdb.c
===================================================================
--- ggzd/database/ggzdb.c	(Revision 9802)
+++ ggzd/database/ggzdb.c	(Arbeitskopie)
@@ -140,7 +140,11 @@
 	|| ((_ggzdb_stats_savegame = dlsym(handle, "_ggzdb_stats_savegame")) == NULL)
 	|| ((_ggzdb_stats_match = dlsym(handle, "_ggzdb_stats_match")) == NULL)
 	|| ((_ggzdb_stats_toprankings = dlsym(handle, "_ggzdb_stats_toprankings")) == NULL)
-	|| ((_ggzdb_stats_calcrankings = dlsym(handle, "_ggzdb_stats_calcrankings")) == NULL))
+	|| ((_ggzdb_stats_calcrankings = dlsym(handle, "_ggzdb_stats_calcrankings")) == NULL)
+	|| ((_ggzdb_savegames = dlsym(handle, "_ggzdb_savegames")) == NULL)
+	|| ((_ggzdb_savegame_owners = dlsym(handle, "_ggzdb_savegame_owners")) == NULL)
+	|| ((_ggzdb_savegame_player = dlsym(handle, "_ggzdb_savegame_player")) == NULL)
+	)
 	{
 		err_sys_exit("%s is an invalid database module (%s)",
 			backend, dlerror());
@@ -471,7 +475,60 @@
 	return rc;
 }
 
+GGZList *ggzdb_savegames(const char *game, const char *owner)
+{
+	GGZList *list = NULL;
+	GGZDBResult rc = GGZDB_NO_ERROR;
 
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		list = _ggzdb_savegames(game, owner);
+
+	_ggzdb_exit();
+
+	return list;
+}
+
+GGZList *ggzdb_savegame_owners(const char *game)
+{
+	GGZList *list = NULL;
+	GGZDBResult rc = GGZDB_NO_ERROR;
+
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		list = _ggzdb_savegame_owners(game);
+
+	_ggzdb_exit();
+
+	return list;
+}
+
+GGZDBResult ggzdb_savegameplayer(int savegame, int seat, const char *name, int type)
+{
+	GGZDBResult rc = GGZDB_NO_ERROR;
+
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		rc = _ggzdb_savegame_player(savegame, seat, name, type);
+
+	_ggzdb_exit();
+
+	return rc;
+}
+
+
 /*** INTERNAL FUNCTIONS ***/
 
 /* Function to initialize player tables if necessary */
Index: ggzd/datatypes.h
===================================================================
--- ggzd/datatypes.h	(Revision 9802)
+++ ggzd/datatypes.h	(Arbeitskopie)
@@ -147,6 +147,10 @@
 
 	/* Can players request each other's hostnames? */
 	bool allow_peers;
+
+	/* Games should be automatically restored if they're saved when
+	   server runs */
+	bool restore_allow;
 } GameInfo;
 
 
Index: ggzd/room.c
===================================================================
--- ggzd/room.c	(Revision 9802)
+++ ggzd/room.c	(Arbeitskopie)
@@ -623,3 +623,66 @@
 	return removed;
 }
 
+
+/* This function is used for restore tables in room after crash
+*/
+void room_restore(int room)
+{
+	pthread_rwlock_rdlock(&rooms[room].lock);
+	int game_type = rooms[room].game_type;
+	pthread_rwlock_unlock(&rooms[room].lock);
+    
+	pthread_rwlock_rdlock(&game_types[game_type].lock);
+	int restore_allow = game_types[game_type].restore_allow;
+	pthread_rwlock_unlock(&game_types[game_type].lock);
+    
+	if (restore_allow) {
+		pthread_rwlock_rdlock(&game_types[game_type].lock);
+		char *game_name = ggz_strdup(ggz_intlstring_translated(game_types[game_type].name, NULL));
+		pthread_rwlock_unlock(&game_types[game_type].lock);
+
+		GGZList *owners = ggzdb_savegame_owners(game_name);
+		char *owner;
+		GGZListEntry *entry;
+
+		ggz_free(game_name);
+
+		if (owners != NULL) {
+			dbg_msg(GGZ_DBG_ROOM, "Restore games for room %d...", room);
+
+			for(entry = ggz_list_head(owners); entry; entry = ggz_list_next(entry)) {
+				owner = ggz_list_get_data(entry);
+				GGZTable *table = table_new();
+				table->type = game_type;
+				table->room = room;
+				table->state = GGZDMOD_STATE_RESTORED;
+
+				// Make open all seats. Game using save game
+				// must be not used seats close.
+				pthread_rwlock_rdlock(&game_types[game_type].lock);
+				int seats = ggz_numberlist_get_max(&game_types[game_type].player_allow_list);
+				pthread_rwlock_unlock(&game_types[game_type].lock);
+			
+				dbg_msg(GGZ_DBG_ROOM, "- owner %s with %d seats", owner, seats);
+
+				table->num_seats = seats;
+				if (seats > 0) {
+					table->seat_types = ggz_malloc(seats * sizeof(*table->seat_types));
+					table->seat_names = ggz_malloc(seats * sizeof(*table->seat_names));
+					int i;
+					for(i = 0; i < seats; ++i) {
+						table->seat_types[i] = GGZ_SEAT_OPEN;
+						table->seat_names[i][0] = '\0';
+					}
+				}
+
+				if (table_launch(table, owner) != E_OK)
+					ggz_free(table);
+			}
+			ggz_list_free(owners);
+		}
+	}
+
+	return;
+}
+
Index: ggzd/room.h
===================================================================
--- ggzd/room.h	(Revision 9802)
+++ ggzd/room.h	(Arbeitskopie)
@@ -123,6 +123,7 @@
 int room_get_count_rooms(void);
 int room_is_removed(int room);
 int room_will_be_removed(int room);
+void room_restore(int room);
 
 GGZReturn room_update_event(const char *player,
 			    GGZPlayerUpdateType update,
Index: ggzd/table.c
===================================================================
--- ggzd/table.c	(Revision 9802)
+++ ggzd/table.c	(Arbeitskopie)
@@ -86,6 +86,8 @@
 			      const void *data);
 static void table_game_savegame(GGZdMod *ggzdmod, GGZdModEvent event,
 			      const void *data);
+static void table_game_savedgamesreq(GGZdMod *ggzdmod, GGZdModEvent event,
+				     const void *data);
 static void table_game_req_num_seats(GGZdMod *ggzdmod, GGZdModEvent event,
 				     const void *data);
 static void table_game_req_boot(GGZdMod *ggzdmod, GGZdModEvent event,
@@ -94,6 +96,10 @@
 			       const void *data);
 static void table_game_req_open(GGZdMod *ggzdmod, GGZdModEvent event,
 				const void *data);
+static void table_game_req_abandoned(GGZdMod *ggzdmod, GGZdModEvent event,
+				     const void *data);
+static void table_game_state_changed(GGZdMod *mod, GGZdModEvent event,
+			       const void *data);
 static void table_error(GGZdMod *ggzdmod, GGZdModEvent event,
 			const void *data);
 
@@ -112,7 +118,7 @@
 static GGZReturn table_launch_event(char* name,
 				    GGZClientReqError status, int index);
 
-static int   type_match_table(int type, GGZTable* table);
+static int type_match_table(int type, GGZTable* table);
 
 
 
@@ -453,6 +459,8 @@
 			    &table_game_report);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_SAVEGAMEREPORT,
 			    &table_game_savegame);
+	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_SAVEDGAMESREQ,
+			    &table_game_savedgamesreq);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_REQ_NUM_SEATS,
 			    &table_game_req_num_seats);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_REQ_BOOT,
@@ -461,8 +469,12 @@
 			    &table_game_req_bot);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_REQ_OPEN,
 			    &table_game_req_open);
+	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_REQ_ABANDONED,
+			    &table_game_req_abandoned);
+	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_GAME_STATE_CHANGED,
+			    &table_game_state_changed);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_ERROR, &table_error);
-	
+
 	/* Setup seats for game table */
 	num_seats = seats_num(table);
 	ggzdmod_set_num_seats(table->ggzdmod, num_seats);
@@ -479,6 +491,8 @@
 		seat.fd = -1;
 		if (ggzdmod_set_seat(table->ggzdmod, &seat) < 0)
 			status = GGZ_ERROR;
+
+		ggzdb_savegameplayer(pthread_self(), i, seat.name, seat.type);
 	}
 
 	/* And start the game */
@@ -487,6 +501,12 @@
 	if (ggzdmod_connect(table->ggzdmod) < 0)
 		status = GGZ_ERROR;
 
+	if (table->state == GGZDMOD_STATE_RESTORED) {
+		log_msg(GGZ_LOG_TABLES,"Server change game state to %d",
+			table->state);
+		ggzdmod_set_state(table->ggzdmod, table->state);
+	}
+
 	return status;
 }
 
@@ -831,6 +851,12 @@
 }
 
 
+static void table_game_state_changed(GGZdMod *mod, GGZdModEvent event,
+				    const void *data)
+{
+	/* FIXME: what to do here? */
+}
+
 static void table_handle_state(GGZdMod *mod, GGZdModEvent event,
 			       const void *data)
 {
@@ -887,6 +913,15 @@
 			table_event_enqueue(table, GGZ_TABLE_UPDATE_STATE);
 		return;
 
+	case GGZDMOD_STATE_RESTORED:
+		dbg_msg(GGZ_DBG_TABLE,
+			"Table %d in room %d is restored.", 
+			table->index, table->room);
+
+		pthread_rwlock_wrlock(&table->lock);
+		table->state = GGZ_TABLE_RESTORED;
+		pthread_rwlock_unlock(&table->lock);
+		return;
 	case GGZDMOD_STATE_CREATED:
 		break;
 	}
@@ -935,7 +970,6 @@
 	/* FIXME: we might want to auto-send the updated rankings here? */
 }
 
-
 static void table_game_savegame(GGZdMod *ggzdmod,
 			      GGZdModEvent event, const void *data)
 {
@@ -948,7 +982,38 @@
 	report_savegame(table->type, table->owner, table->savegame);
 }
 
+static void table_game_savedgamesreq(GGZdMod *ggzdmod, GGZdModEvent event,
+				     const void *data)
+{
+	GGZTable *table = ggzdmod_get_gamedata(ggzdmod);
 
+	pthread_rwlock_rdlock(&table->lock);
+	int room = table->room;
+	char *owner = ggz_strdup(table->owner);
+	pthread_rwlock_unlock(&table->lock);
+
+	pthread_rwlock_rdlock(&rooms[room].lock);
+	char *roomname = ggz_strdup(ggz_intlstring_translated(rooms[room].name, NULL));
+	pthread_rwlock_unlock(&rooms[room].lock);
+
+	dbg_msg(GGZ_DBG_ROOM, "Send savegames for room %s, owner %s...", roomname, owner);
+
+	GGZList *savegames = ggzdb_savegames(roomname, owner);
+	ggz_free(owner);
+	ggz_free(roomname);
+
+	char *savegame;
+	GGZListEntry *entry;
+	for(entry = ggz_list_head(savegames); entry; entry = ggz_list_next(entry)) {
+		savegame = ggz_list_get_data(entry);
+		dbg_msg(GGZ_DBG_ROOM, "- savegames %s", savegame);
+
+		ggzdmod_send_savedgame(table->ggzdmod, savegame);
+	}
+
+	ggz_list_free(savegames);
+}
+
 /* Must be called with a write-lock on the table. */
 static void table_change_num_seats(GGZTable *table, int num_seats)
 {
@@ -1084,6 +1149,8 @@
 		ggzdmod_set_seat(ggzdmod, &seat);
 		transit = GGZ_TRANSIT_LEAVE;
 		update = GGZ_TABLE_UPDATE_LEAVE;
+
+		ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
 	}
 
 	pthread_rwlock_wrlock(&table->lock);
@@ -1135,6 +1202,8 @@
 	seat.playerdata = NULL;
 	ggzdmod_set_seat(ggzdmod, &seat);
 
+	ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
+
 	pthread_rwlock_wrlock(&table->lock);
 	table->seat_types[seat_num] = GGZ_SEAT_BOT;
 	pthread_rwlock_unlock(&table->lock);
@@ -1147,12 +1216,11 @@
 }
 
 
-static void table_game_req_open(GGZdMod *ggzdmod,
-				GGZdModEvent event, const void *data)
+static void _table_game_change_seat(GGZdMod *ggzdmod,
+				    GGZdModEvent event, int seat_num, GGZSeatType seat_type,
+				    const char *name)
 {
 	GGZTable *table = ggzdmod_get_gamedata(ggzdmod);
-	const int *seat_num_ptr = data;
-	const int seat_num = *seat_num_ptr;
 	GGZSeat seat;
 
 	/* FIXME: this code overlaps with the leaving code in transit.c */
@@ -1170,13 +1238,15 @@
 
 	seat.num = seat_num;
 	seat.type = GGZ_SEAT_OPEN;
-	seat.name = NULL;
+	seat.name = name;
 	seat.fd = -1;
 	seat.playerdata = NULL;
 	ggzdmod_set_seat(ggzdmod, &seat);
 
+	ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
+
 	pthread_rwlock_wrlock(&table->lock);
-	table->seat_types[seat_num] = GGZ_SEAT_OPEN;
+	table->seat_types[seat_num] = seat_type;
 	table->seat_names[seat_num][0] = '\0';
 	pthread_rwlock_unlock(&table->lock);
 
@@ -1187,7 +1257,25 @@
 				   "", seat_num);
 }
 
+static void table_game_req_open(GGZdMod *ggzdmod,
+				GGZdModEvent event, const void *data)
+{
+	const int *seat_num_ptr = data;
+	const int seat_num = *seat_num_ptr;
 
+	_table_game_change_seat(ggzdmod, event, seat_num, GGZ_SEAT_OPEN, NULL);
+}
+
+static void table_game_req_abandoned(GGZdMod *ggzdmod, GGZdModEvent event,
+				     const void *data)
+{
+	const GGZSeat *seat = data;
+
+	_table_game_change_seat(ggzdmod, event, seat->num, 
+		GGZ_SEAT_ABANDONED, seat->name);
+}
+
+
 static void table_error(GGZdMod *ggzdmod,
 			GGZdModEvent event, const void *data)
 {
Index: ggzd/parse_opt.c
===================================================================
--- ggzd/parse_opt.c	(Revision 9802)
+++ ggzd/parse_opt.c	(Arbeitskopie)
@@ -698,6 +698,9 @@
 	game_info.allow_peers = ggz_conf_read_int(ch, "TableOptions", 
 						  "AllowPeers", 0);
 
+	game_info.restore_allow = ggz_conf_read_int(ch, "TableOptions",
+						    "AllowRestore", 0);
+
 	/* Named bots */
 	game_info.named_bots = NULL;
 
