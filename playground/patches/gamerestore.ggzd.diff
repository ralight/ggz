Index: ggzdmod++/ggzgameserver.cpp
===================================================================
--- ggzdmod++/ggzgameserver.cpp	(Revision 9802)
+++ ggzdmod++/ggzgameserver.cpp	(Arbeitskopie)
@@ -59,6 +59,10 @@
 				GGZdModEvent event, const void *data);
 			static void handle_spectator_seat(GGZdMod* ggzdmod,
 				GGZdModEvent event, const void *data);
+			static void handle_savedgame(GGZdMod* ggzdmod,
+				GGZdModEvent, const void *data);
+			static void handle_state_changed(GGZdMod *ggzdmod,
+				GGZdModEvent, const void *data);
 			void selfcheck();
 			// Parent object (which is a singleton in 'self')
 			static GGZGameServer *m_parent;
@@ -240,6 +244,16 @@
 	ggzdmod_set_state(m_private->ggzdmod(), (GGZdModState)state);
 }
 
+void GGZGameServer::requestSavedGames()
+{
+	ggzdmod_request_savedgames(m_private->ggzdmod());
+}
+
+void GGZGameServer::reportSave(const char *savedGame)
+{
+	ggzdmod_report_savegame(m_private->ggzdmod(), savedGame);
+}
+
 // Implementation of the internal class
 GGZGameServerPrivate::GGZGameServerPrivate(GGZGameServer *parent)
 {
@@ -259,6 +273,8 @@
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_LEAVE, &handle_spectator_leave);
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_DATA, &handle_spectator_data);
 	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SPECTATOR_SEAT, &handle_spectator_seat);
+	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_SAVEDGAME, &handle_savedgame);
+	ggzdmod_set_handler(m_ggzdmod, GGZDMOD_EVENT_MSG_GAME_STATE_CHANGED, &handle_state_changed);
 
 	selfcheck();
 }
@@ -282,6 +298,7 @@
 	if((int)Seat::abandoned != (int)GGZ_SEAT_ABANDONED) error = true;
 
 	if((int)GGZGameServer::created != (int)GGZDMOD_STATE_CREATED) error = true;
+	if((int)GGZGameServer::restored != (int)GGZDMOD_STATE_RESTORED) error = true;
 	if((int)GGZGameServer::waiting != (int)GGZDMOD_STATE_WAITING) error = true;
 	if((int)GGZGameServer::playing != (int)GGZDMOD_STATE_PLAYING) error = true;
 	if((int)GGZGameServer::done != (int)GGZDMOD_STATE_DONE) error = true;
@@ -378,3 +395,16 @@
 	m_parent->spectatorEvent(spectator);
 }
 
+void GGZGameServerPrivate::handle_savedgame(GGZdMod *ggzdmod, GGZdModEvent event, const void *data)
+{
+	std::cout << "GGZGameServer: savedgame event." << std::endl;
+	SavedGame savedGame(static_cast<const char *>(data));
+	m_parent->savedgameEvent(&savedGame);
+}
+
+void GGZGameServerPrivate::handle_state_changed(GGZdMod *ggzdmod, GGZdModEvent, const void *data)
+{
+	std::cout << "GGZGameServer: state changed to: ";
+	std::cout << (int)m_parent->state() << std::endl;
+	m_parent->stateEvent();
+}
Index: ggzdmod++/ggzgameserver.h
===================================================================
--- ggzdmod++/ggzgameserver.h	(Revision 9802)
+++ ggzdmod++/ggzgameserver.h	(Arbeitskopie)
@@ -65,6 +65,16 @@
 		SeatType type;
 };
 
+class SavedGame
+{
+	public:
+		SavedGame(const char *_savedgame) : savedgame(_savedgame) {}
+		const std::string& getName() const { return savedgame; };
+
+	private:
+		const std::string savedgame;
+};
+
 /* Class representing a game server module.
  * It is used by reimplementing the virtual methods, and then calling
  * connect().
@@ -91,7 +101,8 @@
 			created,
 			waiting,
 			playing,
-			done
+			done,
+			restored
 		};
 
 		/* Callback for idle events (only in async mode) */
@@ -113,6 +124,9 @@
 		/* A spectator seat change happened */
 		virtual void spectatorEvent(Spectator *spectator);
 
+		/* Got saved game name. This event occurred for each saved game name */
+		virtual void savedgameEvent(SavedGame *savedGames) {};
+
 		/* Current game state */
 		State state();
 		/* Announce a state transition */
@@ -148,6 +162,9 @@
 			return s->client->fd;
 		}
 
+		void requestSavedGames();
+		void reportSave(const char *);
+
 	private:
 		GGZGameServerPrivate *m_private;
 		int m_connected;
Index: game_servers/tictactoe/tictactoe.dsc
===================================================================
--- game_servers/tictactoe/tictactoe.dsc	(Revision 9802)
+++ game_servers/tictactoe/tictactoe.dsc	(Arbeitskopie)
@@ -22,6 +22,7 @@
 BotsAllowed = 1
 PlayersAllowed = 2
 AllowSpectators = 1
+AllowRestore = 1
 
 [Statistics]
 Records = 1
Index: game_servers/tictactoe/Makefile.am
===================================================================
--- game_servers/tictactoe/Makefile.am	(Revision 9802)
+++ game_servers/tictactoe/Makefile.am	(Arbeitskopie)
@@ -13,7 +13,8 @@
 	ttt-ai.c \
 	ttt-ai.h
 
-AM_CPPFLAGS = -I$(top_srcdir)/ggzdmod $(LIBGGZ_INCLUDES)
+AM_CPPFLAGS = -I$(top_srcdir)/ggzdmod $(LIBGGZ_INCLUDES) \
+	-DGGZDSTATEDIR=\"$(ggzdstatedir)\"
 ggzd_tictactoe_LDADD = $(LDADD) $(top_builddir)/ggzdmod/libggzdmod.la
 
 PROTOCOL = tictactoe
Index: game_servers/tictactoe/game.c
===================================================================
--- game_servers/tictactoe/game.c	(Revision 9802)
+++ game_servers/tictactoe/game.c	(Arbeitskopie)
@@ -60,6 +60,8 @@
 #define GGZBOTHASNAME /* do not undefine */
 /* The game supports to play one more time; FIXME: not used yet */
 #define GGZAGAINQUERY /* do not undefine */
+/* The game can be restored from a savegame */
+#define GGZRESTORGAME /* do not undefine */
 
 /* TTT artificial intelligence */
 #ifdef GGZBOTPLAYERS
@@ -116,6 +118,10 @@
 #endif
 static void game_handle_ggz_player(GGZdMod *ggz,
                                    GGZdModEvent event, const void *data);
+#ifdef GGZRESTORGAME
+static void game_handle_savedgame(GGZdMod *ggz,
+                                  GGZdModEvent event, const void *data);
+#endif
 
 /* Network IO main functions */
 static void game_network_data(int opcode);
@@ -176,6 +182,10 @@
 	ggzdmod_set_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_SEAT,
 	                    &game_handle_ggz_spectator_seat);
 #endif
+#ifdef GGZRESTORGAME
+	ggzdmod_set_handler(ggzdmod, GGZDMOD_EVENT_SAVEDGAME,
+	                    &game_handle_savedgame);
+#endif
 
 	/* Setup the network callbacks for GGZComm */
 	ggzcomm_set_notifier_callback(game_network_data);
@@ -183,6 +193,21 @@
 }
 
 
+#ifdef GGZRESTORGAME
+/* Callback for GGZDMOD_EVENT_SAVEDGAME */
+static void game_handle_savedgame(GGZdMod *ggz, GGZdModEvent event,
+				  const void *data)
+{
+	const char *savegame = data;
+	char *savegamepath;
+
+	savegamepath = ggz_strbuild(GGZDSTATEDIR "/gamedata/TicTacToe/%s", savegame);
+	ttt_game.savegame = fopen(savegamepath, "a");
+	ggz_free(savegamepath);
+}
+#endif
+
+
 /* Callback for GGZDMOD_EVENT_STATE */
 static void game_handle_ggz_state(GGZdMod *ggz, GGZdModEvent event,
 				  const void *data)
@@ -220,6 +245,10 @@
 	case GGZDMOD_STATE_DONE:
 		/* The game is over and will be destroyed */
 		break;
+	case GGZDMOD_STATE_RESTORED:
+		/* The game is being restored. */
+		/* FIXME: we need to read in a savegame here. */
+		break;
 	}
 }
 
@@ -714,7 +743,7 @@
 	va_list ap;
 
 	if(!ttt_game.savegame) {
-		savegamepath = strdup(GGZDDATADIR "/gamedata/TicTacToe/" TEMPLATE);
+		savegamepath = strdup(GGZDSTATEDIR "/gamedata/TicTacToe/" TEMPLATE);
 		fd = mkstemp(savegamepath);
 		savegamename = strdup(savegamepath + strlen(savegamepath) - strlen(TEMPLATE));
 		free(savegamepath);
Index: ggzdmod/ggzdmod.h
===================================================================
--- ggzdmod/ggzdmod.h	(Revision 9802)
+++ ggzdmod/ggzdmod.h	(Arbeitskopie)
@@ -216,7 +216,9 @@
 	GGZDMOD_STATE_CREATED,	/**< Pre-launch; waiting for ggzdmod */
 	GGZDMOD_STATE_WAITING,	/**< Ready and waiting to play. */
 	GGZDMOD_STATE_PLAYING,	/**< Currently playing a game. */
-	GGZDMOD_STATE_DONE	/**< Table halted, prepping to exit. */
+	GGZDMOD_STATE_DONE,	/**< Table halted, prepping to exit. */
+	GGZDMOD_STATE_RESTORED  /**< Pre-launch if server restore all saved games
+	                             ; waiting for ggzdmod */
 } GGZdModState;
 
 /** @brief Callback events.
@@ -318,6 +320,11 @@
 	 */
 	GGZDMOD_EVENT_SPECTATOR_DATA,
 
+	/** @brief Data about saved games avaiable from ggzd
+         *  This message is answer to saved games request.
+	 */
+	GGZDMOD_EVENT_SAVEDGAME,
+
 	/** @brief An error has occurred
 	 *  This event occurs when a GGZdMod error has occurred.  An
 	 *  error message (a const char*) will be passed as the event's data.
@@ -700,6 +707,8 @@
  */
 void ggzdmod_report_savegame(GGZdMod *ggzdmod, const char *savegame);
 
+void ggzdmod_request_savedgames(GGZdMod *ggzdmod);
+
 /** @brief Tell GGZ to change the number of seats at this table.
  *  @note This functionality is incomplete, and should not yet be used. */
 void ggzdmod_request_num_seats(GGZdMod * ggzdmod, int num_seats);
Index: ggzdmod/mod.h
===================================================================
--- ggzdmod/mod.h	(Revision 9802)
+++ ggzdmod/mod.h	(Arbeitskopie)
@@ -82,5 +82,6 @@
 			    int new_seat, int is_spectator);
 void _ggzdmod_handle_spectator_seat(GGZdMod * ggzdmod, GGZSeat *seat);
 void _ggzdmod_handle_state_response(GGZdMod * ggzdmod);
+void _ggzdmod_handle_savedgame(GGZdMod *ggzdmod, const char *savedgame);
 
 #endif /* GGZDMOD_MOD_H */
Index: ggzdmod/ggzdmod-ggz.h
===================================================================
--- ggzdmod/ggzdmod-ggz.h	(Revision 9802)
+++ ggzdmod/ggzdmod-ggz.h	(Arbeitskopie)
@@ -103,6 +103,10 @@
 	int *scores;
 } GGZdModGameReportData;
 
+/** @brief Send saved game to game module
+ */
+int ggzdmod_send_savedgame(GGZdMod *ggzdmod, const char *savedgame);
+
 /** @brief Callback events (GGZ-side additions).
  *
  *  These events are triggered by the game server and delivered
Index: ggzdmod/protocol.h
===================================================================
--- ggzdmod/protocol.h	(Revision 9802)
+++ ggzdmod/protocol.h	(Arbeitskopie)
@@ -99,7 +99,7 @@
 	 * - an integer containing MSG_SAVEGAME_REPORT
 	 * - an easysock-formatted string containing the path of the file
 	 */
-	MSG_SAVEGAME_REPORT
+	MSG_SAVEGAME_REPORT,
 } TableToControl;
 
 /** Messages sent from the ggz server to the game server. */
@@ -174,6 +174,14 @@
 	 *  only effect is to let the table know the information has
 	 */
 	RSP_GAME_STATE,
+
+	/** @brief Signals the start of a MSG_SAVEDGAMES packet.
+	 *
+	 *  The packed is composed of:
+	 *    - An integer containing the saved games names count.
+	 *    - An easysock-formated strings for each saved game.
+	 */
+	MSG_SAVEDGAMES
 } ControlToTable;
 
 #endif /* GGZDMOD_SERVER_PROTOCOL_H */
Index: ggzdmod/io.c
===================================================================
--- ggzdmod/io.c	(Revision 9802)
+++ ggzdmod/io.c	(Arbeitskopie)
@@ -48,8 +48,8 @@
 static int _io_read_msg_seat_change(GGZdMod * ggzdmod);
 static int _io_read_msg_reseat(GGZdMod * ggzdmod);
 static int _io_read_msg_spectator_seat_change(GGZdMod *ggzdmod);
+static int _io_read_msg_savedgames(GGZdMod *ggzdmod);
 
-
 /* Functions for sending IO messages */
 int _io_send_launch(int fd, const char *name, int seats, int spectators)
 {
@@ -221,7 +221,6 @@
 	return 0;
 }
 
-
 int _io_respond_state(int fd)
 {
 	return ggz_write_int(fd, RSP_GAME_STATE);
@@ -249,6 +248,8 @@
 		case RSP_GAME_STATE:
 			_ggzdmod_handle_state_response(ggzdmod);
 			return 0;
+		case MSG_SAVEDGAMES:
+			return _io_read_msg_savedgames(ggzdmod);
 		}
 	} else {
 		switch ((TableToControl)op) {
@@ -401,13 +402,13 @@
 static int _io_read_req_open(GGZdMod *ggzdmod)
 {
 	int seat_num;
+
 	if (ggz_read_int(ggzdmod->fd, &seat_num) < 0)
 		return -1;
 	_ggzdmod_handle_open_request(ggzdmod, seat_num);
 	return 0;
 }
 
-
 static int _io_read_req_launch(GGZdMod * ggzdmod)
 {
 	int seats, spectators, i;
@@ -526,3 +527,24 @@
 
 	return 0;
 }
+
+int _io_send_savedgame(int fd, const char *savedgame)
+{
+	if (ggz_write_int(fd, MSG_SAVEDGAMES) < 0
+	    || (!savedgame
+	    || (savedgame && ggz_write_string(fd, savedgame) < 0)))
+		return -1;
+	return 0;
+}
+
+static int _io_read_msg_savedgames(GGZdMod *ggzdmod)
+{
+	char *savedgame;
+
+	if (ggz_read_string_alloc(ggzdmod->fd, &savedgame) < 0)
+		return -1;
+    
+	_ggzdmod_handle_savedgame(ggzdmod, savedgame);
+	ggz_free(savedgame);
+	return 0;
+}
Index: ggzdmod/ggzdmod.c
===================================================================
--- ggzdmod/ggzdmod.c	(Revision 9802)
+++ ggzdmod/ggzdmod.c	(Arbeitskopie)
@@ -845,7 +845,14 @@
 	return 0;
 }
 
+int ggzdmod_send_savedgame(GGZdMod *ggzdmod, const char *savedgame)
+{
+	if (!CHECK_GGZDMOD(ggzdmod) || ggzdmod->type != GGZDMOD_GGZ)
+		return -1;
+	return _io_send_savedgame(ggzdmod->fd, savedgame);            
+}
 
+
 /* This information could be tracked every time  a player
    leaves/joins, but that's not really necessary at this point. */
 /* Note also that this function doesn't directly access any
@@ -919,6 +926,7 @@
 	/* The callback function retrieves the state from ggzdmod_get_state.
 	   It could instead be passed as an argument. */
 	ggzdmod->state = state;
+
 	call_handler(ggzdmod, GGZDMOD_EVENT_STATE, &old_state);
 
 	/* If we are the game module, send the new state to GGZ */
@@ -926,8 +934,8 @@
 		ggzdmod_log(ggzdmod, "GGZDMOD: Game setting state to %d", 
 			    state);
 		if (_io_send_state(ggzdmod->fd, state) < 0)
-			/* FIXME: do some sort of error handling? */
 			return;
+		/* FIXME: do some sort of error handling? */
 	}
 }
 
@@ -1106,10 +1114,10 @@
 		else
 			return -1;
 	} else {
-		/* TODO: an extension to the communications protocol will be
-		   needed for this to work ggz-side.  Let's get the rest
-		   of it working first... */
-		return -1;
+		if (state == GGZDMOD_STATE_RESTORED)
+			set_state(ggzdmod, state);
+		else
+			return -1;
 	}
 	return 0;
 }
@@ -1411,6 +1419,7 @@
 		/* Is this right? has the gameover happened yet? */   
 		return;
 	case GGZDMOD_STATE_CREATED:
+	case GGZDMOD_STATE_RESTORED:
 		break;
 	}
 
@@ -1895,3 +1904,8 @@
 {
 	call_handler(ggzdmod, GGZDMOD_EVENT_REQ_OPEN, &seat_num);
 }
+
+void _ggzdmod_handle_savedgame(GGZdMod *ggzdmod, const char *savedgame)
+{
+	call_handler(ggzdmod, GGZDMOD_EVENT_SAVEDGAME, (char *)savedgame);
+}
Index: ggzdmod/io.h
===================================================================
--- ggzdmod/io.h	(Revision 9802)
+++ ggzdmod/io.h	(Arbeitskopie)
@@ -38,6 +38,7 @@
 int _io_send_reseat(int fd,
 		    int old_seat, int was_spectator,
 		    int new_seat, int is_spectator);
+int _io_send_savedgame(int fd, const char *savedgame);
 
 int _io_send_log(int fd, const char *msg);
 int _io_send_game_report(int fd, int num_players,
Index: ggzd/stats.c
===================================================================
--- ggzd/stats.c	(Revision 9802)
+++ ggzd/stats.c	(Arbeitskopie)
@@ -409,7 +409,7 @@
 		sizeof(game_name));
 	pthread_rwlock_unlock(&game_types[gametype].lock);
 
-	ggzdb_stats_savegame(game_name, owner, savegame);
+	ggzdb_stats_savegame(game_name, owner, savegame, pthread_self());
 }
 
 /* This function allocates a list which must be ggz_list_free()d. */
Index: ggzd/control.c
===================================================================
--- ggzd/control.c	(Revision 9802)
+++ ggzd/control.c	(Arbeitskopie)
@@ -590,6 +590,13 @@
 	signal(TABLE_EVENT_SIGNAL, table_handle_event_signal);
 	pthread_key_create(&table_key, NULL);
 
+	/* Restoring saved games for games with flag AutoRestoreGame */
+	int rooms = room_get_count_rooms();
+	while (!term_signal && --rooms)
+		room_restore(rooms);
+
+	// TODO: Need made cleanup and exit if signal arrived
+
 	/* Setup TLS */
 	ggz_tls_init(opt.tls_cert, opt.tls_key, opt.tls_password);
 
Index: ggzd/database/mysql_schema.sql
===================================================================
--- ggzd/database/mysql_schema.sql	(Revision 9802)
+++ ggzd/database/mysql_schema.sql	(Arbeitskopie)
@@ -74,10 +74,22 @@
 	`game` text NOT NULL,
 	`owner` text NOT NULL,
 	`savegame` text NOT NULL,
+	`tableid` int(11) NOT NULL default '0',
 	PRIMARY KEY  (`id`)
 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 
 
+CREATE TABLE `savegameplayers` (
+	`id` int(11) NOT NULL auto_increment,
+	`savegame` int(11) NOT NULL default '0',
+	`seat` int(11) NOT NULL default '0',
+	`handle` text NOT NULL,
+	`seattype` text NOT NULL,
+	PRIMARY KEY  (`id`),
+	--CONSTRAINT `savegame` FOREIGN KEY (`savegame`) REFERENCES `savegames` (`tableid`) ON UPDATE CASCADE ON DELETE CASCADE
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
 CREATE TABLE `teammembers` (
 	`id` int(11) NOT NULL auto_increment,
 	`team_id` int(11) NOT NULL default '0',
Index: ggzd/database/ggzdb.h
===================================================================
--- ggzd/database/ggzdb.h	(Revision 9802)
+++ ggzd/database/ggzdb.h	(Arbeitskopie)
@@ -24,6 +24,8 @@
  */
 
 #include <time.h>
+#include <ggz.h>
+#include <ggz_common.h>
 
 #include "ggzd.h"
 
@@ -83,6 +85,14 @@
 	long highest_score;
 } ggzdbPlayerGameStats;
 
+typedef struct {
+	char *owner;
+	char *savegame;
+	int count;
+	GGZSeatType *types;
+	char **names;
+} ggzdbSavegamePlayers;
+
 /* Error codes */
 typedef enum {
 	GGZDB_NO_ERROR,		/* All's well */
@@ -92,7 +102,6 @@
 	GGZDB_ERR_DB		/* Uh oh.  A database error. */
 } GGZDBResult;
 
-
 /* Exported functions */
 GGZReturn ggzdb_init(ggzdbConnection connection, bool standalone);
 void ggzdb_close(void);
@@ -123,7 +132,7 @@
 GGZDBResult ggzdb_stats_newmatch(const char *game, const char *winner, const char *savegame);
 
 /* Register a savegame entry temporarily */
-GGZDBResult ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame);
+GGZDBResult ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid);
 
 /* Report the top-N players for a certain game type */
 GGZDBResult ggzdb_stats_toprankings(const char *game, int number, ggzdbPlayerGameStats **rankings);
@@ -131,5 +140,14 @@
 /* Recalculate statistics for a certain game type */
 GGZDBResult ggzdb_stats_calcrankings(const char *game);
 
+/* Loading saved games. The list must be deallocated afterwards. */
+GGZList *ggzdb_savegames(const char *game, const char *owner);
+
+/* Loading owners of saved games. The list must be deallocated afterwards. */
+GGZList *ggzdb_savegame_owners(const char *game);
+
+/* Report a table seat change to the database */
+GGZDBResult ggzdb_savegameplayer(int savegame, int seat, const char *name, int type);
+
 #endif
 
Index: ggzd/database/ggzdb_pgsql.c
===================================================================
--- ggzd/database/ggzdb_pgsql.c	(Revision 9802)
+++ ggzd/database/ggzdb_pgsql.c	(Arbeitskopie)
@@ -486,7 +486,7 @@
 			strncpy(pe->email, PQgetvalue(res, 0, 2), sizeof(pe->email));
 			pe->last_login = atol(PQgetvalue(res, 0, 3));
 			pe->perms = atol(PQgetvalue(res, 0, 4));
-			pe->confirmed = atol(PQgetvalue(res, 0, 5));
+			pe->confirmed = (!ggz_strcmp(PQgetvalue(res, 0, 5), "t") ? 1 : 0);
 			rc = GGZDB_NO_ERROR;
 		} else	{
 			/* This is supposed to happen when we look up
@@ -643,7 +643,7 @@
 			strncpy(pe->email, PQgetvalue(iterres, 0, 4), sizeof(pe->email));
 			pe->last_login = atol(PQgetvalue(iterres, 0, 5));
 			pe->perms = atol(PQgetvalue(iterres, 0, 6));
-			pe->confirmed = atol(PQgetvalue(iterres, 0, 7));
+			pe->confirmed = (!ggz_strcmp(PQgetvalue(iterres, 0, 7), "t") ? 1 : 0);
 			rc = GGZDB_NO_ERROR;
 		} else {
 			PQclear(iterres);
@@ -680,7 +680,7 @@
 		strncpy(pe->email, PQgetvalue(iterres, itercount, 4), sizeof(pe->email));
 		pe->last_login = atol(PQgetvalue(iterres, itercount, 5));
 		pe->perms = atol(PQgetvalue(iterres, itercount, 6));
-		pe->confirmed = atol(PQgetvalue(iterres, itercount, 7));
+		pe->confirmed = (!ggz_strcmp(PQgetvalue(iterres, 0, 7), "t") ? 1 : 0);
 
 		return GGZDB_NO_ERROR;
 	} else {
@@ -931,7 +931,7 @@
 	return rc;
 }
 
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	PGconn *conn;
 	PGresult *res;
@@ -945,13 +945,21 @@
 		return rc;
 	}
 
+	snprintf(query, sizeof(query),
+		"DELETE FROM savegames "
+		"WHERE game = '%s' AND owner = '%s'",
+		game, owner);
+
+	res = PQexec(conn, query);
+	PQclear(res);
+
 	owner_quoted = _ggz_sql_escape(owner);
 
 	snprintf(query, sizeof(query),
-		"INSERT INTO savegames"
-		"(date, game, owner, savegame) VALUES "
-		"(%li, '%s', '%s', '%s')",
-		time(NULL), game, owner, savegame);
+		"INSERT INTO savegames "
+		"(date, game, owner, savegame, tableid) VALUES "
+		"(%li, '%s', '%s', '%s', %i)",
+		time(NULL), game, owner, savegame, tableid);
 
 	ggz_free(owner_quoted);
 
@@ -1037,3 +1045,195 @@
 	return GGZDB_NO_ERROR;
 }
 
+static void strfree(void *str)
+{
+	ggzdbSavegamePlayers *sp = str;
+	int i;
+
+	ggz_free(sp->owner);
+	ggz_free(sp->savegame);
+	for(i = 0; i < sp->count; i++) {
+		ggz_free(sp->names[i]);
+	}
+	if(sp->names)
+		ggz_free(sp->names);
+	if(sp->types)
+		ggz_free(sp->types);
+	ggz_free(sp);
+}
+
+GGZList *_ggzdb_savegame_owners(const char *game)
+{
+	PGconn *conn;
+	PGresult *res, *res2;
+	GGZList *owners = NULL;
+
+	char query[4096];
+	char *game_quoted;
+	char *owner;
+	char *savegame;
+	int tableid;
+	int i, j;
+	ggzdbSavegamePlayers *sp;
+
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("ggzdb_savegame_owners: couldn't claim connection");
+		return NULL;
+	}
+
+	game_quoted = _ggz_sql_escape(game);
+	snprintf(query, sizeof(query),
+		"SELECT owner, tableid, savegame FROM savegames WHERE game = '%s'",
+		game_quoted);
+	ggz_free(game_quoted);
+
+	res = PQexec(conn, query);
+	if (PQresultStatus(res) != PGRES_TUPLES_OK) {
+		err_msg("couldn't read savegame owners");
+	} else {
+		owners = ggz_list_create(NULL, NULL, (ggzEntryDestroy)strfree, GGZ_LIST_ALLOW_DUPS);
+		for(i = 0; i < PQntuples(res); i++) {
+			owner = ggz_strdup(PQgetvalue(res, i, 0));
+			tableid = atol(ggz_strdup(PQgetvalue(res, i, 1)));
+			savegame = ggz_strdup(PQgetvalue(res, i, 2));
+
+			sp = ggz_malloc(sizeof(ggzdbSavegamePlayers));
+			sp->owner = owner;
+			sp->count = 0;
+			sp->names = NULL;
+			sp->types = NULL;
+			sp->savegame = savegame;
+
+			snprintf(query, sizeof(query),
+				"SELECT seat, seattype, handle FROM savegameplayers "
+				"WHERE savegame = %i ORDER BY seat ASC",
+				tableid);
+
+			res2 = PQexec(conn, query);
+			if (PQresultStatus(res2) != PGRES_TUPLES_OK) {
+				err_msg("couldn't read savegame players");
+			} else {
+				sp->count = PQntuples(res2);
+				sp->types = ggz_malloc(sp->count * sizeof(int));
+				sp->names = ggz_malloc(sp->count * sizeof(char*));
+				for(j = 0; j < sp->count; j++) {
+					sp->types[j] = ggz_string_to_seattype(PQgetvalue(res2, j, 1));
+					sp->names[j] = ggz_strdup(PQgetvalue(res2, j, 2));
+				}
+			}
+			PQclear(res2);
+
+			ggz_list_insert(owners, sp);
+
+			snprintf(query, sizeof(query),
+				"DELETE FROM savegameplayers WHERE savegame = %i",
+				tableid);
+
+			res2 = PQexec(conn, query);
+			PQclear(res2);
+
+			snprintf(query, sizeof(query),
+				"DELETE FROM savegames WHERE tableid = %i",
+				tableid);
+
+			res2 = PQexec(conn, query);
+			PQclear(res2);
+		}
+	}
+	PQclear(res);
+
+	releaseconnection(conn);
+
+	return owners;
+}
+
+GGZList *_ggzdb_savegames(const char *game, const char *owner)
+{
+	PGconn *conn;
+	PGresult *res;
+	GGZList *savegames = NULL;
+	
+	char query[4096];
+	char *game_quoted;
+	char *owner_quoted;
+	char *savegame;
+	int i;
+
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("ggzdb_savegames: couldn't claim connection");
+		return NULL;
+	}
+
+	game_quoted = _ggz_sql_escape(game);
+	owner_quoted = _ggz_sql_escape(owner);
+	snprintf(query, sizeof(query),
+		"SELECT savegame FROM savegames "
+		"WHERE game = '%s' AND owner = '%s'",
+		game_quoted, owner_quoted);
+	ggz_free(game_quoted);
+	ggz_free(owner_quoted);
+
+	res = PQexec(conn, query);
+	if (PQresultStatus(res) != PGRES_TUPLES_OK) {
+		err_msg("couldn't read savegames");
+	} else {
+		savegames = ggz_list_create(NULL, NULL, (ggzEntryDestroy)strfree, GGZ_LIST_ALLOW_DUPS);
+		for(i = 0; i < PQntuples(res); i++) {
+			savegame = ggz_strdup(PQgetvalue(res, i, 0));
+			ggz_list_insert(savegames, savegame);
+		}
+	}
+	PQclear(res);
+
+	releaseconnection(conn);
+
+	return savegames;
+}
+
+GGZDBResult _ggzdb_savegame_player(int savegame, int seat, const char *name, int type)
+{
+	PGconn *conn;
+	PGresult *res;
+	char query[4096];
+	int rc = GGZDB_ERR_DB;
+	char *name_quoted;
+
+	conn = claimconnection();
+	if (!conn) {
+		err_msg("_ggzdb_savegame_player: couldn't claim connection");
+		return rc;
+	}
+
+	snprintf(query, sizeof(query),
+		"DELETE FROM savegameplayers "
+		"WHERE savegame = %i AND seat = %i",
+		savegame, seat);
+
+	res = PQexec(conn, query);
+
+	name_quoted = _ggz_sql_escape(name);
+
+	snprintf(query, sizeof(query),
+		"INSERT INTO savegameplayers "
+		"(savegame, seat, handle, seattype) VALUES "
+		"(%i, %i, '%s', '%s')",
+		savegame, seat, name_quoted, ggz_seattype_to_string(type));
+
+	if(name_quoted)
+		ggz_free(name_quoted);
+
+	res = PQexec(conn, query);
+
+	if (PQresultStatus(res) != PGRES_COMMAND_OK) {
+		err_msg("couldn't insert savegame player");
+	}
+	else rc = GGZDB_NO_ERROR;
+	PQclear(res);
+
+	releaseconnection(conn);
+
+	return rc;
+}
+
Index: ggzd/database/ggz.sql
===================================================================
--- ggzd/database/ggz.sql	(Revision 9802)
+++ ggzd/database/ggz.sql	(Arbeitskopie)
@@ -54,6 +54,15 @@
 	"date" bigint,
 	"game" character varying(256),
 	"owner" character varying(256),
-	"savegame" character varying(256)
+	"savegame" character varying(256),
+	"tableid" bigint
 );
 
+CREATE TABLE "%PREFIX%savegameplayers" (
+	"id" serial NOT NULL,
+	"savegame" bigint,
+	"seat" bigint,
+	"handle" character varying(256),
+	"seattype" character varying(256)
+);
+
Index: ggzd/database/ggzdb_dbi.c
===================================================================
--- ggzd/database/ggzdb_dbi.c	(Revision 9802)
+++ ggzd/database/ggzdb_dbi.c	(Arbeitskopie)
@@ -327,7 +327,7 @@
 	return GGZDB_NO_ERROR;
 }
 
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	/* Not implemented, but do not return error */
 	return GGZDB_NO_ERROR;
Index: ggzd/database/ggzdb_sqlite.c
===================================================================
--- ggzd/database/ggzdb_sqlite.c	(Revision 9802)
+++ ggzd/database/ggzdb_sqlite.c	(Arbeitskopie)
@@ -277,7 +277,7 @@
 	return GGZDB_NO_ERROR;
 }
 
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	/* Not implemented, but do not return error */
 	return GGZDB_NO_ERROR;
Index: ggzd/database/ggzdb_mysql.c
===================================================================
--- ggzd/database/ggzdb_mysql.c	(Revision 9802)
+++ ggzd/database/ggzdb_mysql.c	(Arbeitskopie)
@@ -525,7 +525,7 @@
 	}
 }
 
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	char query[4096];
 	int rc;
@@ -535,9 +535,9 @@
 
 	snprintf(query, sizeof(query),
 		"INSERT INTO `savegames`"
-		"(`date`,`game`,`owner`,`savegame`) VALUES "
-		"(%li, '%s', '%s', '%s')",
-		time(NULL), game, owner, savegame);
+		"(`date`,`game`,`owner`,`savegame`,`tableid`) VALUES "
+		"(%li, '%s', '%s', '%s', %i)",
+		time(NULL), game, owner, savegame, tableid);
 
 	ggz_free(owner_quoted);
 
Index: ggzd/database/ggzdb_proto.h
===================================================================
--- ggzd/database/ggzdb_proto.h	(Revision 9802)
+++ ggzd/database/ggzdb_proto.h	(Arbeitskopie)
@@ -123,7 +123,7 @@
 GGZDBResult _ggzdb_stats_newmatch(const char *game, const char *winner, const char *savegame);
 
 /** Register a savegame entry temporarily */
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame);
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid);
 
 /** Add player entry to a match statistics entry */
 GGZDBResult _ggzdb_stats_match(ggzdbPlayerGameStats *stats);
@@ -135,3 +135,9 @@
 GGZDBResult _ggzdb_stats_calcrankings(const char *game);
 
 unsigned int _ggzdb_player_next_uid(void);
+
+GGZList *_ggzdb_savegames(const char *game, const char *owner);
+GGZList *_ggzdb_savegame_owners(const char *game);
+
+GGZDBResult _ggzdb_savegame_player(int savegame, int seat, const char *name, int type);
+
Index: ggzd/database/ggzdb_db4.c
===================================================================
--- ggzd/database/ggzdb_db4.c	(Revision 9802)
+++ ggzd/database/ggzdb_db4.c	(Arbeitskopie)
@@ -417,7 +417,7 @@
 	return GGZDB_NO_ERROR;
 }
 
-GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult _ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	/* Not implemented, but do not return error */
 	return GGZDB_NO_ERROR;
Index: ggzd/database/ggzdb_functions.h
===================================================================
--- ggzd/database/ggzdb_functions.h	(Revision 9802)
+++ ggzd/database/ggzdb_functions.h	(Arbeitskopie)
@@ -39,8 +39,13 @@
 GGZDBResult (*_ggzdb_stats_lookup)(ggzdbPlayerGameStats *stats);
 GGZDBResult (*_ggzdb_stats_update)(ggzdbPlayerGameStats *stats);
 GGZDBResult (*_ggzdb_stats_newmatch)(const char *game, const char *winner, const char *savegame);
-GGZDBResult (*_ggzdb_stats_savegame)(const char *game, const char *owner, const char *savegame);
+GGZDBResult (*_ggzdb_stats_savegame)(const char *game, const char *owner, const char *savegame, int tableid);
 GGZDBResult (*_ggzdb_stats_match)(ggzdbPlayerGameStats *stats);
 GGZDBResult (*_ggzdb_stats_toprankings)(const char *game, int number, ggzdbPlayerGameStats **rankings);
 GGZDBResult (*_ggzdb_stats_calcrankings)(const char *game);
 
+GGZList* (*_ggzdb_savegames)(const char *game, const char *owner);
+GGZList* (*_ggzdb_savegame_owners)(const char *game);
+
+GGZDBResult (*_ggzdb_savegame_player)(int savegame, int seat, const char *name, int type);
+
Index: ggzd/database/ggzdb.c
===================================================================
--- ggzd/database/ggzdb.c	(Revision 9802)
+++ ggzd/database/ggzdb.c	(Arbeitskopie)
@@ -140,7 +140,11 @@
 	|| ((_ggzdb_stats_savegame = dlsym(handle, "_ggzdb_stats_savegame")) == NULL)
 	|| ((_ggzdb_stats_match = dlsym(handle, "_ggzdb_stats_match")) == NULL)
 	|| ((_ggzdb_stats_toprankings = dlsym(handle, "_ggzdb_stats_toprankings")) == NULL)
-	|| ((_ggzdb_stats_calcrankings = dlsym(handle, "_ggzdb_stats_calcrankings")) == NULL))
+	|| ((_ggzdb_stats_calcrankings = dlsym(handle, "_ggzdb_stats_calcrankings")) == NULL)
+	|| ((_ggzdb_savegames = dlsym(handle, "_ggzdb_savegames")) == NULL)
+	|| ((_ggzdb_savegame_owners = dlsym(handle, "_ggzdb_savegame_owners")) == NULL)
+	|| ((_ggzdb_savegame_player = dlsym(handle, "_ggzdb_savegame_player")) == NULL)
+	)
 	{
 		err_sys_exit("%s is an invalid database module (%s)",
 			backend, dlerror());
@@ -418,7 +422,7 @@
 }
 
 
-GGZDBResult ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame)
+GGZDBResult ggzdb_stats_savegame(const char *game, const char *owner, const char *savegame, int tableid)
 {
 	GGZDBResult rc = GGZDB_NO_ERROR;
 
@@ -428,7 +432,7 @@
 		rc = ggzdb_stats_init();
 
 	if (rc == GGZDB_NO_ERROR)
-		rc = _ggzdb_stats_savegame(game, owner, savegame);
+		rc = _ggzdb_stats_savegame(game, owner, savegame, tableid);
 
 	_ggzdb_exit();
 
@@ -471,7 +475,60 @@
 	return rc;
 }
 
+GGZList *ggzdb_savegames(const char *game, const char *owner)
+{
+	GGZList *list = NULL;
+	GGZDBResult rc = GGZDB_NO_ERROR;
 
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		list = _ggzdb_savegames(game, owner);
+
+	_ggzdb_exit();
+
+	return list;
+}
+
+GGZList *ggzdb_savegame_owners(const char *game)
+{
+	GGZList *list = NULL;
+	GGZDBResult rc = GGZDB_NO_ERROR;
+
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		list = _ggzdb_savegame_owners(game);
+
+	_ggzdb_exit();
+
+	return list;
+}
+
+GGZDBResult ggzdb_savegameplayer(int savegame, int seat, const char *name, int type)
+{
+	GGZDBResult rc = GGZDB_NO_ERROR;
+
+	_ggzdb_enter();
+
+	if (stats_needs_init)
+		rc = ggzdb_stats_init();
+
+	if (rc == GGZDB_NO_ERROR)
+		rc = _ggzdb_savegame_player(savegame, seat, name, type);
+
+	_ggzdb_exit();
+
+	return rc;
+}
+
+
 /*** INTERNAL FUNCTIONS ***/
 
 /* Function to initialize player tables if necessary */
Index: ggzd/datatypes.h
===================================================================
--- ggzd/datatypes.h	(Revision 9802)
+++ ggzd/datatypes.h	(Arbeitskopie)
@@ -147,6 +147,10 @@
 
 	/* Can players request each other's hostnames? */
 	bool allow_peers;
+
+	/* Games should be automatically restored if they're saved when
+	   server runs */
+	bool restore_allow;
 } GameInfo;
 
 
Index: ggzd/room.c
===================================================================
--- ggzd/room.c	(Revision 9802)
+++ ggzd/room.c	(Arbeitskopie)
@@ -623,3 +623,72 @@
 	return removed;
 }
 
+
+/* This function is used for restore tables in room after crash
+*/
+void room_restore(int room)
+{
+	pthread_rwlock_rdlock(&rooms[room].lock);
+	int game_type = rooms[room].game_type;
+	pthread_rwlock_unlock(&rooms[room].lock);
+    
+	pthread_rwlock_rdlock(&game_types[game_type].lock);
+	int restore_allow = game_types[game_type].restore_allow;
+	pthread_rwlock_unlock(&game_types[game_type].lock);
+    
+	if (restore_allow) {
+		pthread_rwlock_rdlock(&game_types[game_type].lock);
+		char *game_name = ggz_strdup(ggz_intlstring_translated(game_types[game_type].name, NULL));
+		pthread_rwlock_unlock(&game_types[game_type].lock);
+
+		GGZList *owners = ggzdb_savegame_owners(game_name);
+		ggzdbSavegamePlayers *sp;
+		GGZListEntry *entry;
+
+		ggz_free(game_name);
+
+		if (owners != NULL) {
+			dbg_msg(GGZ_DBG_ROOM, "Restore games for room %d...", room);
+
+			for(entry = ggz_list_head(owners); entry; entry = ggz_list_next(entry)) {
+				sp = ggz_list_get_data(entry);
+				GGZTable *table = table_new();
+				table->type = game_type;
+				table->room = room;
+				table->state = GGZDMOD_STATE_RESTORED;
+				table->savegame = sp->savegame;
+
+				// Make open all seats. Game using save game
+				// must be not used seats close.
+				pthread_rwlock_rdlock(&game_types[game_type].lock);
+				int seats = ggz_numberlist_get_max(&game_types[game_type].player_allow_list);
+				pthread_rwlock_unlock(&game_types[game_type].lock);
+
+				dbg_msg(GGZ_DBG_ROOM, "- owner %s with %d seats", sp->owner, seats);
+
+				table->num_seats = seats;
+				if (seats > 0) {
+					table->seat_types = ggz_malloc(seats * sizeof(*table->seat_types));
+					table->seat_names = ggz_malloc(seats * sizeof(*table->seat_names));
+					int i;
+					for(i = 0; i < seats; ++i) {
+						if(i < sp->count) {
+							table->seat_types[i] = sp->types[i];
+							ggz_strncpy(table->seat_names[i], sp->names[i], MAX_USER_NAME_LEN);
+						} else {
+							table->seat_types[i] = GGZ_SEAT_OPEN;
+							table->seat_names[i][0] = '\0';
+						}
+					}
+				}
+
+				if (table_launch(table, sp->owner) != E_OK)
+					ggz_free(table);
+			}
+			ggz_list_free(owners);
+		}
+	}
+
+	return;
+}
+
Index: ggzd/room.h
===================================================================
--- ggzd/room.h	(Revision 9802)
+++ ggzd/room.h	(Arbeitskopie)
@@ -123,6 +123,7 @@
 int room_get_count_rooms(void);
 int room_is_removed(int room);
 int room_will_be_removed(int room);
+void room_restore(int room);
 
 GGZReturn room_update_event(const char *player,
 			    GGZPlayerUpdateType update,
Index: ggzd/table.c
===================================================================
--- ggzd/table.c	(Revision 9802)
+++ ggzd/table.c	(Arbeitskopie)
@@ -112,7 +112,7 @@
 static GGZReturn table_launch_event(char* name,
 				    GGZClientReqError status, int index);
 
-static int   type_match_table(int type, GGZTable* table);
+static int type_match_table(int type, GGZTable* table);
 
 
 
@@ -421,7 +421,7 @@
 #endif
 	char **args;
 	char *pwd;
-	char *game;
+	char *game, *name;
 	int type, i, num_seats;
 	GGZReturn status = GGZ_OK;
 	GGZSeat seat;
@@ -440,6 +440,7 @@
 	pwd = game_types[type].data_dir;
 	args = rooms[table->room].exec_args;
 	game = game_types[type].game;
+	name = ggz_intlstring_translated(game_types[type].name, NULL);
 	pthread_rwlock_unlock(&game_types[type].lock);
 
 	/* Set a pointer to the table so we can get it back in the
@@ -462,7 +463,7 @@
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_REQ_OPEN,
 			    &table_game_req_open);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_ERROR, &table_error);
-	
+
 	/* Setup seats for game table */
 	num_seats = seats_num(table);
 	ggzdmod_set_num_seats(table->ggzdmod, num_seats);
@@ -479,7 +480,10 @@
 		seat.fd = -1;
 		if (ggzdmod_set_seat(table->ggzdmod, &seat) < 0)
 			status = GGZ_ERROR;
+
+		ggzdb_savegameplayer(pthread_self(), i, seat.name, seat.type);
 	}
+	ggzdb_stats_savegame(name, table->owner, table->savegame, pthread_self());
 
 	/* And start the game */
 	log_msg(GGZ_LOG_TABLES, "Launching table: %s", args[0]);
@@ -487,6 +491,14 @@
 	if (ggzdmod_connect(table->ggzdmod) < 0)
 		status = GGZ_ERROR;
 
+	if (table->state == GGZDMOD_STATE_RESTORED) {
+		log_msg(GGZ_LOG_TABLES,"Server change game state to %d",
+			table->state);
+		ggzdmod_set_state(table->ggzdmod, table->state);
+		ggzdmod_send_savedgame(table->ggzdmod, table->savegame);
+		ggzdmod_set_state(table->ggzdmod, GGZDMOD_STATE_CREATED);
+	}
+
 	return status;
 }
 
@@ -887,6 +899,15 @@
 			table_event_enqueue(table, GGZ_TABLE_UPDATE_STATE);
 		return;
 
+	case GGZDMOD_STATE_RESTORED:
+		dbg_msg(GGZ_DBG_TABLE,
+			"Table %d in room %d is restored.", 
+			table->index, table->room);
+
+		pthread_rwlock_wrlock(&table->lock);
+		table->state = GGZ_TABLE_RESTORED;
+		pthread_rwlock_unlock(&table->lock);
+		return;
 	case GGZDMOD_STATE_CREATED:
 		break;
 	}
@@ -935,7 +956,6 @@
 	/* FIXME: we might want to auto-send the updated rankings here? */
 }
 
-
 static void table_game_savegame(GGZdMod *ggzdmod,
 			      GGZdModEvent event, const void *data)
 {
@@ -1084,6 +1104,8 @@
 		ggzdmod_set_seat(ggzdmod, &seat);
 		transit = GGZ_TRANSIT_LEAVE;
 		update = GGZ_TABLE_UPDATE_LEAVE;
+
+		ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
 	}
 
 	pthread_rwlock_wrlock(&table->lock);
@@ -1135,6 +1157,8 @@
 	seat.playerdata = NULL;
 	ggzdmod_set_seat(ggzdmod, &seat);
 
+	ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
+
 	pthread_rwlock_wrlock(&table->lock);
 	table->seat_types[seat_num] = GGZ_SEAT_BOT;
 	pthread_rwlock_unlock(&table->lock);
@@ -1147,12 +1171,11 @@
 }
 
 
-static void table_game_req_open(GGZdMod *ggzdmod,
-				GGZdModEvent event, const void *data)
+static void _table_game_change_seat(GGZdMod *ggzdmod,
+				    GGZdModEvent event, int seat_num, GGZSeatType seat_type,
+				    const char *name)
 {
 	GGZTable *table = ggzdmod_get_gamedata(ggzdmod);
-	const int *seat_num_ptr = data;
-	const int seat_num = *seat_num_ptr;
 	GGZSeat seat;
 
 	/* FIXME: this code overlaps with the leaving code in transit.c */
@@ -1170,13 +1193,15 @@
 
 	seat.num = seat_num;
 	seat.type = GGZ_SEAT_OPEN;
-	seat.name = NULL;
+	seat.name = name;
 	seat.fd = -1;
 	seat.playerdata = NULL;
 	ggzdmod_set_seat(ggzdmod, &seat);
 
+	ggzdb_savegameplayer(pthread_self(), seat.num, seat.name, seat.type);
+
 	pthread_rwlock_wrlock(&table->lock);
-	table->seat_types[seat_num] = GGZ_SEAT_OPEN;
+	table->seat_types[seat_num] = seat_type;
 	table->seat_names[seat_num][0] = '\0';
 	pthread_rwlock_unlock(&table->lock);
 
@@ -1187,7 +1212,16 @@
 				   "", seat_num);
 }
 
+static void table_game_req_open(GGZdMod *ggzdmod,
+				GGZdModEvent event, const void *data)
+{
+	const int *seat_num_ptr = data;
+	const int seat_num = *seat_num_ptr;
 
+	_table_game_change_seat(ggzdmod, event, seat_num, GGZ_SEAT_OPEN, NULL);
+}
+
+
 static void table_error(GGZdMod *ggzdmod,
 			GGZdModEvent event, const void *data)
 {
Index: ggzd/parse_opt.c
===================================================================
--- ggzd/parse_opt.c	(Revision 9802)
+++ ggzd/parse_opt.c	(Arbeitskopie)
@@ -698,6 +698,9 @@
 	game_info.allow_peers = ggz_conf_read_int(ch, "TableOptions", 
 						  "AllowPeers", 0);
 
+	game_info.restore_allow = ggz_conf_read_int(ch, "TableOptions",
+						    "AllowRestore", 0);
+
 	/* Named bots */
 	game_info.named_bots = NULL;
 
