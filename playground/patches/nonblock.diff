Index: types.h
===================================================================
--- types.h	(revision 8178)
+++ types.h	(working copy)
@@ -30,6 +30,7 @@
 
 #include <sys/types.h>
 
+#include "dataio.h"
 #include "shared.h"
 
 #include "deck.h"
@@ -79,8 +80,9 @@
 	team_t team;		/* The player's team, or -1 for none. */
 	bool ready;
 	
+	struct dataio *dio;
+
 	/* Used for tracking AI processees. */
-	int fd;
 #ifdef DEBUG
 	int err_fd;
 #endif /* DEBUG */
@@ -96,6 +98,10 @@
 	seat_t play_seat;	/* what seat are we playing from? */
 };
 
+struct game_spectator_t {
+	struct dataio *dio;
+};
+
 /* Used in message-sending in message.c. */
 typedef struct global_message_list_t global_message_list_t;
 
Index: games/lapocha.c
===================================================================
--- games/lapocha.c	(revision 8178)
+++ games/lapocha.c	(working copy)
@@ -31,6 +31,7 @@
 
 #include <ggz.h>
 
+#include "dataio.h"
 #include "net_common.h"
 
 #include "bid.h"
@@ -61,8 +62,8 @@
 static void lapocha_end_hand(void);
 
 /* these send lapocha-specific game messages. */
-static int lap_send_trump_request(player_t p);
-static int lap_send_bid_request(player_t p);
+static void lap_send_trump_request(player_t p);
+static void lap_send_bid_request(player_t p);
 static void lap_send_dealer(void);
 static void lap_send_trump(void);
 static void lap_send_bid(player_t bidder, bid_t bid);
@@ -301,26 +302,30 @@
    games. */
 
 /* these send lapocha-specific game messages. */
-static int lap_send_trump_request(player_t p)
+static void lap_send_trump_request(player_t p)
 {
-	int fd = get_player_socket(p);
-	if (write_opcode(fd, MESSAGE_GAME) < 0 ||
-	    write_opcode(fd, GAME_MESSAGE_GAME) < 0 ||
-	    ggz_write_string(fd, "lapocha") < 0 ||
-	    ggz_write_int(fd, 1) < 0 || ggz_write_char(fd, LAP_REQ_TRUMP) < 0)
-		return -1;
-	return 0;
+	struct dataio *dio = get_player_socket(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, MESSAGE_GAME);
+	write_opcode(dio, GAME_MESSAGE_GAME);
+	dio_put_string(dio, "lapocha");
+	dio_put_int(dio, 1);
+	dio_put_char(dio, LAP_REQ_TRUMP);
+	dio_end_packet(dio);
 }
 
-static int lap_send_bid_request(player_t p)
+static void lap_send_bid_request(player_t p)
 {
-	int fd = get_player_socket(p);
-	if (write_opcode(fd, MESSAGE_GAME) < 0 ||
-	    write_opcode(fd, GAME_MESSAGE_GAME) < 0 ||
-	    ggz_write_string(fd, "lapocha") < 0 ||
-	    ggz_write_int(fd, 1) < 0 || ggz_write_char(fd, LAP_REQ_BID) < 0)
-		return -1;
-	return 0;
+	struct dataio *dio = get_player_socket(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, MESSAGE_GAME);
+	write_opcode(dio, GAME_MESSAGE_GAME);
+	dio_put_string(dio, "lapocha");
+	dio_put_int(dio, 1);
+	dio_put_char(dio, LAP_REQ_BID);
+	dio_end_packet(dio);
 }
 
 static void lap_send_dealer(void)
@@ -328,14 +333,16 @@
 	int p;
 	
 	for (p = 0; p < game.num_players; p++) {
-		int fd = get_player_socket(p);
+		struct dataio *dio = get_player_socket(p);
 
-		write_opcode(fd, MESSAGE_GAME);
-		write_opcode(fd, GAME_MESSAGE_GAME);
-		ggz_write_string(fd, "lapocha");
-		ggz_write_int(fd, 5);
-		ggz_write_char(fd, LAP_MSG_DEALER);
-		ggz_write_int(fd, CONVERT_SEAT(game.dealer, p));
+		dio_start_packet(dio);
+		write_opcode(dio, MESSAGE_GAME);
+		write_opcode(dio, GAME_MESSAGE_GAME);
+		dio_put_string(dio, "lapocha");
+		dio_put_int(dio, 5);
+		dio_put_char(dio, LAP_MSG_DEALER);
+		dio_put_int(dio, CONVERT_SEAT(game.dealer, p));
+		dio_end_packet(dio);
 	}
 }
 
@@ -344,13 +351,16 @@
 	int p;
 	
 	for (p = 0; p < game.num_players; p++) {
-		int fd = get_player_socket(p);
-		write_opcode(fd, MESSAGE_GAME);
-		write_opcode(fd, GAME_MESSAGE_GAME);
-		ggz_write_string(fd, "lapocha");
-		ggz_write_int(fd, 2);
-		ggz_write_char(fd, LAP_MSG_TRUMP);
-		ggz_write_char(fd, game.trump);
+		struct dataio *dio = get_player_socket(p);
+
+		dio_start_packet(dio);
+		write_opcode(dio, MESSAGE_GAME);
+		write_opcode(dio, GAME_MESSAGE_GAME);
+		dio_put_string(dio, "lapocha");
+		dio_put_int(dio, 2);
+		dio_put_char(dio, LAP_MSG_TRUMP);
+		dio_put_char(dio, game.trump);
+		dio_end_packet(dio);
 	}
 }
 
@@ -362,14 +372,17 @@
 	assert(game.players[bidder].seat == bidder);
 	
 	for (p = 0; p < game.num_players; p++) {
-		int fd = get_player_socket(p);
-		write_opcode(fd, MESSAGE_GAME);
-		write_opcode(fd, GAME_MESSAGE_GAME);
-		ggz_write_string(fd, "lapocha");
-		ggz_write_int(fd, 9);
-		ggz_write_char(fd, LAP_MSG_BID);
-		ggz_write_int(fd, bidder);
-		ggz_write_int(fd, the_bid);
+		struct dataio *dio = get_player_socket(p);
+
+		dio_start_packet(dio);
+		write_opcode(dio, MESSAGE_GAME);
+		write_opcode(dio, GAME_MESSAGE_GAME);
+		dio_put_string(dio, "lapocha");
+		dio_put_int(dio, 9);
+		dio_put_char(dio, LAP_MSG_BID);
+		dio_put_int(dio, bidder);
+		dio_put_int(dio, the_bid);
+		dio_end_packet(dio);
 	}
 }
 
@@ -378,17 +391,20 @@
 	player_t p;
 
 	for (p = 0; p < game.num_players; p++) {
-		int fd = get_player_socket(p);
+		struct dataio *dio = get_player_socket(p);
 		seat_t s_r;
-		write_opcode(fd, MESSAGE_GAME);
-		write_opcode(fd, GAME_MESSAGE_GAME);
-		ggz_write_string(fd, "lapocha");
-		ggz_write_int(fd, 17);
-		ggz_write_char(fd, LAP_MSG_SCORES);
+
+		dio_start_packet(dio);
+		write_opcode(dio, MESSAGE_GAME);
+		write_opcode(dio, GAME_MESSAGE_GAME);
+		dio_put_string(dio, "lapocha");
+		dio_put_int(dio, 17);
+		dio_put_char(dio, LAP_MSG_SCORES);
 		for (s_r = 0; s_r < game.num_seats; s_r++) {
 			seat_t s_abs = UNCONVERT_SEAT(s_r, p);
 			assert(game.seats[s_abs].player == s_abs);
-			ggz_write_int(fd, game.players[s_abs].score);
+			dio_put_int(dio, game.players[s_abs].score);
 		}
+		dio_end_packet(dio);
 	}
 }
Index: common/net_common.c
===================================================================
--- common/net_common.c	(revision 8178)
+++ common/net_common.c	(working copy)
@@ -38,93 +38,84 @@
 
 #include "net_common.h"
 
-int read_card(int fd, card_t * card)
+void read_card(struct dataio *dio, card_t * card)
 {
-	if (ggz_read_char(fd, &card->face) < 0 ||
-	    ggz_read_char(fd, &card->suit) < 0 ||
-	    ggz_read_char(fd, &card->deck) < 0)
-		return -1;
+	dio_get_char(dio, &card->face);
+	dio_get_char(dio, &card->suit);
+	dio_get_char(dio, &card->deck);
 		
 	/* We go ahead and check the card for validity. */
 	if (is_valid_card(*card))
-		return 0;
+		return;
 	
 #if 0 /* This could be dangerous - anyone could crash us! */
 	assert(FALSE);
 #endif
 
 #if 0 /* This probably makes the most sense, but... */
-	return -1;
+	return;
 #endif
 
 	*card = UNKNOWN_CARD;
-	return 0;
 }
 
-int write_card(int fd, card_t card)
+void write_card(struct dataio *dio, card_t card)
 {
 	/* Check for validity. */
 	assert(is_valid_card(card));
 	
-	if (ggz_write_char(fd, card.face) < 0 ||
-	    ggz_write_char(fd, card.suit) < 0 ||
-	    ggz_write_char(fd, card.deck) < 0)
-		return -1;
-	return 0;
+	dio_put_char(dio, card.face);
+	dio_put_char(dio, card.suit);
+	dio_put_char(dio, card.deck);
 }
 
-int read_bid(int fd, bid_t * bid)
+void read_bid(struct dataio *dio, bid_t * bid)
 {
-	if (ggz_read_char(fd, &bid->sbid.val) < 0 ||
-	    ggz_read_char(fd, &bid->sbid.suit) < 0 ||
-	    ggz_read_char(fd, &bid->sbid.spec) < 0 ||
-	    ggz_read_char(fd, &bid->sbid.spec2) < 0)
-		return -1;
-	return 0;
+	dio_get_char(dio, &bid->sbid.val);
+	dio_get_char(dio, &bid->sbid.suit);
+	dio_get_char(dio, &bid->sbid.spec);
+	dio_get_char(dio, &bid->sbid.spec2);
 }
 
 /** @brief Writes a bid to the socket.
- *  @param fd The file descriptor to which to read.
- *  @param bid A pointer to the bid data.
- *  @return 0 on success, -1 on failure. */
-int write_bid(int fd, bid_t bid)
+ *  @param dio The file descriptor to which to read.
+ *  @param bid A pointer to the bid data. */
+void write_bid(struct dataio *dio, bid_t bid)
 {
-	if (ggz_write_char(fd, bid.sbid.val) < 0 ||
-	    ggz_write_char(fd, bid.sbid.suit) < 0 ||
-	    ggz_write_char(fd, bid.sbid.spec) < 0 ||
-	    ggz_write_char(fd, bid.sbid.spec2) < 0)
-		return -1;
-	return 0;
+	dio_put_char(dio, bid.sbid.val);
+	dio_put_char(dio, bid.sbid.suit);
+	dio_put_char(dio, bid.sbid.spec);
+	dio_put_char(dio, bid.sbid.spec2);
 }
 
-int read_opcode(int fd, int *opcode)
+void read_opcode(struct dataio *dio, int *opcode)
 {
 	char op;
-	if (ggz_read_char(fd, &op) < 0)
-		return -1;
+
+	dio_get_char(dio, &op);
 	*opcode = op;
-	return 0;
 }
 
-int write_opcode(int fd, int opcode)
+void write_opcode(struct dataio *dio, int opcode)
 {
 	char op = opcode;
+
 	assert(opcode >= 0 && opcode < 128);
-	return ggz_write_char(fd, op);
+	dio_put_char(dio, op);
 }
 
-int read_seat(int fd, int *seat)
+void read_seat(struct dataio *dio, int *seat)
 {
 	char s;
-	if (ggz_read_char(fd, &s) < 0)
-		return -1;
+
+	dio_get_char(dio, &s);
 	*seat = s;
-	return 0;
 }
 
-int write_seat(int fd, int seat)
+void write_seat(struct dataio *dio, int seat)
 {
 	char s = seat;
+
 	assert(seat >= 0 && seat < 127);
-	return ggz_write_char(fd, s);
+	dio_put_char(dio, s);
 }
Index: common/net_common.h
===================================================================
--- common/net_common.h	(revision 8178)
+++ common/net_common.h	(working copy)
@@ -29,53 +29,54 @@
  */
 
 #include "cards.h"
+#include "dataio.h"
 
 /** @brief Reads a card from the socket.
  *  @param fd The file descriptor from which to read.
  *  @param card A pointer to the card data.
  *  @return 0 on success, -1 on failure. */
-int read_card(int fd, card_t * card);
+void read_card(struct dataio *dio, card_t * card);
 
 /** @brief Wites a card to the socket.
  *  @param fd The file desciptor to which to write.
  *  @param card The card to be written.
  *  @return 0 on success, -1 on failure. */
-int write_card(int fd, card_t card);
+void write_card(struct dataio *dio, card_t card);
 
 /** @brief Reads a bid from the socket.
  *  @param fd The file descriptor from which to read.
  *  @param bid A pointer to the bid data.
  *  @return 0 on success, -1 on failure. */
-int read_bid(int fd, bid_t * bid);
+void read_bid(struct dataio *dio, bid_t * bid);
 
 /** @brief Writes a bid to the socket.
  *  @param fd The file descriptor to which to read.
  *  @param bid A pointer to the bid data.
  *  @return 0 on success, -1 on failure. */
-int write_bid(int fd, bid_t bid);
+void write_bid(struct dataio *dio, bid_t bid);
 
 /** @brief Reads an opcode from the socket.
  *  @param fd The file descriptor from which to read.
  *  @param op A pointer to the opcode data.
  *  @return 0 on success, negative value on failure.
  *  @see enum server_msg_t, enum client_msg_t */
-int read_opcode(int fd, int *op);
+void read_opcode(struct dataio *dio, int *op);
 
 /** @brief Writes an opcode to the socket.
  *  @param fd The file descriptor to which to write.
  *  @param op The opcode data.
  *  @return 0 on success, negative value on failure.
  *  @see enum server_msg_t, enum client_msg_t */
-int write_opcode(int fd, int op);
+void write_opcode(struct dataio *dio, int op);
 
 /** @brief Reads a seat from the socket.
  *  @param fd The file descriptor from which to read.
  *  @param seat A pointer to the seat number.
  *  @return 0 on success, negative value on failure. */
-int read_seat(int fd, int *seat);
+void read_seat(struct dataio *dio, int *seat);
 
 /** @brief Writes a seat number to the socket.
  *  @param fd The file descriptor to which to write.
  *  @param seat The seat number.
  *  @return 0 on success, negative value on failure. */
-int write_seat(int fd, int seat);
+void write_seat(struct dataio *dio, int seat);
Index: common/Makefile.am
===================================================================
--- common/Makefile.am	(revision 8178)
+++ common/Makefile.am	(working copy)
@@ -7,6 +7,7 @@
 
 libcommon_a_SOURCES = \
 	cards.c cards.h \
+	dataio.c dataio.h \
 	net_common.c net_common.h \
 	protocol.c protocol.h \
 	shared.h
Index: common/shared.h
===================================================================
--- common/shared.h	(revision 8178)
+++ common/shared.h	(working copy)
@@ -32,16 +32,16 @@
 #ifndef __SHARED_H__
 #define __SHARED_H__
 
+#include <stdbool.h>
+
 #ifndef TRUE
-# define TRUE 1
+# define TRUE true
 #endif
 
 #ifndef FALSE
-# define FALSE 0
+# define FALSE false
 #endif
 
-typedef int bool;
-
 #ifndef MIN
 # define MIN(a, b) ( (a) < (b) ? (a) : (b) )
 #endif
Index: ai/game.h
===================================================================
--- ai/game.h	(revision 8178)
+++ ai/game.h	(working copy)
@@ -32,7 +32,7 @@
 #define DBG_PLAY "play"
 #define DBG_AI "misc"
 
-void game_alert_server(int server_socket_fd);
+void game_alert_server(struct dataio *server_dio);
 void game_get_newgame(void);
 void game_alert_newgame(cardset_type_t cardset_type);
 void game_alert_newhand(void);
@@ -61,7 +61,7 @@
 void game_set_cardlist_message(const char *mark, int *lengths,
 				      card_t ** cardlist);
 void game_set_player_message(int player, const char *msg);
-int game_handle_game_message(int fd, const char *game, int size);
+int game_handle_game_message(struct dataio *dio, const char *game, int size);
 
 
 
Index: ai/main.c
===================================================================
--- ai/main.c	(revision 8178)
+++ ai/main.c	(working copy)
@@ -36,6 +36,8 @@
 
 #include <ggz.h>		/* libggz */
 
+#include "dataio.h"
+
 #include "client.h"
 
 #include "game.h"
@@ -48,6 +50,7 @@
 	const char* debug_types[] = {NULL};
 #endif
 	fd_set active_fd_set;
+	struct dataio *dio;
 	int fd;
 	
 	ggz_debug_init(debug_types, NULL);
@@ -57,7 +60,8 @@
 		assert(FALSE);
 
 	/* We should have gotten the FD by now. */
-	fd = client_get_fd();
+	dio = client_get_dio();
+	fd = dio_get_socket(dio);
 	assert(fd >= 0);
 
 	FD_ZERO(&active_fd_set);
@@ -65,9 +69,16 @@
 	
 	while (1) {
 		fd_set read_fd_set = active_fd_set;
+		fd_set write_fd_set = active_fd_set;
+		fd_set *pwrite_fd_set = NULL;
 		int status;
+
+		if (dio_is_write_pending(dio)) {
+			pwrite_fd_set = &write_fd_set;
+		}
 		
-		status = select(fd + 1, &read_fd_set, NULL, NULL, NULL);
+		status = select(fd + 1, &read_fd_set, pwrite_fd_set,
+				NULL, NULL);
 		
 		if (status <= 0) {
 			if (errno != EINTR)
@@ -76,8 +87,14 @@
 		}
 		
 		if (FD_ISSET(fd, &read_fd_set))
-			if (client_handle_server() < 0)
-				exit(0);		
+			if (client_handle_server() < 0) 
+				exit(0);
+
+		if (pwrite_fd_set && FD_ISSET(fd, pwrite_fd_set)) {
+			if (dio_write_data(dio) < 0) {
+				exit(0);
+			}
+		}
 	}
 
 	client_quit();
Index: ai/game.c
===================================================================
--- ai/game.c	(revision 8178)
+++ ai/game.c	(working copy)
@@ -44,7 +44,7 @@
 	return num;
 }
 
-void game_alert_server(int server_socket_fd)
+void game_alert_server(struct dataio *server_dio)
 {
 	/* nothing */
 }
@@ -227,7 +227,7 @@
 	/* nothing */
 }
 
-int game_handle_game_message(int fd, const char *game, int size)
+int game_handle_game_message(struct dataio *dio, const char *game, int size)
 {
 	/* nothing */
 	return 0;
Index: main.c
===================================================================
--- main.c	(revision 8178)
+++ main.c	(working copy)
@@ -223,22 +223,32 @@
 	   the bot channels. */
 	do {
 		/* this is a whole lot of unnecessary code... */
-		fd_set fdset;
+		fd_set read_fd_set, write_fd_set;
 		int max_fd = ggzdmod_get_fd(ggz), status;
 
-		FD_ZERO(&fdset);
-		FD_SET(max_fd, &fdset);
+		FD_ZERO(&read_fd_set);
+		FD_SET(max_fd, &read_fd_set);
 
+		FD_ZERO(&write_fd_set);
+
 		/* Assemble a list of file descriptors to monitor.  This list
 		   includes the main GGZ connection, a connection for each
 		   player (including bots), plus a stderr connection for bots.
 		 */
 		allplayers_iterate(p) {
-			int fd = get_player_socket(p);
+			struct dataio *dio = get_player_socket(p);
+			int fd = dio ? dio_get_socket(dio) : -1;
+
 			if (fd >= 0) {
 				max_fd = MAX(max_fd, fd);
-				assert(!FD_ISSET(fd, &fdset));
-				FD_SET(fd, &fdset);
+
+				assert(!FD_ISSET(fd, &read_fd_set));
+				assert(!FD_ISSET(fd, &write_fd_set));
+
+				FD_SET(fd, &read_fd_set);
+				if (dio_is_write_pending(dio)) {
+					FD_SET(fd, &write_fd_set);
+				}
 			}
 
 #ifdef DEBUG
@@ -246,14 +256,15 @@
 				fd = game.players[p].err_fd;
 				if (fd >= 0) {
 					max_fd = MAX(max_fd, fd);
-					assert(!FD_ISSET(fd, &fdset));
-					FD_SET(fd, &fdset);
+					assert(!FD_ISSET(fd, &read_fd_set));
+					FD_SET(fd, &read_fd_set);
 				}
 			}
 #endif /* DEBUG */
 		} allplayers_iterate_end;
 
-		status = select(max_fd + 1, &fdset, NULL, NULL, NULL);
+		status = select(max_fd + 1, &read_fd_set, &write_fd_set,
+				NULL, NULL);
 
 		if (status <= 0) {
 			if (errno != EINTR)
@@ -261,29 +272,34 @@
 			continue;
 		}
 
-		if (FD_ISSET(ggzdmod_get_fd(ggz), &fdset))
+		if (FD_ISSET(ggzdmod_get_fd(ggz), &read_fd_set))
 			ggzdmod_dispatch(ggz);
 
 		/* Check each FD for activity */
 		allplayers_iterate(p) {
-			int fd = get_player_socket(p);
+			struct dataio *dio = get_player_socket(p);
+			int fd = dio ? dio_get_socket(dio) : -1;
 
 			/* This is the player's communication socket.  Note
 			   that AI players will have such a socket too, since
 			   they are run as client-like programs. */
-			if (fd >= 0 && FD_ISSET(fd, &fdset)) {
+			if (fd >= 0 && FD_ISSET(fd, &read_fd_set)) {
 				/* Note - this handles spectator data too,
 				   but the spectator is given a player
 				   number. */
 				handle_player_data_event(p);
 			}
 
+			if (fd >= 0 && FD_ISSET(fd, &write_fd_set)) {
+				dio_write_data(dio);
+			}
+
 #ifdef DEBUG
 			/* The AI can send output to stderr; this is read by
 			   us and translated as debugging output. */
 			if (get_player_status(p) == GGZ_SEAT_BOT) {
 				fd = game.players[p].err_fd;
-				if (fd >= 0 && FD_ISSET(fd, &fdset))
+				if (fd >= 0 && FD_ISSET(fd, &read_fd_set))
 					handle_ai_stderr(p);
 			}
 #endif /* DEBUG */
Index: net.c
===================================================================
--- net.c	(revision 8192)
+++ net.c	(working copy)
@@ -46,8 +46,6 @@
 #include "options.h"
 #include "play.h"
 
-#define NET_ERROR(p) return handle_neterror_event(p)
-
 seat_t convert_seat(seat_t s_abs, player_t p)
 {
 	/* Treat spectators as if they're sitting at seat 0. */
@@ -108,12 +106,12 @@
  */
 void net_send_player_list(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	seat_t s_rel;
 
-	if (write_opcode(fd, MSG_PLAYERS) < 0 ||
-	    ggz_write_int(fd, game.num_seats) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_PLAYERS);
+	dio_put_int(dio, game.num_seats);
 
 	/* Note that this function can be called before we know what game
 	   we're playing.  In this case, we'll know the number of players
@@ -123,11 +121,12 @@
 	   desirable to finesse data by sending the player list instead. */
 	for (s_rel = 0; s_rel < game.num_seats; s_rel++) {
 		seat_t s_abs = UNCONVERT_SEAT(s_rel, p);
-		if (ggz_write_int(fd, get_seat_status(s_abs)) < 0
-		    || ggz_write_string(fd, get_seat_name(s_abs)) < 0
-		    || ggz_write_int(fd, game.seats[s_abs].player) < 0)
-			NET_ERROR(p);
+
+		dio_put_int(dio, get_seat_status(s_abs));
+		dio_put_string(dio, get_seat_name(s_abs));
+		dio_put_int(dio, game.seats[s_abs].player);
 	}
+	dio_end_packet(dio);
 }
 
 void net_broadcast_player_list(void)
@@ -149,21 +148,21 @@
                               int *option_defaults,
                               char ***option_choices)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	int i, j;
-	
-	if (write_opcode(fd, REQ_OPTIONS) < 0 ||
-	    ggz_write_int(fd, num_options) < 0)
-		NET_ERROR(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, REQ_OPTIONS);
+	dio_put_int(dio, num_options);
 	for (i = 0; i < num_options; i++) {
-		if (ggz_write_string(fd, option_descs[i]) < 0 ||
-		    ggz_write_int(fd, num_choices[i]) < 0 ||
-		    ggz_write_int(fd, option_defaults[i]) < 0)
-			NET_ERROR(p);
+		dio_put_string(dio, option_descs[i]);
+		dio_put_int(dio, num_choices[i]);
+		dio_put_int(dio, option_defaults[i]);
+
 		for (j = 0; j < num_choices[i]; j++)
-			if (ggz_write_string(fd, option_choices[i][j]) < 0)
-				NET_ERROR(p);
+			dio_put_string(dio, option_choices[i][j]);
 	}
+	dio_end_packet(dio);
 }
 
 /* Send out play for player to _all_ players. Also symbolizes that this play
@@ -175,12 +174,13 @@
  */
 static void net_send_play(player_t p, seat_t player, card_t card)
 {
-	int fd = get_player_socket(p);
-	
-	if (write_opcode(fd, MSG_PLAY) < 0 ||
-	    write_seat(fd, CONVERT_SEAT(player, p)) < 0 ||
-	    write_card(fd, card) < 0)
-		NET_ERROR(p);
+	struct dataio *dio = get_player_socket(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_PLAY);
+	write_seat(dio, CONVERT_SEAT(player, p));
+	write_card(dio, card);
+	dio_end_packet(dio);
 }
 
 void net_broadcast_play(seat_t player, card_t card)
@@ -200,21 +200,21 @@
  */
 static void net_send_gameover(player_t p, int winner_cnt, player_t * winners)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	int i;
 	
 	assert(winner_cnt >= 0 && winner_cnt <= game.num_players);
 
-	if (write_opcode(fd, MSG_GAMEOVER) < 0 ||
-	    ggz_write_int(fd, winner_cnt) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_GAMEOVER);
+	dio_put_int(dio, winner_cnt);
 	
 	for (i = 0; i < winner_cnt; i++) {
 		seat_t ws = game.players[winners[i]].seat;
 		
-		if (write_seat(fd, CONVERT_SEAT(ws, p)) < 0)
-			NET_ERROR(p);
+		write_seat(dio, CONVERT_SEAT(ws, p));
 	}
+	dio_end_packet(dio);
 }
 
 void net_broadcast_gameover(int winner_cnt, player_t *winners)
@@ -228,7 +228,7 @@
 void net_send_table(player_t p)
 {
 	seat_t s_r, s_abs;
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 
 	if (game.num_seats == 0) /* FIXME: don't check this here */
 		return;
@@ -236,13 +236,13 @@
 	ggz_debug(DBG_NET, "Sending table to player %d/%s.", p,
 		    get_player_name(p));
 
-	if (write_opcode(fd, MSG_TABLE) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_TABLE);
 	for (s_r = 0; s_r < game.num_seats; s_r++) {
 		s_abs = UNCONVERT_SEAT(s_r, p);
-		if (write_card(fd, game.seats[s_abs].table) < 0)
-			NET_ERROR(p);
+		write_card(dio, game.seats[s_abs].table);
 	}
+	dio_end_packet(dio);
 }
 
 /* Request a bid from player p.  bid_count is the number of bids; bids is an
@@ -250,18 +250,20 @@
 void net_send_bid_request(player_t p, int bid_count, bid_t * bids)
 {
 	int i;
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	GGZSeatType seat_type = get_player_status(p);
 
 	ggz_debug(DBG_NET, "Sending bid request to player %d/%s.", p,
 		    get_player_name(p));
 
 	/* request a bid from the client */
-	if (write_opcode(fd, REQ_BID) < 0 || ggz_write_int(fd, bid_count) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, REQ_BID);
+	dio_put_int(dio, bid_count);
 	for (i = 0; i < bid_count; i++) {
 		char bid_text[128] = "";
 		char bid_desc[1024] = "";
+
 		if (seat_type != GGZ_SEAT_BOT) {
 			/* HACK: we need to send the full bid text to
 			   a bot. */
@@ -270,22 +272,23 @@
 			game.data->get_bid_desc(bid_desc, sizeof(bid_desc),
 			                         bids[i]);
 		}
-		if (write_bid(fd, bids[i]) < 0 ||
-		    ggz_write_string(fd, bid_text) < 0 ||
-		    ggz_write_string(fd, bid_desc) < 0)
-			NET_ERROR(p);
+		write_bid(dio, bids[i]);
+		dio_put_string(dio, bid_text);
+		dio_put_string(dio, bid_desc);
 	}
+	dio_end_packet(dio);
 }
 
 void net_send_bid(player_t p, player_t bidder, bid_t bid)
 {
 	seat_t seat = game.players[bidder].seat;
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
-	if (write_opcode(fd, MSG_BID) < 0 ||
-	    write_seat(fd, CONVERT_SEAT(seat, p)) < 0 ||
-	    write_bid(fd, bid) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_BID);
+	write_seat(dio, CONVERT_SEAT(seat, p));
+	write_bid(dio, bid);
+	dio_end_packet(dio);
 }
 
 void net_broadcast_bid(player_t bidder, bid_t bid)
@@ -299,7 +302,7 @@
 void net_send_play_request(player_t p, seat_t s)
 {
 	seat_t s_r = CONVERT_SEAT(s, p);
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
 	hand_t *hand = &game.seats[s].hand;
 	card_t valid_plays[hand->hand_size];
@@ -319,22 +322,23 @@
 		    "to play from seat %d/%s's hand.", p,
 		    get_player_name(p), s, get_seat_name(s));
 
-	if (write_opcode(fd, REQ_PLAY) < 0 ||
-	    write_seat(fd, s_r) < 0 ||
-	    ggz_write_int(fd, num_valid_plays) < 0)
-		NET_ERROR(p);
-		
+	dio_start_packet(dio);
+	write_opcode(dio, REQ_PLAY);
+	write_seat(dio, s_r);
+	dio_put_int(dio, num_valid_plays);
 	for (i = 0; i < num_valid_plays; i++)
-		if (write_card(fd, valid_plays[i]) < 0)
-			NET_ERROR(p);
+		write_card(dio, valid_plays[i]);
+	dio_end_packet(dio);
 }
 
 void net_send_badplay(player_t p, char *msg)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
-	if (write_opcode(fd, MSG_BADPLAY) < 0 || ggz_write_string(fd, msg) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_BADPLAY);
+	dio_put_string(dio, msg);
+	dio_end_packet(dio);
 }
 
 /* Show a player a hand.  This will reveal the cards in the hand iff reveal
@@ -342,7 +346,7 @@
 void net_send_hand(const player_t p, const seat_t s,
                    bool show_fronts, bool show_backs)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	int i;
 
 	ggz_debug(DBG_NET,
@@ -350,10 +354,10 @@
 		    PLAYER_TO_SEAT(p), get_player_name(p), s,
 		    get_seat_name(s), show_fronts, show_backs);
 
-	if (write_opcode(fd, MSG_HAND) < 0
-	    || write_seat(fd, CONVERT_SEAT(s, p)) < 0
-	    || ggz_write_int(fd, game.seats[s].hand.hand_size) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_HAND);
+	write_seat(dio, CONVERT_SEAT(s, p));
+	dio_put_int(dio, game.seats[s].hand.hand_size);
 
 	for (i = 0; i < game.seats[s].hand.hand_size; i++) {
 		card_t card = game.seats[s].hand.cards[i];
@@ -364,18 +368,19 @@
 		if (!show_backs)
 			card.deck = UNKNOWN_DECK;
 
-		if (write_card(fd, card) < 0)
-			NET_ERROR(p);
+		write_card(dio, card);
 	}
+	dio_end_packet(dio);
 }
 
 static void net_send_trick(player_t p, player_t winner)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 
-	if (write_opcode(fd, MSG_TRICK) < 0 ||
-	    write_seat(fd,CONVERT_SEAT(game.players[winner].seat, p)) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_TRICK);
+	write_seat(dio, CONVERT_SEAT(game.players[winner].seat, p));
+	dio_end_packet(dio);
 }
 
 void net_broadcast_trick(player_t winner)
@@ -387,23 +392,26 @@
 
 void net_send_newgame_request(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 
 	assert(get_player_status(p) == GGZ_SEAT_PLAYER);
 
 	ggz_debug(DBG_NET, "Sending out a REQ_NEWGAME to player %d/%s.", p,
 		    get_player_name(p));
-	if (write_opcode(fd, REQ_NEWGAME) < 0)
-		NET_ERROR(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, REQ_NEWGAME);
+	dio_end_packet(dio);
 }
 
 void net_send_newgame(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
-	if (write_opcode(fd, MSG_NEWGAME) < 0
-	    || ggz_write_int(fd, get_cardset_type()) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_NEWGAME);
+	dio_put_int(dio, get_cardset_type());
+	dio_end_packet(dio);
 }
 
 void net_broadcast_newgame(void)
@@ -418,10 +426,11 @@
 
 static void net_send_newhand(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
-	if (write_opcode(fd, MSG_NEWHAND) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MSG_NEWHAND);
+	dio_end_packet(dio);
 }
 
 
@@ -435,10 +444,10 @@
 void net_send_global_text_message(player_t p, const char *mark,
                              const char *message)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
 	/* Special case - don't send to dead bots */
-	if (fd < 0)
+	if (!dio)
 		return;
 	
 	assert(mark);
@@ -446,11 +455,13 @@
 	if (message == NULL)
 		message = "";	/* this happens sometimes (hmmm, really?
 				   how?) */
-	if (write_opcode(fd, MESSAGE_GAME) < 0 ||
-	    write_opcode(fd, GAME_MESSAGE_TEXT) < 0 ||
-	    ggz_write_string(fd, mark) < 0 ||
-	    ggz_write_string(fd, message) < 0)
-		NET_ERROR(p);
+
+	dio_start_packet(dio);
+	write_opcode(dio, MESSAGE_GAME);
+	write_opcode(dio, GAME_MESSAGE_TEXT);
+	dio_put_string(dio, mark);
+	dio_put_string(dio, message);
+	dio_end_packet(dio);
 }
 
 /* send_global_message_toall sends the truly global message to all players */
@@ -463,21 +474,22 @@
 
 void net_send_player_text_message(player_t p, seat_t s, const char *message)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	
 	assert(message);
 	
-	if (write_opcode(fd, MESSAGE_GAME) < 0 ||
-	    write_opcode(fd, GAME_MESSAGE_PLAYER) < 0 ||
-	    write_seat(fd, CONVERT_SEAT(s, p)) < 0 ||
-	    ggz_write_string(fd, message) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MESSAGE_GAME);
+	write_opcode(dio, GAME_MESSAGE_PLAYER);
+	write_seat(dio, CONVERT_SEAT(s, p));
+	dio_put_string(dio, message);
+	dio_end_packet(dio);
 }
 
 void net_send_global_cardlist_message(player_t p, const char *mark, int *lengths,
                                  card_t ** cardlist)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	int i;
 	seat_t s_rel;
 
@@ -485,19 +497,18 @@
 	ggz_debug(DBG_NET, "Sending global cardlist message to player %d.",
 		    p);
 		
-	if (write_opcode(fd, MESSAGE_GAME) < 0 ||
-	    write_opcode(fd, GAME_MESSAGE_CARDLIST) < 0 ||
-	    ggz_write_string(fd, mark) < 0)
-		NET_ERROR(p);
+	dio_start_packet(dio);
+	write_opcode(dio, MESSAGE_GAME);
+	write_opcode(dio, GAME_MESSAGE_CARDLIST);
+	dio_put_string(dio, mark);
 
 	for (s_rel = 0; s_rel < game.num_seats; s_rel++) {
 		seat_t s = UNCONVERT_SEAT(s_rel, p);
-		if (ggz_write_int(fd, lengths[s]) < 0)
-			NET_ERROR(p);
+		dio_put_int(dio, lengths[s]);
 		for (i = 0; i < lengths[s]; i++)
-			if (write_card(fd, cardlist[s][i]) < 0)
-				NET_ERROR(p);
+			write_card(dio, cardlist[s][i]);
 	}
+	dio_end_packet(dio);
 }
 
 void net_broadcast_global_cardlist_message(const char *mark, int *lengths,
@@ -513,83 +524,70 @@
  * NETWORK READING CODE
  */
 
-static int net_rec_language(player_t p)
+static void net_rec_language(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	char lang[128];
 	
 	/* Read the language (string) */
-	if (ggz_read_string(fd, lang, sizeof(lang)) < 0)
-		return -1;
+	dio_get_string(dio, lang, sizeof(lang));
 		
 	handle_client_language(p, lang);
-	return 0;
 }
 
 
 /* receives a bid from the client, and calls handle_client_bid
    to handle it.   Returns 0 on success; -1 on (communication) error */
-static int net_rec_play(player_t p)
+static void net_rec_play(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	card_t card;
 
 	/* read the card played */
-	if (read_card(fd, &card) < 0)
-		return -1;
+	read_card(dio, &card);
 		
 	handle_client_play(p, card);
-	return 0;
 }
 
 /* Receive a bid from an arbitrary player, and call another function
    to handle it. */
-static int net_rec_bid(player_t p)
+static void net_rec_bid(player_t p)
 {
-	int fd = get_player_socket(p);
+	struct dataio *dio = get_player_socket(p);
 	int bid_choice;
 
 	/* Receive the bid index */
-	if (ggz_read_int(fd, &bid_choice) < 0)
-		return -1;
+	dio_get_int(dio, &bid_choice);
 		
 	handle_client_bid(p, bid_choice);
-	return 0;
 }
 
-static int net_rec_options(player_t p)
+static void net_rec_options(player_t p)
 {
-	int fd = get_player_socket(p);
-	int status = 0;
-	int num_options, *options, i;
+	struct dataio *dio = get_player_socket(p);
+	int num_options;
 	
-	if (ggz_read_int(fd, &num_options) < 0
-	    || num_options <= 0)
-		return -1;
-		
-	/* FIXME: this is a major security hole.  */
-	options = ggz_malloc(num_options * sizeof(*options));
+	dio_get_int(dio, &num_options);
+
+	if (num_options > 0) {
+		/* FIXME: this is a major security hole.  */
+		int options[num_options], i;
+
+		for (i = 0; i < num_options; i++)
+			dio_get_int(dio, &options[i]);
 	
-	for (i = 0; i < num_options; i++)
-		if (ggz_read_int(fd, &options[i]) < 0)
-			status = -1;
-	
-	if (status == 0)	
 		handle_client_options(p, num_options, options);
-	ggz_free(options);
-	return status;
+	}
 }
 
 	
 void net_read_player_data(player_t p)
 {
-	int fd = get_player_socket(p);
-	int status = 0;
+	struct dataio *dio = get_player_socket(p);
 	int opcode;
 	client_msg_t op;
 
-	if (read_opcode(fd, &opcode) < 0)
-		NET_ERROR(p);
+	read_opcode(dio, &opcode);
 	op = opcode;
 
 	ggz_debug(DBG_NET, "Received %d (%s) from player %d/%s.",
@@ -597,34 +595,27 @@
 
 	switch (op) {
 	case MSG_LANGUAGE:
-		status = net_rec_language(p);
-		break;
+		net_rec_language(p);
+		return;
 	case RSP_NEWGAME:
-		status = 0;
 		handle_client_newgame(p);
-		break;
+		return;
 	case RSP_OPTIONS:
-		status = net_rec_options(p);
-		break;
+		net_rec_options(p);
+		return;
 	case RSP_BID:
-		status = net_rec_bid(p);
-		break;
+		net_rec_bid(p);
+		return;
 	case RSP_PLAY:
-		status = net_rec_play(p);
-		break;
+		net_rec_play(p);
+		return;
 	case REQ_SYNC:
-		status = 0;
 		handle_client_sync(p);
-		break;
-	default:
-		/* Unrecognized opcode */
-		ggz_debug(DBG_CLIENT,
-			  "game_handle_player: unrecognized opcode %d.",
-			  op);
-		status = -1;
-		break;
+		return;
 	}
 
-	if (status != 0)
-		NET_ERROR(p);
+	/* Unrecognized opcode */
+	ggz_debug(DBG_CLIENT,
+		  "game_handle_player: unrecognized opcode %d.",
+		  op);
 }
Index: common.c
===================================================================
--- common.c	(revision 8192)
+++ common.c	(working copy)
@@ -377,13 +377,15 @@
 		game.players[p].seat = -1;
 		game.players[p].team = -1;
 		game.players[p].allbids = NULL;
-		game.players[p].fd = -1;
+		game.players[p].dio = NULL;
 #ifdef DEBUG
 		game.players[p].err_fd = -1;
 #endif
 		game.players[p].pid = -1;
 	} players_iterate_end;
 
+	game.spectators = NULL;
+
 	/* we don't yet know the number of seats */
 
 	/* As soon as we know which game we're playing, we should init the
@@ -910,25 +912,15 @@
 	return ggzdmod_get_seat(game.ggz, p).type;
 }
 
-int get_player_socket(int p)
+struct dataio *get_player_socket(int p)
 {
 	if (IS_SPECTATOR(p)) {
 		int sp = PLAYER_TO_SPECTATOR(p);
-		return ggzdmod_get_spectator(game.ggz, sp).fd;
-	} else {
-		GGZSeat seat = ggzdmod_get_seat(game.ggz, p);
 
-		switch (seat.type) {
-		case GGZ_SEAT_PLAYER:
-			return seat.fd;
-		case GGZ_SEAT_BOT:
-			return game.players[p].fd;
-		default:
-			return -1;
-		}
+		return game.spectators[sp].dio;
+	} else {
+		return game.players[p].dio;
 	}
-	assert(FALSE);
-	return -1;
 }
 
 /* libggz should handle this instead! */
Index: ai.c
===================================================================
--- ai.c	(revision 8178)
+++ ai.c	(working copy)
@@ -77,7 +77,7 @@
 	ggz_debug(DBG_AI, "Starting AI for player %d as %s.", p, module->name);
 		
 	assert(get_player_status(p) == GGZ_SEAT_BOT);
-	assert(game.players[p].fd == -1);
+	assert(game.players[p].dio == NULL);
 	assert(game.players[p].pid == -1);
 #ifdef DEBUG
 	assert(game.players[p].err_fd == -1);
@@ -123,7 +123,7 @@
 	} else {
 		/* parent */
 		(void) close(fd_pair[1]);
-		game.players[p].fd = fd_pair[0];
+		game.players[p].dio = dio_new(fd_pair[0]);
 		
 #ifdef DEBUG
 		(void) close(err_fd_pair[1]);
@@ -143,7 +143,7 @@
 	/* Check to see if the AI has been spawned yet.  It's much easier to
 	   check here than elsewhere. */
 	if (game.players[p].pid < 0) {
-		assert(game.players[p].fd < 0);
+		assert(game.players[p].dio == NULL);
 #ifdef DEBUG
 		assert(game.players[p].err_fd < 0);
 #endif
@@ -158,14 +158,15 @@
 	game.players[p].pid = -1;
 	
 	/* Clean up FD's. */
-	if (close(game.players[p].fd) < 0
+	if (close(dio_get_socket(game.players[p].dio)) < 0
 #ifdef DEBUG
 	    || close(game.players[p].err_fd) < 0
 #endif
 	   )
 		ggz_error_sys("Close of AI fd's failed (player %d)", p);
-		
-	game.players[p].fd = -1;
+
+	dio_free(game.players[p].dio);
+	game.players[p].dio = NULL;
 #ifdef DEBUG
 	game.players[p].err_fd = -1;
 #endif
Index: client/client.c
===================================================================
--- client/client.c	(revision 8178)
+++ client/client.c	(working copy)
@@ -57,15 +57,15 @@
 
 static void handle_server_connect(int server_fd);
 
-static int handle_message_global(void);
+static void handle_message_global(void);
 
-static int handle_text_message(void);
-static int handle_player_message(void);
-static int handle_cardlist_message(void);
-static int handle_game_message(void);
+static void handle_text_message(void);
+static void handle_player_message(void);
+static void handle_cardlist_message(void);
+static void handle_game_message(void);
 
 static struct {
-	int fd;
+	struct dataio *dio;
 #ifdef GUI_CLIENT
 	GGZMod *ggzmod;
 #endif				/* GUI_CLIENT */
@@ -79,7 +79,7 @@
 
 struct ggzcards_game_t ggzcards = { 0 };
 
-static int handle_req_play(void);
+static void handle_req_play(void);
 
 #ifdef GUI_CLIENT
 GGZMod *client_get_ggzmod(void)
@@ -98,14 +98,11 @@
 
 static void handle_server_connect(int server_fd)
 {
-	game_internal.fd = server_fd;
+	game_internal.dio = dio_new(server_fd);
 
-	if (client_send_language(getenv("LANG")) < 0) {
-		game_internal.fd = -1;
-		ggz_error_msg("Couldn't send message to server.");
-	}
+	client_send_language(getenv("LANG"));
 
-	game_alert_server(game_internal.fd);	/* ?? */
+	game_alert_server(game_internal.dio);	/* ?? */
 }
 
 int client_initialize(void)
@@ -123,7 +120,7 @@
 
 	srand((unsigned)time(NULL));
 
-	game_internal.fd = -1;
+	game_internal.dio = NULL;
 	game_internal.max_hand_size = 0;
 
 	ggzcards.state = STATE_INIT;
@@ -154,7 +151,7 @@
 #ifdef GUI_CLIENT
 	if (ggzmod_disconnect(game_internal.ggzmod) < 0)
 #else /* AI_CLIENT */
-	if (close(game_internal.fd) < 0)
+	if (close(dio_get_socket(game_internal.dio)) < 0)
 #endif
 		ggz_error_msg_exit("Couldn't disconnect from ggz.");
 
@@ -174,9 +171,9 @@
 }
 
 
-int client_get_fd(void)
+struct dataio *client_get_dio(void)
 {
-	return game_internal.fd;
+	return game_internal.dio;
 }
 
 
@@ -214,21 +211,21 @@
 	}
 }
 
-static int handle_text_message(void)
+static void handle_text_message(void)
 {
 	char *message, *mark;
-	if (ggz_read_string_alloc(game_internal.fd, &mark) < 0 ||
-	    ggz_read_string_alloc(game_internal.fd, &message) < 0)
-		return -1;
+
+	dio_get_string_alloc(game_internal.dio, &mark);
+	dio_get_string_alloc(game_internal.dio, &message);
+
 	game_set_text_message(mark, message);
 	ggz_free(message);	/* allocated by easysock */
 	ggz_free(mark);	/* allocated by easysock */
-	return 0;
 }
 
-static int handle_cardlist_message(void)
+static void handle_cardlist_message(void)
 {
-	int status = 0, p, i;
+	int p, i;
 	card_t **cardlist =
 	    ggz_malloc(ggzcards.num_players * sizeof(*cardlist));
 	int *lengths = ggz_malloc(ggzcards.num_players * sizeof(*lengths));
@@ -237,23 +234,18 @@
 	if (!cardlist || !lengths)
 		abort();
 
-	if (ggz_read_string_alloc(game_internal.fd, &mark) < 0)
-		status = -1;
+	dio_get_string_alloc(game_internal.dio, &mark);
 
 	for (p = 0; p < ggzcards.num_players; p++) {
-		if (ggz_read_int(game_internal.fd, &lengths[p]))
-			status = -1;
+		dio_get_int(game_internal.dio, &lengths[p]);
 		if (lengths[p] > 0)
 			cardlist[p] = ggz_malloc(lengths[p]
 						 * sizeof(**cardlist));
 		for (i = 0; i < lengths[p]; i++)
-			if (read_card(game_internal.fd, &cardlist[p][i]) <
-			    0)
-				status = -1;
+			read_card(game_internal.dio, &cardlist[p][i]);
 	}
 
-	if (status == 0)
-		game_set_cardlist_message(mark, lengths, cardlist);
+	game_set_cardlist_message(mark, lengths, cardlist);
 
 	for (p = 0; p < ggzcards.num_players; p++)
 		if (lengths[p] > 0)
@@ -261,27 +253,23 @@
 	ggz_free(cardlist);
 	ggz_free(lengths);
 	ggz_free(mark);	/* allocated by easysock */
-
-	return status;
 }
 
 /* A message_player message tells you one "player message", which is
    displayed by the client. */
-static int handle_player_message(void)
+static void handle_player_message(void)
 {
 	int p;
 	char *message;
 
-	if (read_seat(game_internal.fd, &p) < 0 ||
-	    ggz_read_string_alloc(game_internal.fd, &message) < 0)
-		return -1;
+	read_seat(game_internal.dio, &p);
+	dio_get_string_alloc(game_internal.dio, &message);
+
 	assert(p >= 0 && p < ggzcards.num_players);
 
 	game_set_player_message(p, message);
 
 	ggz_free(message);	/* allocated by easysock */
-
-	return 0;
 }
 
 /* This handles a game-specific message.  We pass the game all the
@@ -294,14 +282,13 @@
    used an XML protocol, things could just sort-of take care of themselves
    because we'd just skip over the tag automatically if it wasn't handled (I
    think). */
-static int handle_game_message(void)
+static void handle_game_message(void)
 {
 	int size, handled;
 	char *game;
 
-	if (ggz_read_string_alloc(game_internal.fd, &game) < 0
-	    || ggz_read_int(game_internal.fd, &size) < 0)
-		return -1;
+	dio_get_string_alloc(game_internal.dio, &game);
+	dio_get_int(game_internal.dio, &size);
 
 	/* Note: "size" refers to the size of the data block, not including
 	   the headers above. */
@@ -309,34 +296,30 @@
 		  "Received game message of size %d for game %s.", size,
 		  game);
 
-	handled = game_handle_game_message(game_internal.fd, game, size);
-	if (handled < 0)
-		return -1;
+	handled = game_handle_game_message(game_internal.dio, game, size);
 	assert(handled <= size);
+#if 0 /* Shouldn't be needed; unused data is skipped automatically. */
 	size -= handled;	/* this is how much was unread */
 
 	if (size > 0) {
 		/* We read the block just to get it out of the way. */
-		char *block = ggz_malloc(size);
-		if (ggz_readn(game_internal.fd, block, size) < 0)
-			return -1;
-		ggz_free(block);
+		char block[size];
+
+		dio_get_memory(game_internal.dio, block, size);
 	}
+#endif
 
 	ggz_free(game);	/* allocated by easysock */
-
-	return 0;
 }
 
 /* a message_global message tells you one "global message", which is
    displayed by the client. */
-static int handle_message_global(void)
+static void handle_message_global(void)
 {
-	int opcode, status = 0;
+	int opcode;
 	game_message_t op;
 
-	if (read_opcode(game_internal.fd, &opcode) < 0)
-		return -1;
+	read_opcode(game_internal.dio, &opcode);
 
 	op = opcode;
 
@@ -345,54 +328,49 @@
 
 	switch (op) {
 	case GAME_MESSAGE_TEXT:
-		status = handle_text_message();
+		handle_text_message();
 		break;
 	case GAME_MESSAGE_CARDLIST:
-		status = handle_cardlist_message();
+		handle_cardlist_message();
 		break;
 	case GAME_MESSAGE_GAME:
-		status = handle_game_message();
+		handle_game_message();
 		break;
 	case GAME_MESSAGE_PLAYER:
-		status = handle_player_message();
+		handle_player_message();
 		break;
 	}
-
-	return status;
 }
 
 
-static int handle_msg_newgame(void)
+static void handle_msg_newgame(void)
 {
 	int cardset;
 	cardset_type_t cardset_type;
 
-	if (ggz_read_int(game_internal.fd, &cardset) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &cardset);
+
 	cardset_type = cardset;
 
 	assert(cardset_type != UNKNOWN_CARDSET);
 	set_cardset_type(cardset_type);
 	game_alert_newgame(cardset_type);
-	return 0;
 }
 
 
 /* A gameover message tells you the game is over, and who won. */
-static int handle_msg_gameover(void)
+static void handle_msg_gameover(void)
 {
 	int num_winners, i, *winners = NULL;
 
-	if (ggz_read_int(game_internal.fd, &num_winners) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &num_winners);
 	assert(num_winners >= 0 && num_winners <= ggzcards.num_players);
 
 	if (num_winners > 0)
 		winners = ggz_malloc(num_winners * sizeof(*winners));
 
 	for (i = 0; i < num_winners; i++)
-		if (read_seat(game_internal.fd, &winners[i]) < 0)
-			return -1;
+		read_seat(game_internal.dio, &winners[i]);
 
 	game_handle_gameover(num_winners, winners);
 
@@ -400,14 +378,12 @@
 
 	if (winners)
 		ggz_free(winners);
-
-	return 0;
 }
 
 
 /* A players message tells you all the players (well, seats really) at the
    table. */
-static int handle_msg_players(void)
+static void handle_msg_players(void)
 {
 	int i, numplayers, different;
 	int old_numplayers = ggzcards.num_players;
@@ -415,8 +391,8 @@
 	/* It is possible to have 0 players.  At the begginning of a
 	   "general" game, you don't know how many seats will be used yet so
 	   the number of players is 0. */
-	if (ggz_read_int(game_internal.fd, &numplayers) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &numplayers);
+
 	assert(numplayers >= 0);
 
 	/* we may need to allocate memory for the players */
@@ -457,11 +433,10 @@
 		GGZSeatType old_type, new_type;
 		char *old_name, *new_name;
 
-		if (ggz_read_int(game_internal.fd, &type) < 0
-		    || ggz_read_string_alloc(game_internal.fd,
-					     &new_name) < 0
-		    || ggz_read_int(game_internal.fd, &ggzseat) < 0)
-			return -1;
+		dio_get_int(game_internal.dio, &type);
+		dio_get_string_alloc(game_internal.dio, &new_name);
+		dio_get_int(game_internal.dio, &ggzseat);
+
 		new_type = type;
 
 		old_name = ggzcards.players[i].name;
@@ -490,8 +465,6 @@
 	}
 
 	/* TODO: should we need to enter a waiting state if players leave? */
-
-	return 0;
 }
 
 /* Possibly increase the maximum hand size we can sustain. */
@@ -527,7 +500,7 @@
 }
 
 /* A hand message tells you all the cards in one player's hand. */
-static int handle_msg_hand(void)
+static void handle_msg_hand(void)
 {
 	int player, hand_size, i;
 	hand_t *hand;
@@ -535,13 +508,12 @@
 	assert(ggzcards.players);
 
 	/* first read the player whose hand it is */
-	if (read_seat(game_internal.fd, &player) < 0)
-		return -1;
+	read_seat(game_internal.dio, &player);
+
 	assert(player >= 0 && player < ggzcards.num_players);
 
 	/* Find out how many cards in this hand */
-	if (ggz_read_int(game_internal.fd, &hand_size) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &hand_size);
 
 	/* Reallocate hand structures, if necessary */
 	increase_max_hand_size(hand_size);
@@ -554,8 +526,7 @@
 	ggzcards.players[player].u_hand_size = hand_size;
 	for (i = 0; i < hand->hand_size; i++) {
 		card_t card;
-		if (read_card(game_internal.fd, &card) < 0)
-			return -1;
+		read_card(game_internal.dio, &card);
 
 		hand->cards[i] = card;
 
@@ -569,13 +540,11 @@
 
 	/* Finally, show the hand. */
 	game_display_hand(player);
-
-	return 0;
 }
 
 
 /* A bid request asks you to pick from a given list of bids. */
-static int handle_req_bid(void)
+static void handle_req_bid(void)
 {
 	int i;
 	int possible_bids;
@@ -591,20 +560,17 @@
 	}
 
 	/* Determine the number of bidding choices we have */
-	if (ggz_read_int(game_internal.fd, &possible_bids) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &possible_bids);
+
 	bid_choices = ggz_malloc(possible_bids * sizeof(*bid_choices));
 	bid_texts = ggz_malloc(possible_bids * sizeof(*bid_texts));
 	bid_descs = ggz_malloc(possible_bids * sizeof(*bid_descs));
 
 	/* Read in all of the bidding choices. */
 	for (i = 0; i < possible_bids; i++) {
-		if (read_bid(game_internal.fd, &bid_choices[i]) < 0 ||
-		    ggz_read_string_alloc(game_internal.fd,
-					  &bid_texts[i]) < 0 ||
-		    ggz_read_string_alloc(game_internal.fd,
-					  &bid_descs[i]) < 0)
-			return -1;
+		read_bid(game_internal.dio, &bid_choices[i]);
+		dio_get_string_alloc(game_internal.dio, &bid_texts[i]);
+		dio_get_string_alloc(game_internal.dio, &bid_descs[i]);
 	}
 
 	/* Get the bid */
@@ -619,42 +585,35 @@
 	ggz_free(bid_choices);
 	ggz_free(bid_texts);
 	ggz_free(bid_descs);
-
-	return 0;
 }
 
 
-static int handle_msg_bid(void)
+static void handle_msg_bid(void)
 {
 	bid_t bid;
 	int bidder;
 
-	if (read_seat(game_internal.fd, &bidder) < 0 ||
-	    read_bid(game_internal.fd, &bid) < 0)
-		return -1;
+	read_seat(game_internal.dio, &bidder);
+	read_bid(game_internal.dio, &bid);
 
 	game_alert_bid(bidder, bid);
-
-	return 0;
 }
 
 
 /* A play request asks you to play a card from any hand (most likely your
    own). */
-static int handle_req_play(void)
+static void handle_req_play(void)
 {
 	int num_valid_cards, i;
 	card_t *valid_cards;
 
 	/* Determine which hand we're supposed to be playing from. */
-	if (read_seat(game_internal.fd, &ggzcards.play_hand) < 0 ||
-	    ggz_read_int(game_internal.fd, &num_valid_cards) < 0)
-		return -1;
+	read_seat(game_internal.dio, &ggzcards.play_hand);
+	dio_get_int(game_internal.dio, &num_valid_cards);
 
 	valid_cards = ggz_malloc(num_valid_cards * sizeof(*valid_cards));
 	for (i = 0; i < num_valid_cards; i++)
-		if (read_card(game_internal.fd, &valid_cards[i]) < 0)
-			return -1;
+		read_card(game_internal.dio, &valid_cards[i]);
 
 	assert(ggzcards.play_hand >= 0
 	       && ggzcards.play_hand < ggzcards.num_players);
@@ -664,19 +623,16 @@
 	game_get_play(ggzcards.play_hand, num_valid_cards, valid_cards);
 
 	ggz_free(valid_cards);
-
-	return 0;
 }
 
 
 /* A badplay message indicates an invalid play, and requests a new one. */
-static int handle_msg_badplay(void)
+static void handle_msg_badplay(void)
 {
 	char *err_msg;
 
 	/* Read the error message for the bad play. */
-	if (ggz_read_string_alloc(game_internal.fd, &err_msg) < 0)
-		return -1;
+	dio_get_string_alloc(game_internal.dio, &err_msg);
 
 	/* Get a new play. */
 	set_game_state(STATE_PLAY);
@@ -684,8 +640,6 @@
 
 	/* Clean up. */
 	ggz_free(err_msg);	/* allocated by easysock */
-
-	return 0;
 }
 
 
@@ -743,16 +697,15 @@
 
 
 /* A play message tells of a play from a hand to the table. */
-static int handle_msg_play(void)
+static void handle_msg_play(void)
 {
 	int p, c, tc, card_pos, card_pos_2;
 	card_t card;
 	hand_t *hand;
 
 	/* Read the card being played. */
-	if (read_seat(game_internal.fd, &p) < 0
-	    || read_card(game_internal.fd, &card) < 0)
-		return -1;
+	read_seat(game_internal.dio, &p);
+	read_card(game_internal.dio, &card);
 
 	assert(p >= 0 && p < ggzcards.num_players);
 
@@ -794,7 +747,6 @@
 		ggz_debug(DBG_CLIENT,
 			  "Whoa!  We can't find a match for the card.  That's strange.");
 		(void)client_send_sync_request();
-		return 0;
 	}
 
 	/* Remove the card.  This is a bit inefficient. It's also
@@ -818,14 +770,12 @@
 
 	/* Update the graphics */
 	game_alert_play(p, card, card_pos, card_pos_2);
-
-	return 0;
 }
 
 
 /* A table message tells you all the cards on the table.  Each player only
    gets one card. */
-static int handle_msg_table(void)
+static void handle_msg_table(void)
 {
 	int p;
 
@@ -834,8 +784,7 @@
 	assert(ggzcards.players);
 	for (p = 0; p < ggzcards.num_players; p++) {
 		card_t card;
-		if (read_card(game_internal.fd, &card) < 0)
-			return -1;
+		read_card(game_internal.dio, &card);
 		ggzcards.players[p].table_card = card;
 	}
 
@@ -843,19 +792,17 @@
 	 */
 
 	game_alert_table();
-
-	return 0;
 }
 
 
 /* A trick message tells you about the end of a trick (and who won). */
-static int handle_msg_trick(void)
+static void handle_msg_trick(void)
 {
 	int winner, p;
 
 	/* Read the trick winner */
-	if (read_seat(game_internal.fd, &winner) < 0)
-		return -1;
+	read_seat(game_internal.dio, &winner);
+
 	assert(winner >= 0 && winner < ggzcards.num_players);
 
 	/* Clear all cards off the table. */
@@ -864,15 +811,13 @@
 
 	/* Update the graphics. */
 	game_alert_trick(winner);
-
-	return 0;
 }
 
 
 /* An options request asks you to pick a set of options.  Each "option" gives
    a list of choices so that you pick one choice for each option.  An option
    with only one choice is a special case: a boolean option. */
-static int handle_req_options(void)
+static void handle_req_options(void)
 {
 	int i, j;
 	int option_cnt;		/* the number of options */
@@ -891,8 +836,8 @@
 	}
 
 	/* Read the number of options. */
-	if (ggz_read_int(game_internal.fd, &option_cnt) < 0)
-		return -1;
+	dio_get_int(game_internal.dio, &option_cnt);
+
 	assert(option_cnt > 0);
 
 	/* Allocate all data */
@@ -903,17 +848,15 @@
 
 	/* Read all the options, their defaults, and the possible choices. */
 	for (i = 0; i < option_cnt; i++) {
-		if (ggz_read_string_alloc(game_internal.fd, &descs[i]) < 0
-		    || ggz_read_int(game_internal.fd, &choice_cnt[i]) < 0
-		    || ggz_read_int(game_internal.fd, &defaults[i]) < 0)
-			return -1;	/* read the default */
+		dio_get_string_alloc(game_internal.dio, &descs[i]);
+		dio_get_int(game_internal.dio, &choice_cnt[i]);
+		dio_get_int(game_internal.dio, &defaults[i]);
+
 		option_choices[i] =
 		    ggz_malloc(choice_cnt[i] * sizeof(**option_choices));
 		for (j = 0; j < choice_cnt[i]; j++)
-			if (ggz_read_string_alloc
-			    (game_internal.fd, &option_choices[i][j])
-			    < 0)
-				return -1;
+			dio_get_string_alloc(game_internal.dio,
+					     &option_choices[i][j]);
 	}
 
 	/* Get the options. */
@@ -935,13 +878,11 @@
 	ggz_free(option_choices);
 	ggz_free(choice_cnt);
 	ggz_free(descs);
-
-	return 0;
 }
 
 
 /* The language lets the server translate messages for us. */
-int client_send_language(const char *lang)
+void client_send_language(const char *lang)
 {
 	if (!lang) {
 		lang = "";
@@ -949,82 +890,70 @@
 
 	ggz_debug(DBG_CLIENT, "Sending language %s to the server.", lang);
 
-	if (write_opcode(game_internal.fd, MSG_LANGUAGE) < 0 ||
-	    ggz_write_string(game_internal.fd, lang) < 0)
-		return -1;
-
-	return 0;
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, MSG_LANGUAGE);
+	dio_put_string(game_internal.dio, lang);
+	dio_end_packet(game_internal.dio);
 }
 
 
 /* A newgame message tells the server to start a new game. */
-int client_send_newgame(void)
+void client_send_newgame(void)
 {
-	if (write_opcode(game_internal.fd, RSP_NEWGAME) < 0) {
-		ggz_error_msg("Couldn't send newgame.");
-		return -1;
-	}
-	return 0;
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, RSP_NEWGAME);
+	dio_end_packet(game_internal.dio);
 }
 
 
 /* A bid message tells the server our choice for a bid. */
-int client_send_bid(int bid)
+void client_send_bid(int bid)
 {
 	set_game_state(STATE_WAIT);
-	if (write_opcode(game_internal.fd, RSP_BID) < 0
-	    || ggz_write_int(game_internal.fd, bid) < 0) {
-		ggz_error_msg("Couldn't send bid.");
-		return -1;
-	}
-	return 0;
+
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, RSP_BID);
+	dio_put_int(game_internal.dio, bid);
+	dio_end_packet(game_internal.dio);
 }
 
 
 /* An options message tells the server our choices for options. */
-int client_send_options(int option_cnt, int *options)
+void client_send_options(int option_cnt, int *options)
 {
-	int i, status = 0;
+	int i;
 
-	if (write_opcode(game_internal.fd, RSP_OPTIONS) < 0 ||
-	    ggz_write_int(game_internal.fd, option_cnt) < 0)
-		status = -1;
-	for (i = 0; i < option_cnt; i++)
-		if (ggz_write_int(game_internal.fd, options[i]) < 0)
-			status = -1;
-
 	set_game_state(STATE_WAIT);
 
-	if (status < 0) {
-		ggz_error_msg("Couldn't send options.");
-		return -1;
-	}
-	return status;
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, RSP_OPTIONS);
+	dio_put_int(game_internal.dio, option_cnt);
+	for (i = 0; i < option_cnt; i++)
+		dio_put_int(game_internal.dio, options[i]);
+	dio_end_packet(game_internal.dio);
 }
 
 
 /* A play message tells the server our choice for a play. */
-int client_send_play(card_t card)
+void client_send_play(card_t card)
 {
 	set_game_state(STATE_WAIT);
-	if (write_opcode(game_internal.fd, RSP_PLAY) < 0
-	    || write_card(game_internal.fd, card) < 0) {
-		ggz_error_msg("Couldn't send play.");
-		return -1;
-	}
-	return 0;
+
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, RSP_PLAY);
+	write_card(game_internal.dio, card);
+	dio_end_packet(game_internal.dio);
 }
 
 
 /* A sync request asks for a sync from the server. */
-int client_send_sync_request(void)
+void client_send_sync_request(void)
 {
 	ggz_debug(DBG_CLIENT, "Sending sync request to server.");
-	if (write_opcode(game_internal.fd, REQ_SYNC) < 0) {
-		ggz_error_msg("Couldn't send sync request.");
-		return -1;
-	}
-	return 0;
+
+	dio_start_packet(game_internal.dio);
+	write_opcode(game_internal.dio, REQ_SYNC);
+	dio_end_packet(game_internal.dio);
 }
 
 #ifdef GUI_CLIENT
@@ -1034,17 +963,14 @@
 }
 #endif
 
-/* This function handles any input from the server. */
-int client_handle_server(void)
+static void server_read_callback(struct dataio *dio)
 {
-	int opcode, status = -1;
+	int opcode;
 	server_msg_t op;
 
 	/* Read the opcode */
-	if (read_opcode(game_internal.fd, &opcode) < 0) {
-		ggz_error_msg("Couldn't read server opcode.");
-		return -1;
-	}
+	read_opcode(game_internal.dio, &opcode);
+
 	op = opcode;
 
 	ggz_debug(DBG_CLIENT, "Received %s opcode from the server.",
@@ -1054,56 +980,58 @@
 	case REQ_NEWGAME:
 		game_get_newgame();
 		ggzcards.play_hand = -1;
-		status = 0;
-		break;
+		return;
 	case MSG_NEWGAME:
 		/* TODO: don't make "new game" until here */
-		status = handle_msg_newgame();
-		break;
+		handle_msg_newgame();
+		return;
 	case MSG_GAMEOVER:
-		status = handle_msg_gameover();
-		break;
+		handle_msg_gameover();
+		return;
 	case MSG_PLAYERS:
-		status = handle_msg_players();
-		break;
+		handle_msg_players();
+		return;
 	case MSG_NEWHAND:
 		game_alert_newhand();
-		status = 0;
-		break;
+		return;
 	case MSG_HAND:
-		status = handle_msg_hand();
-		break;
+		handle_msg_hand();
+		return;
 	case REQ_BID:
-		status = handle_req_bid();
-		break;
+		handle_req_bid();
+		return;
 	case MSG_BID:
-		status = handle_msg_bid();
-		break;
+		handle_msg_bid();
+		return;
 	case REQ_PLAY:
-		status = handle_req_play();
-		break;
+		handle_req_play();
+		return;
 	case MSG_BADPLAY:
-		status = handle_msg_badplay();
-		break;
+		handle_msg_badplay();
+		return;
 	case MSG_PLAY:
-		status = handle_msg_play();
-		break;
+		handle_msg_play();
+		return;
 	case MSG_TABLE:
-		status = handle_msg_table();
-		break;
+		handle_msg_table();
+		return;
 	case MSG_TRICK:
-		status = handle_msg_trick();
-		break;
+		handle_msg_trick();
+		return;
 	case MESSAGE_GAME:
-		status = handle_message_global();
-		break;
+		handle_message_global();
+		return;
 	case REQ_OPTIONS:
-		status = handle_req_options();
-		break;
+		handle_req_options();
+		return;
 	}
 
-	if (status < 0)
-		ggz_error_msg("Error handling message"
-			      " from server (opcode %d).", op);
-	return status;
+	ggz_error_msg("Error handling message"
+		      " from server (opcode %d).", op);
 }
+
+/* This function handles any input from the server. */
+int client_handle_server(void)
+{
+	return dio_read_data(game_internal.dio, server_read_callback);
+}
Index: client/client.h
===================================================================
--- client/client.h	(revision 8178)
+++ client/client.h	(working copy)
@@ -162,7 +162,7 @@
 /** This function will return the file descriptor that is used to communicate
  *  with the server.
  */
-int client_get_fd(void);
+struct dataio *client_get_dio(void);
 
 /** @} end of Setup */
 
@@ -175,7 +175,7 @@
 
 /** Handles an update of the server socket.  This will only happen once, when
  *  we first connect to the server. */
-extern void game_alert_server(int server_socket_fd);
+extern void game_alert_server(struct dataio *dio);
 
 /** Handles a newgame request by calling client_send_newgame when
  *  ready (you may wish to ask the user first). */
@@ -321,7 +321,8 @@
  *  @param size The amount of data ready to be read.
  *  @return The number of bytes read, or negative for error.
  *  @note When in doubt, just use "return 0". */
-extern int game_handle_game_message(int fd, const char *game, int size);
+extern int game_handle_game_message(struct dataio *dio,
+				    const char *game, int size);
 
 /** @} end of Callbacks */
 
@@ -332,35 +333,35 @@
  *  @{ */
 
 /** Sends the language to the server. */
-int client_send_language(const char *lang);
+void client_send_language(const char *lang);
 
 /** Sends a simple newgame response.
  *  @return 0 on success, -1 on failure.
  *  @see game_get_newgame */
-int client_send_newgame(void);
+void client_send_newgame(void);
 
 /** Sends a bid response.
  *  @param bid The index of the bid chosen.
  *  @return 0 on success, -1 on failure
  *  @see game_get_bid */
-int client_send_bid(int bid);
+void client_send_bid(int bid);
 
 /** Sends an options response.
  *  @param option_cnt The number of options.
  *  @param options The choice made for each option.
  *  @return 0 on success, -1 on failure
  *  @see game_get_options */
-int client_send_options(int option_cnt, int *options);
+void client_send_options(int option_cnt, int *options);
 
 /** Sends a play response.
  *  @param card The card chosen to be played.
  *  @return 0 on success, -1 on failure
  *  @see game_get_play, game_alert_badplay */
-int client_send_play(card_t card);
+void client_send_play(card_t card);
 
 /** Sends a request for a sync.
  *  @return 0 on success, -1 on failure. */
-int client_send_sync_request(void);
+void client_send_sync_request(void);
 
 /** @} end of Responses */
 
Index: common.h
===================================================================
--- common.h	(revision 8178)
+++ common.h	(working copy)
@@ -138,6 +138,7 @@
 	int num_players;	/**< the number of players in the game */
 	int player_count;	/**< the number of human players who have joined, in total */
 	struct game_player_t *players;	/**< data for each player, allocated in game_init */
+	struct game_spectator_t *spectators; /**< data for each spectator. */
 
 	/* table data: seats */
 	int num_seats;	/**< the number of "seats" in the table (which includes fake non-players */
@@ -214,7 +215,7 @@
 
 const char* get_player_name(player_t p);
 GGZSeatType get_player_status(player_t p);
-int get_player_socket(int p);
+struct dataio *get_player_socket(int p);
 
 bool seats_full(void);
 bool seats_empty(void);
