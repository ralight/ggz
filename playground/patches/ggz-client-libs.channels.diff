? a.out
? channel.xml
? channels.diff
? socketpair.diff
? stats.diff
? win32.diff
? ggzcore/highscore.diff
Index: ggzcore/game.c
===================================================================
RCS file: /var/lib/cvs/ggz/src/ggzcore/game.c,v
retrieving revision 1.36
diff -u -r1.36 game.c
--- ggzcore/game.c	18 Jan 2005 02:51:57 -0000	1.36
+++ ggzcore/game.c	18 Jan 2005 06:14:32 -0000
@@ -231,13 +231,6 @@
 }   
 
 
-void ggzcore_game_set_server_fd(GGZGame *game, unsigned int fd)
-{
-	if (game)
-		return _ggzcore_game_set_server_fd(game, fd);
-}
-
-
 GGZModule* ggzcore_game_get_module(GGZGame *game)
 {
 	if (game)
@@ -296,6 +289,10 @@
 	/* Setup client module connection */
 	game->client = ggzmod_new(GGZMOD_GGZ);
 	ggzmod_set_gamedata(game->client, game);
+	ggzmod_set_server_host(game->client,
+			       ggzcore_server_get_host(server),
+			       ggzcore_server_get_port(server),
+			       ggzcore_server_get_handle(server));
 	ggzmod_set_handler(game->client, GGZMOD_EVENT_STATE,
 			   &_ggzcore_game_handle_state);
 	ggzmod_set_transaction_handler(game->client,
@@ -653,12 +650,6 @@
 	}
 
 	return status;
-}
-
-
-void _ggzcore_game_set_server_fd(struct _GGZGame *game, int fd)
-{
-	ggzmod_set_server_fd(game->client, fd);
 }
 
 
Index: ggzcore/ggzcore-ggz.h
===================================================================
RCS file: ggzcore/ggzcore-ggz.h
diff -N ggzcore/ggzcore-ggz.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ggzcore/ggzcore-ggz.h	18 Jan 2005 06:14:32 -0000
@@ -0,0 +1,39 @@
+/* 
+ * File: ggzcore-ggz.h
+ * Author: GGZ Dev Team
+ * Project: ggzcore
+ * Date: 01/16/2005
+ * Desc: GGZ client<->server network connection (GGZ side)
+ * $Id: ggz-client-libs.channels.diff 6756 2005-01-20 03:05:53Z jdorje $
+ *
+ * This file contains the GGZ-only interface for the ggzcore library.  This
+ * library facilitates the communication between the GGZ server (ggzd)
+ * and GGZ client.  The functions provided in this file are intended for use
+ * inside ggzmod.
+ *
+ * Copyright (C) 2005 GGZ Development Team.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+
+
+#ifndef __GGZCORE_GGZ_H__
+#define __GGZCORE_GGZ_H__
+
+/* Returns the socket FD, or -1 */
+int ggzcore_channel_connect(const char *host, unsigned int port,
+			    const char *handle);
+
+#endif /* __GGZCORE_GGZ_H__ */
Index: ggzcore/ggzcore.h
===================================================================
RCS file: /var/lib/cvs/ggz/src/ggzcore/ggzcore.h,v
retrieving revision 1.133
diff -u -r1.133 ggzcore.h
--- ggzcore/ggzcore.h	17 Jan 2005 03:36:17 -0000	1.133
+++ ggzcore/ggzcore.h	18 Jan 2005 06:14:33 -0000
@@ -720,19 +720,8 @@
  */
 int          ggzcore_server_get_fd(GGZServer *server);
 
-
-/** @brief Get the socket used for direct gane connections
- *
- *  This returns the file descriptor of the socket for
- *  the TCP game connection.  This will be handed off to a game module 
- *  when it is ready.
- *
- *  @param server The GGZ server object.
- *  @return The file descriptor of the connection socket.
- *  @see ggzcore_server_create_channel
- */
-int ggzcore_server_get_channel(GGZServer *server);
-
+/** @brief Deprecated function.  Do not use. */
+#define ggzcore_server_get_channel(server) (-1)
 
 /** @brief Get the state of the server connection.
  *
@@ -815,16 +804,8 @@
  */
 int ggzcore_server_connect(GGZServer *server);
 
-/** @brief Establish a direct connection.
- *
- *  Direct connections are requested for games. They are similar to
- *  connections, instead of that no login takes place, but a channel for
- *  arbitrary game data is created.
- *
- *  @param server The GGZ server object.
- *  @return 0 on success, -1 on failure.
- */
-int ggzcore_server_create_channel(GGZServer *server);
+/** @brief Deprecated function.  Do not use. */
+#define ggzcore_server_create_channel(server) (void)0
 
 /** @brief Log in to the server.
  *
@@ -1469,8 +1450,8 @@
 /** @brief Return the control (ggzmod) socket for the game. */
 int  ggzcore_game_get_control_fd(GGZGame *game);
 
-/** @brief Return the game's server socket. */
-void ggzcore_game_set_server_fd(GGZGame *game, unsigned int fd);
+/** @brief Deprecated function.  Do not use. */
+#define ggzcore_game_set_server_fd(game, fd) (void)0
 
 /** @brief Return the module set for the game. */
 GGZModule* ggzcore_game_get_module(GGZGame *game);
Index: ggzcore/server.c
===================================================================
RCS file: /var/lib/cvs/ggz/src/ggzcore/server.c,v
retrieving revision 1.80
diff -u -r1.80 server.c
--- ggzcore/server.c	17 Jan 2005 23:35:49 -0000	1.80
+++ ggzcore/server.c	18 Jan 2005 06:14:33 -0000
@@ -40,6 +40,8 @@
 #include <ggz.h>
 
 #include "ggzcore.h"
+#include "ggzcore-ggz.h"
+
 #include "hook.h"
 #include "net.h"
 #include "player.h"
@@ -111,8 +113,11 @@
 	/* Current game on game server */
 	GGZGame *game;
 
-	/* Game communications channel */
-	GGZNet *channel;	
+	/* Whether this is a primary ggzcore server connection or a
+	 * channel. */
+	int is_channel;
+	int channel_complete;
+	int channel_failed;
 
        	/* Callbacks for server events.  Every time an event happens all the
 	 * hooks in the list for that event are called. */
@@ -318,15 +323,6 @@
 }
 
 
-int ggzcore_server_get_channel(GGZServer *server)
-{
-	if (server && server->channel)
-		return _ggzcore_net_get_fd(server->channel);
-	else
-		return -1;
-}
-
-
 GGZStateID ggzcore_server_get_state(GGZServer *server)
 {
 	if (server)
@@ -457,16 +453,6 @@
 }
 
 
-int ggzcore_server_create_channel(GGZServer *server)
-{
-	if (server && server->net && server->state == GGZ_STATE_IN_ROOM) {
-		return _ggzcore_server_create_channel(server);
-	}
-	else
-		return -1;
-}
-
-
 int ggzcore_server_login(GGZServer *server)
 {
 	/* Return nothing if we didn't get the necessary info */
@@ -556,24 +542,25 @@
 {
 	int status = -1;
 
-	if (!server)
+	if (!server || !server->net
+	    || (fd = _ggzcore_net_get_fd(server->net)) < 0)
 		return -1;
 
-	if (server->net && fd == _ggzcore_net_get_fd(server->net)) {
-		if (server->state != GGZ_STATE_OFFLINE) {
-			status = _ggzcore_net_read_data(server->net);
-
-			/* See comment in
-			 * ggzcore_server_queue_players_changed. */
-			if (server->queued_events.players_changed) {
-				_ggzcore_server_event(server,
-					GGZ_SERVER_PLAYERS_CHANGED, NULL);
-				server->queued_events.players_changed = 0;
-			}
+	if (server->state != GGZ_STATE_OFFLINE) {
+		status = _ggzcore_net_read_data(server->net);
+
+		/* See comment in
+		 * ggzcore_server_queue_players_changed. */
+		if (server->queued_events.players_changed) {
+			_ggzcore_server_event(server,
+				GGZ_SERVER_PLAYERS_CHANGED, NULL);
+			server->queued_events.players_changed = 0;
 		}
-	} else if (server->channel
-		   && fd == _ggzcore_net_get_fd(server->channel)) {
-		status = _ggzcore_net_read_data(server->channel);
+	} else {
+		/* If we *don't* return an error here, the caller is likely
+		 * to just keep calling this function again and again
+		 * because no data will ever be read. */
+		return -1;
 	}
 
 	return 0;
@@ -775,12 +762,13 @@
 void _ggzcore_server_set_negotiate_status(GGZServer *server, GGZNet *net,
 					  GGZClientReqError status)
 {
-	if (net == server->net)
+	if (net != server->net) {
+		_ggzcore_server_net_error(server, "Unknown negotation");
+	} else if (server->is_channel == 0) {
 		_ggzcore_server_main_negotiate_status(server, status);
-	else if (net == server->channel)
+	} else {
 		_ggzcore_server_channel_negotiate_status(server, status);
-	else
-		_ggzcore_server_net_error(server, "Unknown negotation");
+	}
 }
 
 
@@ -911,14 +899,16 @@
 
 void _ggzcore_server_session_over(GGZServer *server, GGZNet *net)
 {
-	if (net == server->net) {
+	if (net != server->net) return;
+	if (server->is_channel == 0) {
 		/* Server is ending session */
 		_ggzcore_net_disconnect(net);
 		_ggzcore_server_change_state(server, GGZ_TRANS_LOGOUT_OK);
 		_ggzcore_server_event(server, GGZ_LOGOUT, NULL);
-	}
-	else if (net == server->channel) {
-		_ggzcore_server_event(server, GGZ_CHANNEL_READY, NULL);
+	} else {
+		/* Channel is ready! */
+		_ggzcore_server_change_state(server, GGZ_TRANS_LOGOUT_OK);
+		server->channel_complete = 1;
 	}
 }
 
@@ -942,6 +932,8 @@
 	/* Allocate network object */
 	server->net = _ggzcore_net_new();
 
+	server->is_channel = 0;
+
 	/* Setup event hook lists */
 	for (i = 0; i < GGZ_NUM_SERVER_EVENTS; i++)
 		server->event_hooks[i] = _ggzcore_hook_list_init(i);
@@ -976,41 +968,66 @@
 }
 
 
-int _ggzcore_server_create_channel(GGZServer *server)
+int ggzcore_channel_connect(const char *host, unsigned int port,
+			    const char *handle)
 {
-	int status;
-	const char *host;
-	unsigned int port;
-	char *errmsg;
-	
-	/* FIXME: make sure we don't already have a channel */
-	server->channel = _ggzcore_net_new();
-	host = _ggzcore_net_get_host(server->net);
-	port = _ggzcore_net_get_port(server->net);
-	_ggzcore_net_init(server->channel, server, host, port, 0);
-	status = _ggzcore_net_connect(server->channel);
-	
-	if (status < 0) {
-		ggz_debug(GGZCORE_DBG_SERVER, "Channel creation failed");
-		if(status == -1) errmsg = strerror(errno);
-		else {
-#ifdef HAVE_HSTRERROR
-			errmsg = (char*)hstrerror(h_errno);
-#else
-			/* Not all systems have hstrerror. */
-			errmsg = "Unable to connect";
-#endif
-		}
-		_ggzcore_server_event(server, GGZ_CHANNEL_FAIL, errmsg);
-	}
-	else {
-		ggz_debug(GGZCORE_DBG_SERVER, "Channel created");
-		_ggzcore_server_event(server, GGZ_CHANNEL_CONNECTED, NULL);
+	GGZServer *server;
+	int fd;
+
+	/* Hack, hack, hack.  The below really needs to be fixed up with some
+	 * error handling.  There's also a major problem that it blocks the
+	 * whole time while the connection is being made. */
+	server = ggzcore_server_new();
+	ggzcore_server_log_session(server, "channel.xml");
+	server->is_channel = 1;
+	server->channel_complete = server->channel_failed = 0;
+	if (ggzcore_server_set_hostinfo(server, host, port, 0) < 0
+	    || ggzcore_server_set_logininfo(server, GGZ_LOGIN_GUEST,
+					    handle, NULL) < 0) {
+		ggzcore_server_free(server);
+		return -1;
 	}
 
-	return status;
-}
+	if (_ggzcore_server_connect(server) < 0) {
+		ggzcore_server_free(server);
+		return -1;
+	}
+	fd = _ggzcore_net_get_fd(server->net);
+
+	while (1) {
+		fd_set active_fd_set;
+		int status;
+		struct timeval timeout = {.tv_sec = 30, .tv_usec = 0};
+
+		FD_ZERO(&active_fd_set);
+		FD_SET(fd, &active_fd_set);
+
+		status = select(fd + 1, &active_fd_set, NULL, NULL, &timeout);
+		if (status < 0) {
+			if (errno == EINTR) continue;
+			ggzcore_server_free(server);
+			return -1;
+		} else if (status == 0) {
+			/* Timed out. */
+			return -1;
+		} else if (status > 0 && FD_ISSET(fd, &active_fd_set)) {
+			if (ggzcore_server_read_data(server, fd) < 0) {
+				return -1;
+			}
+		}
 
+		if (server->channel_complete != 0) {
+			/* Set the socket to -1 so we don't
+			 * accidentally close it. */
+			_ggzcore_net_set_fd(server->net, -1);
+			ggzcore_server_free(server);
+			return fd;
+		} else if (server->channel_failed != 0) {
+			ggzcore_server_free(server);
+			return -1;
+		}
+	}
+}
 			    
 int _ggzcore_server_login(GGZServer *server)
 {
@@ -1166,12 +1183,12 @@
 	int fd;
 	
 	if (status == E_OK) {
-		fd = _ggzcore_net_get_fd(server->channel);
-		_ggzcore_net_send_channel(server->channel, server->handle);
-		_ggzcore_net_send_logout(server->channel);
+		fd = _ggzcore_net_get_fd(server->net);
+		_ggzcore_net_send_channel(server->net, server->handle);
+		_ggzcore_net_send_logout(server->net);
 	}
 	else {
-		_ggzcore_server_event(server, GGZ_CHANNEL_FAIL, "Protocol mismatch");
+		server->channel_failed = 1;
 	}
 }
 
@@ -1288,6 +1305,9 @@
 {
 	_ggzcore_server_change_state(server, GGZ_TRANS_NET_ERROR);
 	_ggzcore_server_event(server, GGZ_NET_ERROR, message);
+	if (server->is_channel) {
+		server->channel_failed = 1;
+	}
 }
 
 
@@ -1297,6 +1317,9 @@
 	_ggzcore_net_disconnect(server->net);
 	_ggzcore_server_change_state(server, GGZ_TRANS_PROTO_ERROR);
 	_ggzcore_server_event(server, GGZ_PROTOCOL_ERROR, message);
+	if (server->is_channel) {
+		server->channel_failed = 1;
+	}
 }
 
 
Index: ggzmod/Makefile.am
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/Makefile.am,v
retrieving revision 1.15
diff -u -r1.15 Makefile.am
--- ggzmod/Makefile.am	22 Dec 2004 16:38:28 -0000	1.15
+++ ggzmod/Makefile.am	18 Jan 2005 06:14:33 -0000
@@ -15,9 +15,9 @@
 
 include_HEADERS = ggzmod.h ggzmod-ggz.h
 
-libggzmod_la_LIBADD = $(LIB_GGZ)
+libggzmod_la_LIBADD = $(LIB_GGZ) $(top_builddir)/ggzcore/libggzcore.la
 libggzmod_la_LDFLAGS = $(LIBGGZ_LDFLAGS) -version-info 2:0:1
 
-AM_CPPFLAGS = $(LIBGGZ_INCLUDES)
+AM_CPPFLAGS = $(LIBGGZ_INCLUDES) -I$(top_srcdir)/ggzcore
 
 #libggz_la_LDFLAGS = -version-info @GGZ_CLIENT_LIBS_VERSION_INFO@
Index: ggzmod/ggzmod-ggz.h
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/ggzmod-ggz.h,v
retrieving revision 1.4
diff -u -r1.4 ggzmod-ggz.h
--- ggzmod/ggzmod-ggz.h	17 Jul 2004 22:45:57 -0000	1.4
+++ ggzmod/ggzmod-ggz.h	18 Jan 2005 06:14:33 -0000
@@ -77,11 +77,15 @@
 void ggzmod_set_module(GGZMod * ggzmod, const char *pwd, char **args);
 		       
 
-/** @brief Set the fd of the game server connection
+/** @brief Set the host and port for the game server connection
  *  @param ggzmod The GGZMod object.
- *  @return The server connection fd
+ *  @param host The hostname.
+ *  @param port The port to connect to.
+ *  @param handle The ID to use to connect (currently the player handle).
  */
-void ggzmod_set_server_fd(GGZMod * ggzmod, int fd);
+void ggzmod_set_server_host(GGZMod * ggzmod,
+			    const char *host, unsigned int port,
+			    const char *handle);
 
 /** @brief Set data about which seat at which this ggzmod is sitting.
  *
Index: ggzmod/ggzmod.c
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/ggzmod.c,v
retrieving revision 1.30
diff -u -r1.30 ggzmod.c
--- ggzmod/ggzmod.c	18 Jan 2005 02:51:57 -0000	1.30
+++ ggzmod/ggzmod.c	18 Jan 2005 06:14:33 -0000
@@ -57,6 +57,8 @@
 
 #include <ggz.h>
 
+#include "ggzcore-ggz.h"
+
 #include "ggzmod.h"
 #include "ggzmod-ggz.h"
 #include "mod.h"
@@ -146,6 +148,9 @@
 	ggzmod->state = GGZMOD_STATE_CREATED;
 	ggzmod->fd = -1;
 	ggzmod->server_fd = -1;
+	ggzmod->server_host = NULL;
+	ggzmod->server_port = 0;
+	ggzmod->server_handle = NULL;
 	for (i = 0; i < GGZMOD_NUM_HANDLERS; i++)
 		ggzmod->handlers[i] = NULL;
 	ggzmod->gamedata = NULL;
@@ -190,6 +195,9 @@
 	if (ggzmod->fd != -1)
 		(void)ggzmod_disconnect(ggzmod);
 	
+	if (ggzmod->server_host) ggz_free(ggzmod->server_host);
+	if (ggzmod->server_handle) ggz_free(ggzmod->server_handle);
+
 	ggzmod->type = -1;
 
 	if (ggzmod->my_name)
@@ -300,14 +308,17 @@
 }
 
 
-void ggzmod_set_server_fd(GGZMod * ggzmod, int fd)
+void ggzmod_set_server_host(GGZMod * ggzmod,
+			    const char *host, unsigned int port,
+			    const char *handle)
 {
 	if (ggzmod && ggzmod->type == GGZMOD_GGZ) {
-		ggzmod->server_fd = fd;
-
 		/* If we're already connected, send the fd */
 		if (ggzmod->state == GGZMOD_STATE_CONNECTED)
-			_io_send_server(ggzmod->fd, fd);
+			_io_send_server(ggzmod->fd, host, port, handle);
+		ggzmod->server_host = ggz_strdup(host);
+		ggzmod->server_port = port;
+		ggzmod->server_handle = ggz_strdup(handle);
 	}
 }
 
@@ -923,8 +934,10 @@
 		return -1;
 
 	/* If the server fd has already been set, send that too */
-	if (ggzmod->server_fd != -1)
-		if (_io_send_server(ggzmod->fd, ggzmod->server_fd) < 0)
+	if (ggzmod->server_host)
+		if (_io_send_server(ggzmod->fd, ggzmod->server_host,
+				    ggzmod->server_port,
+				    ggzmod->server_handle) < 0)
 			return -5;
 
 	return 0;
@@ -1271,14 +1284,19 @@
 }
 
 
-void _ggzmod_handle_server(GGZMod * ggzmod, int fd)
+void _ggzmod_handle_server(GGZMod * ggzmod, const char *host,
+			   unsigned int port, const char *handle)
 {
-	ggzmod->server_fd = fd;
-
-	/* Everything's done now, so we move into the waiting state. */
+	ggzmod->server_host = ggz_strdup(host);
+	ggzmod->server_port = port;
+	ggzmod->server_handle = ggz_strdup(handle);
+	ggzmod->server_fd = ggzcore_channel_connect(host, port, handle);
+	if (ggzmod->server_fd < 0) {
+		_ggzmod_error(ggzmod, "Could not create channel.");
+		return;
+	}
 	_ggzmod_set_state(ggzmod, GGZMOD_STATE_WAITING);
-
-	call_handler(ggzmod, GGZMOD_EVENT_SERVER, &fd);
+	call_handler(ggzmod, GGZMOD_EVENT_SERVER, &ggzmod->server_fd);
 }
   
 int ggzmod_set_stats(GGZMod *ggzmod, GGZStat *player_stats,
Index: ggzmod/io.c
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/io.c,v
retrieving revision 1.9
diff -u -r1.9 io.c
--- ggzmod/io.c	16 Jul 2004 17:31:15 -0000	1.9
+++ ggzmod/io.c	18 Jan 2005 06:14:33 -0000
@@ -69,11 +69,13 @@
 	return 0;
 }
 
-
-int _io_send_server(int fd, int server_fd)
+int _io_send_server(int fd, const char *host, unsigned int port,
+		    const char *handle)
 {
 	if (ggz_write_int(fd, MSG_GAME_SERVER) < 0
-	    || ggz_write_fd(fd, server_fd) < 0)
+	    || ggz_write_string(fd, host) < 0
+	    || ggz_write_int(fd, port) < 0
+	    || ggz_write_string(fd, handle) < 0)
 		return -1;
 	else
 		return 0;
@@ -343,13 +345,20 @@
 
 static int _io_read_msg_server(GGZMod *ggzmod)
 {
-	int fd;
+	char *host = NULL, *handle = NULL;
+	int port;
 
-	if (ggz_read_fd(ggzmod->fd, &fd) < 0)
+	if (ggz_read_string_alloc(ggzmod->fd, &host) < 0
+	    || ggz_read_int(ggzmod->fd, &port) < 0
+	    || ggz_read_string_alloc(ggzmod->fd, &handle) < 0) {
+		if (host) ggz_free(host);
+		if (handle) ggz_free(handle);
 		return -1;
-	else
-		_ggzmod_handle_server(ggzmod, fd);
-	
+	}
+
+	_ggzmod_handle_server(ggzmod, host, port, handle);
+	ggz_free(host);
+	ggz_free(handle);
 	return 0;
 }
 
Index: ggzmod/io.h
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/io.h,v
retrieving revision 1.7
diff -u -r1.7 io.h
--- ggzmod/io.h	16 Jul 2004 17:31:15 -0000	1.7
+++ ggzmod/io.h	18 Jan 2005 06:14:33 -0000
@@ -35,7 +35,8 @@
 /* Functions for sending IO messages */
 int _io_send_launch(int fd);
 int _io_send_state(int fd, GGZModState state);
-int _io_send_server(int fd, int server_fd);
+int _io_send_server(int fd, const char *host, unsigned int port,
+		    const char *handle);
 int _io_send_player(int fd, const char *name, int is_spectator, int seat_num);
 int _io_send_seat(int fd, GGZSeat *seat);
 int _io_send_spectator_seat(int fd, GGZSpectatorSeat *seat);
Index: ggzmod/mod.h
===================================================================
RCS file: /var/lib/cvs/ggz-client-libs/ggzmod/mod.h,v
retrieving revision 1.9
diff -u -r1.9 mod.h
--- ggzmod/mod.h	17 Jul 2004 22:45:57 -0000	1.9
+++ ggzmod/mod.h	18 Jan 2005 06:14:33 -0000
@@ -52,7 +52,11 @@
 	int fd;			/* file descriptor */
 	GGZModHandler handlers[GGZMOD_NUM_HANDLERS];
 	void *gamedata;         /* game-specific data */
+
 	int server_fd;
+	const char *server_host;
+	unsigned int server_port;
+	const char *server_handle;
 
 	const char *my_name;
 	int i_am_spectator;
@@ -92,7 +96,9 @@
 
 /* Game side functions for handling various messages */
 void _ggzmod_handle_launch(GGZMod * ggzmod);
-void _ggzmod_handle_server(GGZMod * ggzmod, int fd);
+void _ggzmod_handle_server(GGZMod * ggzmod,
+			   const char *host, unsigned int port,
+			   const char *handle);
 void _ggzmod_handle_player(GGZMod *ggzmod,
 			   const char *name, int is_spectator, int seat_num);
 void _ggzmod_handle_seat(GGZMod *ggzmod, GGZSeat *seat);
