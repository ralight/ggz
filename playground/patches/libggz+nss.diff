=== m4/tls.m4
==================================================================
--- m4/tls.m4	(revision 10280)
+++ m4/tls.m4	(local)
@@ -18,6 +18,7 @@
 dnl 2002-02-24: default to GnuTLS; create conditional compile vars
 dnl 2005-09-14: several cleanups due to newer autotools
 dnl 2006-08-06: now includes gcrypt checks
+dnl 2007-10-24: addition of Netscape Network Security (NSS) checks
 
 dnl ------------------------------------------------------------------------
 dnl Content of this file:
@@ -29,6 +30,7 @@
 dnl Private macros:
 dnl AC_PATH_SSL - OpenSSL implementation backend (code from kdelibs)
 dnl AC_GGZ_GNUTLS - GNUTLS implementation backend
+dnl AC_GGZ_NSS - use TLS implementation from the NSS libraries
 dnl
 
 dnl ------------------------------------------------------------------------
@@ -297,7 +299,7 @@
 AC_MSG_CHECKING([for GGZ TLS implementation])
 
 AC_ARG_WITH([tls],
-  AC_HELP_STRING([--with-tls@<:@=ARG@:>@], [GnuTLS or OpenSSL - auto if no ARG]),
+  AC_HELP_STRING([--with-tls@<:@=ARG@:>@], [GnuTLS or OpenSSL or NSS - auto if no ARG]),
   [tls_type=$withval],
   [tls_type=no])
 
@@ -336,6 +338,21 @@
   fi
 fi
 
+if test \( "$tls_type" = yes -a "$have_gnutls" = no -a "$have_ssl" = no \) -o "$tls_type" = NSS
+then
+  dnl NSS check
+  AC_GGZ_NSS
+  if test "$have_nss" = yes; then
+    GGZTLS_INCLUDES="-I $nss_includes"
+    GGZTLS_LDFLAGS="-L $nss_libraries"
+    LIB_GGZTLS=$nss_lib
+    AC_MSG_RESULT([using NSS])
+    AC_DEFINE_UNQUOTED([GGZ_TLS_NSS], 1,
+		      [Define if NSS is to be used])
+    TLS_TYPE="NSS"
+  fi
+fi
+
 if test "$TLS_TYPE" = no; then
   if test "$tls_type" = no; then
     AC_MSG_RESULT([no])
@@ -398,3 +415,25 @@
 AC_SUBST(LIB_GCRYPT)
 ])
 
+dnl ------------------------------------------------------------------------
+dnl Try to find the NSS headers and libraries.
+dnl Exported are $(nss_includes), $(nss_libraries) and $(nss_lib).
+dnl ------------------------------------------------------------------------
+dnl
+AC_DEFUN([AC_GGZ_NSS],
+[
+ac_nss_includes=NO ac_nss_libraries=NO
+nss_libraries=""
+nss_includes=""
+nss_lib=""
+
+inc=`pkg-config --cflags nss 2>/dev/null`
+lib=`pkg-config --libs nss 2>/dev/null`
+if test "$inc" != "" -a "$lib" != ""; then
+	have_nss=yes
+	nss_includes=$inc
+	nss_libraries=""
+	nss_lib=$lib
+fi
+])
+
=== src/ggz.h
==================================================================
--- src/ggz.h	(revision 10280)
+++ src/ggz.h	(local)
@@ -1773,8 +1773,10 @@
 
 /** @brief Initialize TLS support on the server side.
  *
- *  This function ought only be used on the server side.
- *  It sets up the necessary initialization values.
+ *  This function sets up the necessary initialization values.
+ *  It must be called by both the client and the server before any other TLS
+ *  operations can take place. The client can pass NULL values for all
+ *  parameters.
  *
  *  @param certfile File containing the certificate, or NULL
  *  @param keyfile File containing the private key, or NULL
=== src/security/Makefile.am
==================================================================
--- src/security/Makefile.am	(revision 10280)
+++ src/security/Makefile.am	(local)
@@ -6,6 +6,7 @@
 	base64.c base64.h \
 	ggz_tls_gnutls.c \
 	ggz_tls_openssl.c \
+	ggz_tls_nss.c \
 	ggz_tls_none.c
 
 libggzsecurity_la_LDFLAGS = $(GGZTLS_LDFLAGS)
=== src/security/ggz_tls_none.c
==================================================================
--- src/security/ggz_tls_none.c	(revision 10280)
+++ src/security/ggz_tls_none.c	(local)
@@ -4,7 +4,7 @@
  * Project: GGZ Core Client Lib
  * Date: 10/21/02
  *
- * Routines to enable easysock to utilize TLS using gnutls
+ * Fake routines pretending to enable easysock to utilize TLS
  *
  * Copyright (C) 2002 Brent Hendricks.
  *
=== src/security/ggz_tls_openssl.c
==================================================================
--- src/security/ggz_tls_openssl.c	(revision 10280)
+++ src/security/ggz_tls_openssl.c	(local)
@@ -295,7 +295,7 @@
 }
 
 /* Compare function */
-static int list_entry_compare(void *a, void *b)
+static int list_entry_compare(const void *a, const void *b)
 {
 	struct list_entry x, y;
 	x = *(struct list_entry*)a;
=== src/security/ggz_tls_nss.c
==================================================================
--- src/security/ggz_tls_nss.c	(revision 10280)
+++ src/security/ggz_tls_nss.c	(local)
@@ -0,0 +1,182 @@
+/*
+ * Routines to enable easysock to utilize TLS using NSS
+ *
+ * Copyright (C) 2007 Josef Spillner <josef@ggzgamingzone.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#ifdef GGZ_TLS_NSS
+
+#include <unistd.h>
+
+#include <prinit.h>
+#include <nss/nss.h> // FIXME: evil path override!
+#include <nss/ssl.h>
+
+#include "ggz.h"
+
+/* List entries */
+struct list_entry
+{
+	PRFileDesc *fdtls;
+	int fd;
+	int active;
+};
+static GGZList *nsslist;
+
+/* Utility comparison function for list entries */
+static int list_entry_compare(const void *a, const void *b)
+{
+	struct list_entry x, y;
+	x = *(struct list_entry*)a;
+	y = *(struct list_entry*)b;
+	return (x.fd == y.fd ? 0 : 1);
+}
+
+/* API function declarations missing from NSPR headers */
+/* FIXME: blindly taken from nss_compat_ossl sources */
+PRInt32 PR_FileDesc2NativeHandle(PRFileDesc *fd);
+void PR_ChangeFileDescNativeHandle(PRFileDesc *fd, PRInt32 handle);
+
+void ggz_tls_init(const char *certfile, const char *keyfile, const char *password)
+{
+	/*PR_Init();*/
+//	PK11_SetPasswordFunc();
+	NSS_Init("/tmp");
+	NSS_SetDomesticPolicy();
+
+	nsslist = ggz_list_create(NULL, NULL, NULL, 0);
+}
+
+#if 0
+void ggz_tls_finish(void)
+{
+	NSS_Shutdown();
+	PR_Cleanup();
+}
+#endif
+
+int ggz_tls_support_query(void)
+{
+	return 1;
+}
+
+const char *ggz_tls_support_name(void)
+{
+	return "NSS";
+}
+
+int ggz_tls_enable_fd(int fdes, GGZTLSType whoami, GGZTLSVerificationType verify)
+{
+	PRFileDesc *fdpr, *fdtls;
+	struct list_entry *entry;
+
+	fdpr = PR_NewTCPSocket();
+
+	// FIXME: the following lines are taken from nss_compat_ossl
+	close(PR_FileDesc2NativeHandle(fdpr));
+	fdpr = PR_GetIdentitiesLayer(fdpr, PR_NSPR_IO_LAYER);
+	PR_ChangeFileDescNativeHandle(fdpr, fdes);
+
+	fdtls = SSL_ImportFD(NULL, fdpr);
+	if(!fdtls) return 0;
+
+	if(whoami == GGZ_TLS_CLIENT)
+	{
+		/* FIXME: use real domain */
+		SSL_SetURL(fdtls, "localhost");
+	}
+	else
+	{
+		/* FIXME: use values from ggz_tls_init instead of NULL */
+		SSL_ConfigSecureServer(fdtls, NULL, NULL, kt_dh);
+	}
+
+	entry = (struct list_entry*)ggz_malloc(sizeof(struct list_entry));
+	entry->fdtls = fdtls;
+	entry->fd = fdes;
+	entry->active = 1;
+	ggz_list_insert(nsslist, &entry);
+
+	return 1;
+}
+
+int ggz_tls_disable_fd(int fdes)
+{
+	struct list_entry *entry;
+	struct list_entry entry2;
+	PRFileDesc *fdtls;
+
+	entry2.fd = fdes;
+	entry = (struct list_entry*)ggz_list_search_alt(nsslist, &entry2, list_entry_compare);
+
+	if(entry)
+	{
+		fdtls = entry->fdtls;
+		PR_Shutdown(fdtls, PR_SHUTDOWN_BOTH);
+		PR_Close(fdtls);
+		ggz_list_delete_entry(nsslist, (GGZListEntry*)entry);
+		return 1;
+	}
+
+	return 0;
+}
+
+size_t ggz_tls_write(int fd, void *ptr, size_t n)
+{
+	struct list_entry *entry;
+	struct list_entry entry2;
+	PRFileDesc *fdtls;
+
+	entry2.fd = fd;
+	entry = (struct list_entry*)ggz_list_search_alt(nsslist, &entry2, list_entry_compare);
+
+	if(entry)
+	{
+		fdtls = entry->fdtls;
+		return PR_Write(fdtls, ptr, n);
+	}
+	else
+	{
+		return write(fd, ptr, n);
+	}
+}
+
+size_t ggz_tls_read(int fd, void *ptr, size_t n)
+{
+	struct list_entry *entry;
+	struct list_entry entry2;
+	PRFileDesc *fdtls;
+
+	entry2.fd = fd;
+	entry = (struct list_entry*)ggz_list_search_alt(nsslist, &entry2, list_entry_compare);
+
+	if(entry)
+	{
+		fdtls = entry->fdtls;
+		return PR_Read(fdtls, ptr, n);
+	}
+	else
+	{
+		return read(fd, ptr, n);
+	}
+}
+
+#endif
+
=== tests/tls.c
==================================================================
--- tests/tls.c	(revision 10280)
+++ tests/tls.c	(local)
@@ -29,17 +29,6 @@
 
 #define HAVE_ALARM 1
 
-#ifdef GGZ_TLS_NONE
-
-/* Don't bother with the test. */
-int main(int argc, char *argv[])
-{
-	printf("Cannot run test on this platform.\n");
-	return 0;
-}
-
-#else
-
 /* This test needs more autoconf help. */
 
 static char buffer[1024], buffer2[1024];
@@ -52,6 +41,7 @@
 	char *shm;
 
 	printf("Enable TLS for the server...\n");
+	ggz_tls_init(NULL, NULL, NULL);
 	ret = ggz_tls_enable_fd(fd, GGZ_TLS_SERVER, GGZ_TLS_VERIFY_NONE);
 	/*if(!ret) return NULL;*/
 	printf("Read a message...\n");
@@ -70,6 +60,7 @@
 	int ret;
 
 	printf("Enable TLS for the client...\n");
+	ggz_tls_init(NULL, NULL, NULL);
 	ret = ggz_tls_enable_fd(fd, GGZ_TLS_CLIENT, GGZ_TLS_VERIFY_NONE);
 	/*if(!ret) return NULL;*/
 	printf("Write a message...\n");
@@ -87,10 +78,19 @@
 {
 	int fd[2];
 	/*pthread_t id_read, id_write;*/
+	/* FIXME: using threads would be better but doesn't seem to be possible? */
 	pid_t pid;
 	char *shm;
 
-	printf("Preparation...\n");
+	if(!ggz_tls_support_query())
+	{
+		/* Don't bother with the test. */
+		printf("Cannot run test on this platform.\n");
+		return 0;
+	}
+	printf("Info: using TLS backend %s.\n", ggz_tls_support_name());
+
+	printf("Preparation for TLS handshake...\n");
 	/*ret = shm_open("Physical", O_RDWR, 0777);
 	if(ret < 0)
 	{
@@ -104,7 +104,7 @@
 		fprintf(stderr, "SHM failed (errno = %i (%s))!\n", errno, strerror(errno));
 		exit(-1);
 	}
-	printf("SHM: size=%i\n", getpagesize());
+	printf("SHM succeeded (size=%i)\n", getpagesize());
 
 	strcpy(buffer, "This is a test.");
 	socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
@@ -161,4 +161,3 @@
 	return 0;
 }
 
-#endif
