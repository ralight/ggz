? client-libs/channel.xml
? client-libs/stats.diff
? client-libs/win32.diff
? client-libs/ggzcore/channel.xml
? client-libs/ggzcore/highscore.diff
? ggzd/destdir.diff
? gtk-client/combo.diff
? gtk-client/ggz-gtk/channel.xml
? gtk-client/ggz-gtk/patch.diff
? gtk-games/channel.xml
? kde-client/channel.xml
? kde-client/ggz-kde/ggzcore++/src/GGZCoreModule.loT
? kde-client/ggz-kde/ggzcore++/src/GGZCoreServer.loT
? kde-client/kio_ggz/kio_ggz.loT
? txt-client/win32.diff
Index: ggzd/game_servers/tictactoe/tictactoe.dsc
===================================================================
RCS file: /var/lib/cvs/ggzd/game_servers/tictactoe/tictactoe.dsc,v
retrieving revision 1.24
diff -u -r1.24 tictactoe.dsc
--- ggzd/game_servers/tictactoe/tictactoe.dsc	17 Jul 2004 02:30:40 -0000	1.24
+++ ggzd/game_servers/tictactoe/tictactoe.dsc	25 Jan 2005 08:19:48 -0000
@@ -8,7 +8,7 @@
 Version = 0.0.6
 
 [LaunchInfo]
-ExecutablePath = ggzd.tictactoe
+ExecutablePath = /usr/bin/valgrind /usr/local/lib/ggzd/ggzd.tictactoe
 
 [Protocol]
 Engine = TicTacToe
Index: ggzd/ggzd/net.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzd/net.c,v
retrieving revision 1.116
diff -u -r1.116 net.c
--- ggzd/ggzd/net.c	23 Jan 2005 23:28:03 -0000	1.116
+++ ggzd/ggzd/net.c	25 Jan 2005 08:19:49 -0000
@@ -1646,6 +1646,10 @@
 				strcpy(table->seat_names[seat->index],
 				       seat->name);
 			break;
+		case GGZ_SEAT_ABANDONED:
+			/* Clients can't do this. */
+			seat_type = GGZ_SEAT_NONE;
+			break;
 		}
 		table->seat_types[seat->index] = seat_type;
 	}
@@ -1902,6 +1906,7 @@
 	switch (seat->type) {
 	case GGZ_SEAT_RESERVED:
 	case GGZ_SEAT_PLAYER:
+	case GGZ_SEAT_ABANDONED:
 		name = seat->name;
 		break;
 	case GGZ_SEAT_OPEN:
Index: ggzd/ggzd/stats.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzd/stats.c,v
retrieving revision 1.13
diff -u -r1.13 stats.c
--- ggzd/ggzd/stats.c	25 Jan 2005 04:09:19 -0000	1.13
+++ ggzd/ggzd/stats.c	25 Jan 2005 08:19:49 -0000
@@ -256,8 +256,9 @@
 		if ((report->types[i] == GGZ_SEAT_BOT)
 		&&  (!bot_stats)) continue;
 
-		if ((report->types[i] != GGZ_SEAT_PLAYER)
-		&&  (report->types[i] != GGZ_SEAT_BOT)) {
+		if (report->types[i] != GGZ_SEAT_PLAYER
+		    && report->types[i] != GGZ_SEAT_BOT
+		    && report->types[i] != GGZ_SEAT_ABANDONED) {
 			err_msg("Unknown player type %d in stats calc.",
 				report->types[i]);
 			return;
Index: ggzd/ggzd/table.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzd/table.c,v
retrieving revision 1.158
diff -u -r1.158 table.c
--- ggzd/ggzd/table.c	25 Jan 2005 04:09:19 -0000	1.158
+++ ggzd/ggzd/table.c	25 Jan 2005 08:19:49 -0000
@@ -560,7 +560,8 @@
 	   may still be necessary to always double-check. */
 	/* Remove any seat reservations this player may have. */
 	for (i = 0; i < table->num_seats; i++) {
-		if (table->seat_types[i] == GGZ_SEAT_RESERVED
+		if ((table->seat_types[i] == GGZ_SEAT_RESERVED
+		     || table->seat_types[i] == GGZ_SEAT_ABANDONED)
 		    && !strcasecmp(table->seat_names[i], name)) {
 			pthread_rwlock_wrlock(&table->lock);
 			table->seat_types[i] = GGZ_SEAT_OPEN;
Index: ggzd/ggzd/transit.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzd/transit.c,v
retrieving revision 1.71
diff -u -r1.71 transit.c
--- ggzd/ggzd/transit.c	16 Feb 2004 00:21:25 -0000	1.71
+++ ggzd/ggzd/transit.c	25 Jan 2005 08:19:49 -0000
@@ -80,6 +80,7 @@
 
 static int transit_table_find_player(GGZTable *table, char *name);
 static int transit_table_find_spectator(GGZTable *table, char *name);
+static int transit_find_required_seat(GGZTable *table, const char *name);
 static int transit_find_available_seat(GGZTable *table, char *name);
 static int transit_find_available_spectator(GGZTable *table, char *name);
 
@@ -159,6 +160,15 @@
 		return GGZ_EVENT_OK;
 	}
 
+	if (seat->type == GGZ_SEAT_PLAYER && !spectating) {
+		int index = transit_find_required_seat(table, event->caller);
+
+		if (index >= 0) {
+			/* Force the player into this seat. */
+			seat->index = index;
+		}
+	}
+
 	/* Try to find a seat if one isn't specified */
 	if ((seat->type == GGZ_SEAT_PLAYER || spectating)
 	    && seat->index == GGZ_SEATNUM_ANY) {
@@ -178,6 +188,15 @@
 		}
 	}
 
+	if (event->transit == GGZ_TRANSIT_LEAVE
+	    && event->reason == GGZ_LEAVE_NORMAL
+	    && table->state == GGZ_TABLE_PLAYING) {
+		/* The seat becomes abandoned not open. */
+		strncpy(event->seat.name, table->seat_names[seat->index],
+			sizeof(event->seat.name));
+		event->seat.type = GGZ_SEAT_ABANDONED;
+	}
+
 	if (transit_send_seat_to_game(table, event->transit,
 				      event) != GGZ_OK) {
 		/* Otherwise send an error message back to the player */
@@ -311,6 +330,7 @@
 					event->seat.index, 1);
 		break;
 	case GGZ_TRANSIT_MOVE:
+	  /* FIXME: moves shouldn't be allowed while the game is PLAYING. */
 		old_seat = transit_table_find_player(table, event->caller);
 		result = ggzdmod_reseat(table->ggzdmod,
 					old_seat, 0,
@@ -407,6 +427,25 @@
 }
 
 
+/* Call this function to find the required seat for a player.  Even if
+   the player gives a specific preference it should be ignored. */
+static int transit_find_required_seat(GGZTable *table, const char *name)
+{
+	int i, num_seats = seats_num(table);
+
+	for (i = 0; i < num_seats; i++) {
+		GGZSeatType type = seats_type(table, i);
+
+		if (type == GGZ_SEAT_ABANDONED
+		    && strcasecmp(table->seat_names[i], name) == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+/* Call this function to find the preferred seat for a player, only if
+   the player doesn't have a preference. */
 static int transit_find_available_seat(GGZTable *table, char *name)
 {
 	int i, num_seats = seats_num(table);
Index: ggzd/ggzdmod/ggzdmod.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzdmod/ggzdmod.c,v
retrieving revision 1.121
diff -u -r1.121 ggzdmod.c
--- ggzd/ggzdmod/ggzdmod.c	25 Jan 2005 04:31:44 -0000	1.121
+++ ggzd/ggzdmod/ggzdmod.c	25 Jan 2005 08:19:49 -0000
@@ -699,8 +699,23 @@
 			     .name = NULL,
 			     .type = GGZ_SEAT_OPEN,
 			     .fd = -1};
+		const char *name;
+
+		name = ggz_strdup(ggzdmod_get_seat(ggzdmod, old_seat).name);
+		if (ggzdmod->state == GGZDMOD_STATE_PLAYING) {
+			/* Mark the seat as abandoned rather than open.
+			   FIXME - this should probably be done inside ggzd
+			   rather than here, which would allow it to be
+			   controlled by game options. However this will
+			   take some interface changes.  See also the comment
+			   in handle_reseat. */
+			s.name = name;
+			s.type = GGZ_SEAT_ABANDONED;
+		}
+
 		if (_ggzdmod_set_seat(ggzdmod, &s) < 0)
 			_ggzdmod_error(ggzdmod, "ggzdmod_reseat failed");
+		ggz_free(name);
 	}
 
 	if (is_spectator) {
@@ -1350,6 +1365,7 @@
 		break;
 	case GGZ_SEAT_NONE:
 	case GGZ_SEAT_PLAYER:
+	case GGZ_SEAT_ABANDONED:
 		break;
 	}
 
@@ -1458,6 +1474,16 @@
 
 		name = ggz_strdup(old->name);
 
+		if (ggzdmod->state == GGZDMOD_STATE_PLAYING) {
+			/* Mark the seat as abandoned rather than open.
+			   FIXME - rather than have ggzdmod-game deduce this
+			   on its own, ggzdmod-ggz should instead send the
+			   full value of the new seat.  See also the comment
+			   in ggzdmod_reseat. */
+			s.name = name;
+			s.type = GGZ_SEAT_ABANDONED;
+		}
+
 		old_old = seat_copy(old);
 		_ggzdmod_set_seat(ggzdmod, &s);
 		old_event = GGZDMOD_EVENT_LEAVE;
@@ -1668,6 +1694,7 @@
 			switch (seat.type) {
 			case GGZ_SEAT_PLAYER:
 			case GGZ_SEAT_BOT:
+			case GGZ_SEAT_ABANDONED:
 				usable = 1;
 				break;
 			case GGZ_SEAT_RESERVED:
Index: ggzd/ggzdmod/io.c
===================================================================
RCS file: /var/lib/cvs/ggzd/ggzdmod/io.c,v
retrieving revision 1.22
diff -u -r1.22 io.c
--- ggzd/ggzdmod/io.c	25 Jan 2005 04:31:44 -0000	1.22
+++ ggzd/ggzdmod/io.c	25 Jan 2005 08:19:49 -0000
@@ -401,11 +401,10 @@
 	_ggzdmod_handle_launch_begin(ggzdmod, seats, spectators);
 
 	for (i = 0; i < seats; i++) {
-		char *name;
+		char *name = NULL;
 
 		/* Reset seat */
 		seat.num = i;
-		seat.name = NULL;
 		seat.fd = -1;
 		
 		if (ggz_read_int(ggzdmod->fd, (int*)&seat.type) < 0)
Index: ggzd/tests/basic.c
===================================================================
RCS file: /var/lib/cvs/ggzd/tests/basic.c,v
retrieving revision 1.15
diff -u -r1.15 basic.c
--- ggzd/tests/basic.c	25 Jan 2005 04:31:44 -0000	1.15
+++ ggzd/tests/basic.c	25 Jan 2005 08:19:49 -0000
@@ -194,6 +194,8 @@
 		return "None";
 	case GGZ_SEAT_PLAYER: 
 		return "Player";
+	case GGZ_SEAT_ABANDONED:
+		return "Abandoned";
 	}
 
 	return "**Error**";
Index: ggzd/tests/logmod.c
===================================================================
RCS file: /var/lib/cvs/ggzd/tests/logmod.c,v
retrieving revision 1.10
diff -u -r1.10 logmod.c
--- ggzd/tests/logmod.c	11 Sep 2002 02:22:46 -0000	1.10
+++ ggzd/tests/logmod.c	25 Jan 2005 08:19:49 -0000
@@ -61,7 +61,9 @@
 		case GGZ_SEAT_PLAYER:
 			printf("Received player seat\n");
 			break;
-
+		case GGZ_SEAT_ABANDONED:
+			printf("Received abandoned seat\n");
+			break;
 		}	
 		if (type == GGZ_SEAT_RESERVED
 		    && ggz_read_string(fd, name, 1024) < 0) {
Index: gtk-games/common/dlg_players.c
===================================================================
RCS file: /var/lib/cvs/ggz/game_clients/common/dlg_players.c,v
retrieving revision 1.17
diff -u -r1.17 dlg_players.c
--- gtk-games/common/dlg_players.c	16 Nov 2004 05:20:59 -0000	1.17
+++ gtk-games/common/dlg_players.c	25 Jan 2005 08:19:50 -0000
@@ -132,6 +132,10 @@
 			status = _("Reserved");
 			name = seat.name;
 			break;
+		case GGZ_SEAT_ABANDONED:
+			status = _("Abandoned");
+			name = seat.name;
+			break;
 		case GGZ_SEAT_NONE:
 			status = _("-");
 			name = seat.name;
Index: libggz/src/ggz_common.c
===================================================================
RCS file: /var/lib/cvs/libggz/src/ggz_common.c,v
retrieving revision 1.14
diff -u -r1.14 ggz_common.c
--- libggz/src/ggz_common.c	24 Jan 2005 06:03:21 -0000	1.14
+++ libggz/src/ggz_common.c	25 Jan 2005 08:19:50 -0000
@@ -41,6 +41,7 @@
 #define BOT_SEAT_NAME "bot"
 #define PLAYER_SEAT_NAME "player"
 #define RESERVED_SEAT_NAME "reserved"
+#define ABANDONED_SEAT_NAME "abandoned"
 #define NONE_SEAT_NAME "none"
 
 const char *ggz_seattype_to_string(GGZSeatType type)
@@ -54,6 +55,8 @@
 		return RESERVED_SEAT_NAME;
 	case GGZ_SEAT_PLAYER:
 		return PLAYER_SEAT_NAME;
+	case GGZ_SEAT_ABANDONED:
+		return ABANDONED_SEAT_NAME;
 	case GGZ_SEAT_NONE:
 		return NONE_SEAT_NAME;
 	}
@@ -79,6 +82,8 @@
 		return GGZ_SEAT_RESERVED;
 	else if (strcasecmp(type_str, PLAYER_SEAT_NAME) == 0)
 		return GGZ_SEAT_PLAYER;
+	else if (strcasecmp(type_str, ABANDONED_SEAT_NAME) == 0)
+		return GGZ_SEAT_ABANDONED;
 
 	return GGZ_SEAT_NONE;
 }
Index: libggz/src/ggz_common.h
===================================================================
RCS file: /var/lib/cvs/libggz/src/ggz_common.h,v
retrieving revision 1.22
diff -u -r1.22 ggz_common.h
--- libggz/src/ggz_common.h	20 Jan 2005 05:51:06 -0000	1.22
+++ libggz/src/ggz_common.h	25 Jan 2005 08:19:51 -0000
@@ -44,7 +44,8 @@
 	GGZ_SEAT_OPEN,		/**< The seat is open (unoccupied). */
 	GGZ_SEAT_BOT,		/**< The seat has a bot (AI) in it. */
 	GGZ_SEAT_PLAYER,	/**< The seat has a regular player in it. */
-	GGZ_SEAT_RESERVED	/**< The seat is reserved for a player. */
+	GGZ_SEAT_RESERVED,	/**< The seat is reserved for a player. */
+	GGZ_SEAT_ABANDONED	/**< The seat is abandoned by a player. */
 } GGZSeatType;
 
 
