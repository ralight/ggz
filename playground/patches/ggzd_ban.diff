Index: java/src/ggz/client/core/Net.java
===================================================================
--- java/src/ggz/client/core/Net.java	(revision 9217)
+++ java/src/ggz/client/core/Net.java	(working copy)
@@ -529,6 +529,9 @@
             sendStartElement("ADMIN", attributes);
             sendTextElement("REASON", reason);
             sendEndElement("ADMIN");
+        } else if (type == AdminType.GGZ_ADMIN_BAN) {
+            attributes.addAttribute("", "", "ACTION", "CDATA", "ban");
+            sendEmptyElement("ADMIN", attributes);
         } else {
             // * Not yet in use.
         }
Index: ggzd/ggzd/client.c
===================================================================
--- ggzd/ggzd/client.c	(revision 9217)
+++ ggzd/ggzd/client.c	(working copy)
@@ -126,6 +126,16 @@
 		client_free(client);
 		pthread_exit(NULL);
 	}
+
+	/* Check whether ip is banned */
+	if(is_banned(client->addr)){
+		net_send_player_banned(client->net, opt.server_name);
+		log_msg(GGZ_LOG_NOTICE,
+			"BANNED - Rejected connection from %s",
+			client->addr);
+		client_free(client);
+		pthread_exit(NULL);
+	}
 	
 	pthread_rwlock_wrlock(&state.lock);
 	if (state.players == MAX_USERS) {
Index: ggzd/ggzd/control.c
===================================================================
--- ggzd/ggzd/control.c	(revision 9217)
+++ ggzd/ggzd/control.c	(working copy)
@@ -82,6 +82,19 @@
 struct GameInfo game_types[MAX_GAME_TYPES];
 struct GGZState state;
 
+/* Ban data */
+typedef struct BanList {
+	pthread_rwlock_t lock;
+	GGZList *list;
+} BanList;
+typedef struct BanItem {
+	char addr[64];
+	time_t expires;
+} BanItem;
+
+static BanList bans;
+
+
 /* Termination signal */
 static sig_atomic_t hup_signal;
 static sig_atomic_t term_signal;
@@ -132,6 +145,7 @@
 		err_msg_exit("*** Database initialization failed");
 
 	hash_initialize();
+	bans_initialize();
 }
 
 static void cleanup_data(void)
@@ -710,3 +724,73 @@
 
 	return 0;
 }
+
+
+void bans_initialize(void)
+{
+	pthread_rwlock_init(&bans.lock, NULL);
+	bans.list = ggz_list_create(NULL, NULL, NULL, GGZ_LIST_ALLOW_DUPS);
+}
+
+
+void bans_add(const char *addr)
+{
+	BanItem *ban;
+	time_t t;
+
+	if(!addr) return;
+
+	ban = ggz_malloc(sizeof(BanItem));
+	if(!ban) return;
+
+	strncpy(ban->addr, addr, 64);
+	t = time(NULL);
+	if(t == -1){
+		ggz_free(ban);
+		return;
+	}
+
+	ban->expires = t + 900; /* Current time plus 15 minutes */
+	
+	pthread_rwlock_wrlock(&bans.lock);	
+	ggz_list_insert(bans.list, ban);
+	pthread_rwlock_unlock(&bans.lock);	
+}
+
+
+int is_banned(const char *addr)
+{
+	GGZListEntry *entry;
+	BanItem *ban;
+	int rc = 0;
+
+	/*
+	 * This is a wrlock in case a ban has expired and needs
+	 * removing. Some sort of locking is required and assuming
+	 * that only a rdlock is required here means four lock 
+	 * operations are required when a ban needs to be expired.
+	 */
+	pthread_rwlock_wrlock(&bans.lock);
+	entry = ggz_list_head(bans.list);
+	while(entry){
+		/* Grab next entry here in case current entry is expired. */
+		next = ggz_list_next(entry);
+		ban = ggz_list_get_data(entry);
+#ifdef DEBUG
+		dbg_msg(GGZ_DBG_CONNECTION, "Banned IP: %s (%s)", ban->addr, addr);
+#endif
+		if(!strncmp(ban->addr, addr, 64)){
+			if(ban->expires >= time(NULL)){
+				rc = 1;
+				break;
+			}else{
+				ggz_list_delete_entry(bans.list, entry);
+				ggz_free(ban);
+			}
+		}
+		entry = next;
+	}
+	pthread_rwlock_unlock(&bans.lock);
+
+	return rc;
+}
Index: ggzd/ggzd/hash.h
===================================================================
--- ggzd/ggzd/hash.h	(revision 9217)
+++ ggzd/ggzd/hash.h	(working copy)
@@ -27,6 +27,10 @@
 #include "players.h"
 
 /* Exported functions */
+void bans_initialize(void);
+void bans_add(const char *addr);
+int is_banned(const char *addr);
+
 void hash_initialize(void);
 int hash_player_add(const char *name, GGZPlayer* player);
 
Index: ggzd/ggzd/players.c
===================================================================
--- ggzd/ggzd/players.c	(revision 9217)
+++ ggzd/ggzd/players.c	(working copy)
@@ -1497,6 +1496,20 @@
 		break;
 	case GGZ_ADMIN_BAN:
 		log_msg(GGZ_LOG_ADMIN, "ADMIN %s bans %s", player->name, target);
+		if (rcvr == NULL || rcvr == player) {
+			status = E_USR_LOOKUP;
+		} else {
+			bans_add(rcvr->client->addr);
+			/* FIXME 1: session_over should be bool, not char */
+			/* FIXME: We temporarily take away the wr-lock since player_enqueue needs it */
+			pthread_rwlock_unlock(&rcvr->lock);	
+			chat_player_enqueue(target, GGZ_CHAT_PERSONAL, player, "You have been banned");
+
+			/* Recover the rcvr player - a new lookup is needed */
+			rcvr = hash_player_lookup(target);
+			if (rcvr) rcvr->client->session_over = 1;
+			status = E_OK;
+		}
 		/* This is not implemented/used yet. */
 		break;
 	}
Index: ggzd/ggzd/net.h
===================================================================
--- ggzd/ggzd/net.h	(revision 9217)
+++ ggzd/ggzd/net.h	(working copy)
@@ -56,6 +56,7 @@
 /* Functions to send data to the client */
 GGZReturn net_send_serverid(GGZNetIO *net, const char *srv_name, bool use_tls);
 GGZReturn net_send_server_full(GGZNetIO *net, const char *srv_name);
+GGZReturn net_send_player_banned(GGZNetIO *net, const char *srv_name);
 GGZReturn net_send_login(GGZNetIO *net, GGZLoginType type,
 			 GGZClientReqError status, const char *password);
 GGZReturn net_send_motd(GGZNetIO *net);
