Index: ggzd/datatypes.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/datatypes.h,v
retrieving revision 1.68
diff -u -3 -p -r1.68 datatypes.h
--- ggzd/datatypes.h	5 May 2002 00:22:08 -0000	1.68
+++ ggzd/datatypes.h	20 May 2002 17:21:04 -0000
@@ -85,10 +85,11 @@ typedef struct GameInfo {
 	char *author;   /* String containing name(s) of author(s) */
 	char *homepage; /* Contains a web address for the game */
 	
-	/* Masks for how many overall players and bots are allowed
+	/* Masks for how many overall players, bots and spectators are allowed
 	   to be selected for the game. */
 	unsigned char player_allow_mask;
 	unsigned char bot_allow_mask;
+	unsigned char spectator_allow_mask;
 	
 	/* Are players allowed to leave mid-game?  (i.e. does the
 	   game support this?) */
Index: ggzd/net.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/net.c,v
retrieving revision 1.57
diff -u -3 -p -r1.57 net.c
--- ggzd/net.c	5 May 2002 18:43:52 -0000	1.57
+++ ggzd/net.c	20 May 2002 17:21:04 -0000
@@ -121,6 +121,7 @@ static void _net_handle_list(GGZNetIO *n
 static void _net_handle_enter(GGZNetIO *net, GGZXMLElement *element);
 static void _net_handle_chat(GGZNetIO *net, GGZXMLElement *element);
 static void _net_handle_join(GGZNetIO *net, GGZXMLElement *element);
+static void _net_handle_join_spectator(GGZNetIO *net, GGZXMLElement *element);
 static void _net_handle_leave(GGZNetIO *net, GGZXMLElement *element);
 static void _net_handle_launch(GGZNetIO *net, GGZXMLElement *element);
 static void _net_handle_table(GGZNetIO *net, GGZXMLElement *element);
@@ -139,8 +140,10 @@ static int _net_send_login_anon_status(G
 static int _net_send_login_new_status(GGZNetIO *net, char status, char *password);
 static int _net_send_table_status(GGZNetIO *net, GGZTable *table);
 static int _net_send_table_seat(GGZNetIO *net, GGZTable *table, int num);
+static int _net_send_table_spectator(GGZNetIO *net, GGZTable *table, int num);
 static int _net_send_table_desc(GGZNetIO *net, GGZTable *table);
 static int _net_send_seat(GGZNetIO *net, GGZTable *table, int num);
+static int _net_send_spectator(GGZNetIO *net, GGZTable *table, int num);
 static int _net_send_line(GGZNetIO *net, char *line, ...)
 			  ggz__attribute((format(printf, 2, 3)));
 
@@ -386,8 +389,8 @@ int net_send_type(GGZNetIO *net, int ind
 		       index, type->name, type->version);
 	_net_send_line(net, "<PROTOCOL ENGINE='%s' VERSION='%s'/>",
 		       type->p_engine, type->p_version);
-	_net_send_line(net, "<ALLOW PLAYERS='%d' BOTS='%d'/>",
-		       type->player_allow_mask, type->bot_allow_mask);
+	_net_send_line(net, "<ALLOW PLAYERS='%d' BOTS='%d' SPECTATORS='%d'/>",
+		       type->player_allow_mask, type->bot_allow_mask, type->spectator_allow_mask);
 	
 	if (verbose) {
 		_net_send_line(net, "<ABOUT AUTHOR='%s' URL='%s'/>",
@@ -572,6 +575,12 @@ int net_send_table_join(GGZNetIO *net, c
 }
 
 
+int net_send_table_join_spectator(GGZNetIO *net, char status)
+{
+	return _net_send_result(net, "joinspectator", status);
+}
+
+
 int net_send_table_leave(GGZNetIO *net, char status)
 {
 	return _net_send_result(net, "leave", status);
@@ -650,6 +659,12 @@ int net_send_table_update(GGZNetIO *net,
 	case GGZ_UPDATE_SEAT:
 		action = "seat";
 		break;
+	case GGZ_UPDATE_SPECTATOR_JOIN:
+		action = "joinspectator";
+		break;
+	case GGZ_UPDATE_SPECTATOR_LEAVE:
+		action = "leave";
+		break;
 	default:
 		/* We should never get any other update types */
 		return -1;
@@ -671,6 +686,10 @@ int net_send_table_update(GGZNetIO *net,
 	case GGZ_UPDATE_SEAT:
 		_net_send_table_seat(net, table, seat);
 		break;
+	case GGZ_UPDATE_SPECTATOR_JOIN:
+	case GGZ_UPDATE_SPECTATOR_LEAVE:
+		_net_send_table_spectator(net, table, seat);
+		break;
 	case GGZ_UPDATE_STATE:
 		_net_send_table_status(net, table);
 		break;
@@ -888,6 +907,8 @@ static GGZXMLElement* _net_new_element(c
 		process_func = _net_handle_chat;
 	else if (strcmp(tag, "JOIN") == 0)
 		process_func = _net_handle_join;
+	else if (strcmp(tag, "JOINSPECTATOR") == 0)
+		process_func = _net_handle_join_spectator;
 	else if (strcmp(tag, "LEAVE") == 0)
 		process_func = _net_handle_leave;
 	else if (strcmp(tag, "LAUNCH") == 0)
@@ -1241,6 +1262,16 @@ static void _net_handle_join(GGZNetIO *n
 	}
 }
 
+/* Functions for <JOINSPECTATOR> tag */
+static void _net_handle_join_spectator(GGZNetIO *net, GGZXMLElement *element)
+{
+	int table;
+
+	if (element) {
+		table = safe_atoi(ggz_xmlelement_get_attr(element, "TABLE"));
+		player_table_join_spectator(net->client->data, table);
+	}
+}
 
 /* Functions for <LEAVE> tag */
 static void _net_handle_leave(GGZNetIO *net, GGZXMLElement *element)
@@ -1561,6 +1592,17 @@ static int _net_send_table_seat(GGZNetIO
 }
 
 
+static int _net_send_table_spectator(GGZNetIO *net, GGZTable *table, int spectator)
+{
+	_net_send_line(net, "<TABLE ID='%d' SPECTATORS='%d'>", table->index,
+		       spectators_count(table));
+	_net_send_spectator(net, table, spectator);
+	_net_send_line(net, "</TABLE>");
+	
+	return 0;
+}
+
+
 static int _net_send_table_desc(GGZNetIO *net, GGZTable *table)
 {
 	_net_send_line(net, "<TABLE ID='%d'>", table->index);
@@ -1612,6 +1654,17 @@ static int _net_send_seat(GGZNetIO *net,
 	return 0;
 }
 
+
+static int _net_send_spectator(GGZNetIO *net, GGZTable *table, int num)
+{
+	char *name = NULL;
+
+	name = table->spectators[num];
+	
+	_net_send_line(net, "<SPECTATOR NUM='%d'>%s</SPECTATOR>", num, name);
+
+	return 0;
+}
 
 static int _net_send_result(GGZNetIO *net, char *action, char code)
 {
Index: ggzd/net.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/net.h,v
retrieving revision 1.19
diff -u -3 -p -r1.19 net.h
--- ggzd/net.h	5 May 2002 18:43:52 -0000	1.19
+++ ggzd/net.h	20 May 2002 17:21:04 -0000
@@ -86,6 +86,7 @@ int net_send_chat(GGZNetIO *net, unsigne
 int net_send_chat_result(GGZNetIO *net, char status);
 int net_send_table_launch(GGZNetIO *net, char status);
 int net_send_table_join(GGZNetIO *net, char status);
+int net_send_table_join_spectator(GGZNetIO *net, char status);
 int net_send_table_leave(GGZNetIO *net, char status);
 int net_send_player_update(GGZNetIO *net, unsigned char opcode, char *name);
 int net_send_table_update(GGZNetIO *net, GGZUpdateOpcode opcode, GGZTable *table, int seat);
Index: ggzd/parse_opt.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/parse_opt.c,v
retrieving revision 1.87
diff -u -3 -p -r1.87 parse_opt.c
--- ggzd/parse_opt.c	6 May 2002 05:48:44 -0000	1.87
+++ ggzd/parse_opt.c	20 May 2002 17:21:05 -0000
@@ -494,6 +494,7 @@ static void parse_game(char *name, char 
 	game_info->allow_leave = ggz_conf_read_int(ch,"TableOptions","AllowLeave",0);
 	game_info->kill_when_empty =
 		ggz_conf_read_int(ch, "TableOptions", "KillWhenEmpty", 1);
+
 	ggz_conf_read_list(ch, "TableOptions", "BotsAllowed", &b_count, &b_list);
 	if(b_count != 0) {
 		for(i=0; i<b_count; i++) {
@@ -520,6 +521,19 @@ static void parse_game(char *name, char 
 				continue;
 			}
 			game_info->player_allow_mask |= 1 << (intval - 1);
+			ggz_free(b_list[i]);
+		}
+		ggz_free(b_list);
+	}
+	ggz_conf_read_list(ch, "TableOptions", "SpectatorsAllowed", &b_count, &b_list);
+	if(b_count != 0) {
+		for(i=0; i<b_count; i++) {
+			intval = atoi(b_list[i]);
+			if(intval < 1 || intval > MAX_TABLE_SIZE) {
+				err_msg("SpectatorsAllowed has invalid value");
+				continue;
+			}
+			game_info->spectator_allow_mask |= 1 << (intval - 1);
 			ggz_free(b_list[i]);
 		}
 		ggz_free(b_list);
Index: ggzd/players.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/players.c,v
retrieving revision 1.156
diff -u -3 -p -r1.156 players.c
--- ggzd/players.c	5 May 2002 21:51:20 -0000	1.156
+++ ggzd/players.c	20 May 2002 17:21:05 -0000
@@ -469,6 +469,33 @@ GGZPlayerHandlerStatus player_table_join
 	return status;
 }
 
+GGZPlayerHandlerStatus player_table_join_spectator(GGZPlayer* player, int index)
+{
+	int status;
+
+	dbg_msg(GGZ_DBG_TABLE, "Handling table join (as spectator) for %s", player->name);
+
+	dbg_msg(GGZ_DBG_TABLE, "%s attempting to join (as spectator) table %d in room %d", 
+		player->name, index, player->room);
+
+	if (player->table != -1)
+		status = E_AT_TABLE;
+	else if (player->transit)
+		status = E_IN_TRANSIT;
+	else if (perms_check(player, PERMS_JOIN_TABLE) == PERMS_DENY)
+		status = E_NO_PERMISSION;
+	else /* Send a join event to the table */
+		status = player_transit(player, GGZ_TRANSIT_JOIN_SPECTATOR, index);
+
+	/* Return any immediate failures to client*/
+	if (status < 0) {
+		if (net_send_table_join_spectator(player->client->net, (char)status) < 0)
+			return GGZ_REQ_DISCONNECT;
+		status = GGZ_REQ_FAIL;
+	}
+	
+	return status;
+}
 
 /* 
  * player_table_leave() handles REQ_TABLE_LEAVE request from the
@@ -538,6 +565,7 @@ GGZPlayerHandlerStatus player_table_leav
 static int player_transit(GGZPlayer* player, char opcode, int index)
 {
 	struct GGZTableSeat seat;
+	struct GGZTableSpectator spectator;
 	int status;
 
 	/* Do some quick sanity checking */
@@ -569,7 +597,28 @@ static int player_transit(GGZPlayer* pla
 		pthread_rwlock_wrlock(&player->lock);
 		player->game_fd = -1;
 		pthread_rwlock_unlock(&player->lock);
-		
+
+		break;
+	case GGZ_TRANSIT_JOIN_SPECTATOR:
+		spectator.index = GGZ_SEATNUM_ANY;
+		spectator.fd = player->game_fd;
+		strcpy(spectator.name, player->name);
+
+		status = transit_spectator_event(player->room, index, spectator, player->name);
+		/* Now that channel fd has been sent, rest it here */
+		pthread_rwlock_wrlock(&player->lock);
+		player->game_fd = -1;
+		pthread_rwlock_unlock(&player->lock);
+
+		break;
+	case GGZ_TRANSIT_LEAVE_SPECTATOR:
+		spectator.index = table_find_player(player->room, index, player->name);
+		if(spectator.index == -1)
+			return E_NO_TABLE;
+		spectator.name[0] = '\0';
+		spectator.fd = -1;
+
+		status = transit_spectator_event(player->room, index, spectator, player->name);
 		break;
 	default:
 		/* Should never get here */
Index: ggzd/players.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/players.h,v
retrieving revision 1.31
diff -u -3 -p -r1.31 players.h
--- ggzd/players.h	5 May 2002 21:51:20 -0000	1.31
+++ ggzd/players.h	20 May 2002 17:21:05 -0000
@@ -98,6 +98,7 @@ int player_chat(GGZPlayer* player, unsig
 GGZPlayerHandlerStatus player_table_launch(GGZPlayer* player, GGZTable *table);
 GGZPlayerHandlerStatus player_table_update(GGZPlayer* player, GGZTable *table);
 GGZPlayerHandlerStatus player_table_join(GGZPlayer* player, int index);
+GGZPlayerHandlerStatus player_table_join_spectator(GGZPlayer* player, int index);
 GGZPlayerHandlerStatus player_table_leave(GGZPlayer* player, char force);
 GGZPlayerHandlerStatus player_list_players(GGZPlayer* player);
 GGZPlayerHandlerStatus player_list_types(GGZPlayer* player, char verbose);
Index: ggzd/protocols.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/protocols.h,v
retrieving revision 1.41
diff -u -3 -p -r1.41 protocols.h
--- ggzd/protocols.h	11 May 2002 16:08:04 -0000	1.41
+++ ggzd/protocols.h	20 May 2002 17:21:05 -0000
@@ -46,7 +46,10 @@ typedef enum {
 	GGZ_UPDATE_STATE  = 4,
 	GGZ_UPDATE_LAG	  = 5,
 	GGZ_UPDATE_SEAT   = 6,
-	GGZ_UPDATE_DESC   = 7
+	GGZ_UPDATE_DESC   = 7,
+	GGZ_UPDATE_SPECTATOR_LEAVE = 8,
+	GGZ_UPDATE_SPECTATOR_JOIN = 9,
+	GGZ_UPDATE_SPECTATOR = 10
 } GGZUpdateOpcode;
 
 #endif /*_GGZ_PROTOCOL_H*/
Index: ggzd/seats.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/seats.c,v
retrieving revision 1.11
diff -u -3 -p -r1.11 seats.c
--- ggzd/seats.c	30 Jan 2002 09:24:30 -0000	1.11
+++ ggzd/seats.c	20 May 2002 17:21:05 -0000
@@ -42,6 +42,18 @@ int seats_count(GGZTable* table, GGZSeat
 }
 
 
+int spectators_count(GGZTable *table)
+{
+	/*int i, count = 0;
+	for (i = 0; i < MAX_TABLE_SIZE; i++)
+		if (!table->spectators[i][0])
+			count++;
+	return count;*/
+	/* FIXME: return actual maximum number of spectators! */
+	return MAX_TABLE_SIZE - 1;
+}
+
+
 int seats_num(GGZTable* table)
 {
 	int i;
Index: ggzd/seats.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/seats.h,v
retrieving revision 1.11
diff -u -3 -p -r1.11 seats.h
--- ggzd/seats.h	5 May 2002 18:43:52 -0000	1.11
+++ ggzd/seats.h	20 May 2002 17:21:05 -0000
@@ -46,6 +46,18 @@ struct GGZTableSeat {
 	int fd;
 };
 
+/* Spectator structure */
+struct GGZTableSpectator {
+	/* Spectator index */
+	int index;
+
+	/* Spectator's name */
+	char name[MAX_USER_NAME_LEN + 1];
+
+	/* File descriptor */
+	int fd;
+};
+
 #define GGZ_SEATNUM_ANY -1
 
 
@@ -71,6 +83,13 @@ int seats_num(GGZTable* table);
 s *  @return The type of the given seat.
  */
 GGZSeatType seats_type(GGZTable* table, int seat);
+
+/** @brief Return the total number of spectators at a table.
+ *
+ *  @param table The table to query.
+ *  @return The number of spectators at that table.
+ */
+int spectators_count(GGZTable *table);
 
 
 #endif /* __GGZ_TABLE_H_ */
Index: ggzd/table.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/table.c,v
retrieving revision 1.101
diff -u -3 -p -r1.101 table.c
--- ggzd/table.c	5 May 2002 18:43:52 -0000	1.101
+++ ggzd/table.c	20 May 2002 17:21:06 -0000
@@ -64,6 +64,13 @@ struct GGZSeatChange {
 	struct GGZTableSeat seat;
 };
 
+/* Packaging for spectator events */
+struct GGZSpectatorChange {
+	int table;
+	int num_spectators;
+	struct GGZTableSpectator spectator;
+};
+
 /* Server wide data structures*/
 extern struct GameInfo game_types[MAX_GAME_TYPES];
 extern struct GGZState state;
@@ -82,6 +89,8 @@ static void table_handle_state(GGZdMod *
 static void table_game_join(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
 static void table_game_leave(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
 static void table_game_seatchange(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
+static void table_game_spectator_join(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
+static void table_game_spectator_leave(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
 static void table_log(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
 static void table_error(GGZdMod *ggzdmod, GGZdModEvent event, void *data);
 
@@ -91,7 +100,9 @@ static int   table_update_event_enqueue(
 					 unsigned int seat);
 static int   table_seat_event_enqueue(GGZTable* table, GGZUpdateOpcode opcode,
 				      unsigned int seat);
-				      
+static int   table_spectator_event_enqueue(GGZTable* table, GGZUpdateOpcode opcode,
+				      unsigned int spectator);
+			      
 static int   table_pack(void** data, unsigned char opcode, GGZTable* table);
 static int   table_transit_pack(void** data, unsigned char opcode, 
 				GGZTable* table, char* name, 
@@ -100,6 +111,8 @@ static GGZEventFuncReturn table_event_ca
                                                  void* data);
 static GGZEventFuncReturn table_seat_event_callback(void* target, int size,
 						    void* data);
+static GGZEventFuncReturn table_spectator_event_callback(void* target, int size,
+						    void* data);
 static GGZEventFuncReturn table_kill_callback(void* target, int size, void* data);
 static int   table_launch_event(char* name, int status, int index);
 static void  table_free(GGZTable* table);
@@ -131,6 +144,9 @@ GGZTable* table_new(void)
 	for (i = 0; i < MAX_TABLE_SIZE; i++)
 		table->seat_types[i] = GGZ_SEAT_NONE;
 
+	for (i = 0; i < MAX_TABLE_SIZE; i++)
+		table->spectators[i][0] = 0;
+
 	return table;
 }
 
@@ -149,6 +165,7 @@ static int table_check(GGZTable* table)
 	int i, status = 0;
 	int ai_total = seats_count(table, GGZ_SEAT_BOT);
 	int seat_total = seats_num(table);
+	int spectator_total = spectators_count(table);
 	int g_type = table->type;
 	int room_type;
 	
@@ -188,6 +205,15 @@ static int table_check(GGZTable* table)
 		status = E_BAD_OPTIONS;
 	}
 
+	if(spectator_total == 0
+		|| (spectator_total > 0
+			&& game_types[g_type].spectator_allow_mask & (1 << (spectator_total - 1))))
+		dbg_msg(GGZ_DBG_TABLE, "Spectators: %d (accept)", spectator_total);
+	else {
+		dbg_msg(GGZ_DBG_TABLE, "Spectators: %d (invalid)", spectator_total);
+		status = E_BAD_OPTIONS;
+	}
+
 	dbg_msg(GGZ_DBG_TABLE, "Open Seats : %d", seats_count(table, GGZ_SEAT_OPEN));
 	dbg_msg(GGZ_DBG_TABLE, "Resv.Seats : %d", seats_count(table, GGZ_SEAT_RESERVED));
 	dbg_msg(GGZ_DBG_TABLE, "State      : %d", table->state);
@@ -354,7 +380,7 @@ static int table_start_game(GGZTable *ta
 #endif
 	char **args;
 	char *pwd;
-	int type, i, num_seats, status = 0;
+	int type, i, num_seats, num_spectators, status = 0;
 	GGZSeat seat;
 
 	pthread_rwlock_wrlock(&table->lock);
@@ -381,6 +407,8 @@ static int table_start_game(GGZTable *ta
         ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_JOIN, &table_game_join);
         ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_LEAVE, &table_game_leave);
         ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_SEAT, &table_game_seatchange);
+        ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_SPECTATOR_JOIN, &table_game_spectator_join);
+        ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_SPECTATOR_LEAVE, &table_game_spectator_leave);
         ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_LOG, &table_log);
 	ggzdmod_set_handler(table->ggzdmod, GGZDMOD_EVENT_ERROR, &table_error);
 	
@@ -399,6 +427,10 @@ static int table_start_game(GGZTable *ta
 			status = 1;
         }
 
+	/* Setup spectators */
+	num_spectators = spectators_count(table);
+	ggzdmod_set_num_spectators(table->ggzdmod, num_spectators);
+
 	/* And start the game */
 	ggzdmod_set_module(table->ggzdmod, pwd, args);
 	if (ggzdmod_connect(table->ggzdmod) < 0)
@@ -637,6 +669,125 @@ static void table_game_seatchange(GGZdMo
 	pthread_rwlock_unlock(&table->lock);
 }
 
+/*
+ * table_game_spectator_join handles the RSP_GAME_JOIN_SPECTATOR from the table
+ * Note: table->transit_name contains malloced mem on entry
+ */
+static void table_game_spectator_join(GGZdMod *ggzdmod, GGZdModEvent event, void *data)
+{
+	GGZTable* table = ggzdmod_get_gamedata(ggzdmod);
+	char* name;
+	int spectator_num, msg_status;
+	struct GGZTableSpectator spectator;
+
+	dbg_msg(GGZ_DBG_TABLE, "Table %d in room %d responded to spectator join", 
+		table->index, table->room);
+
+	/* Error: we didn't request a join! */
+	if (!table->transit)
+		return;
+
+	/* Read saved transit data */
+	name = table->transit_name;
+	spectator_num = table->transit_seat;
+
+	/* Notify player of transit status */
+	msg_status = transit_player_event(name, GGZ_TRANSIT_JOIN_SPECTATOR, 0,
+					  table->index);
+	/* FIXME: we still need to handle the case where the join fails */
+
+	/* Transit successful: Assign seat */
+	pthread_rwlock_wrlock(&table->lock);
+	strcpy(table->spectators[spectator_num], name);
+	pthread_rwlock_unlock(&table->lock);
+	
+	/* If player notification failed, they must've logged out */
+	if (msg_status < 0) {
+		dbg_msg(GGZ_DBG_TABLE, "%s logged out during spectator join",
+			name);
+		
+		spectator.index = spectator_num;
+		spectator.name[0] = '\0';
+		spectator.fd = -1;
+		
+		transit_spectator_event(table->room, table->index, spectator, name);
+
+	} else {
+		table_update_event_enqueue(table, GGZ_UPDATE_SPECTATOR_JOIN,
+					   name, spectator_num);
+		dbg_msg(GGZ_DBG_TABLE, 
+			"%s in spectator %d at table %d of room %d",
+			name, spectator_num, table->index, table->room);
+	}
+	
+	/* Clear table for next transit */
+	pthread_rwlock_wrlock(&table->lock);
+	table->transit = 0;
+	free(table->transit_name);
+	table->transit_name = NULL;
+	pthread_rwlock_unlock(&table->lock);
+}
+
+
+/*
+ * table_game_leave handles the RSP_GAME_LEAVE_SPECTATOR from the table
+ */
+static void table_game_spectator_leave(GGZdMod *ggzdmod, GGZdModEvent event, void *data)
+{
+	GGZTable* table = ggzdmod_get_gamedata(ggzdmod);
+	char* name;
+	char status, empty = 0;
+	int spectator;
+
+	dbg_msg(GGZ_DBG_TABLE, "Table %d in room %d responded to spectator leave", 
+		table->index, table->room);
+
+	status = *(char*)data;
+
+	/* Error: we didn't request a leave! */
+	if (!table->transit)
+		return ;
+
+	/* Read in saved transit data */
+	name = table->transit_name;
+	spectator = table->transit_seat;
+	
+	if (status == 0) {
+		/* Vacate seat */
+		dbg_msg(GGZ_DBG_TABLE, 
+			"%s left spectator %d at table %d of room %d", name, spectator,
+			table->index, table->room);
+		
+		pthread_rwlock_wrlock(&table->lock);
+		
+		/* No spectators doesn't mean table is empty */
+		/*if (!spectators_count(table)) {
+			dbg_msg(GGZ_DBG_TABLE, "Table %d in room %d now empty",
+				table->index, table->room);
+			empty = 1;
+		}*/
+		pthread_rwlock_unlock(&table->lock);
+		table_update_event_enqueue(table, GGZ_UPDATE_SPECTATOR_LEAVE, name, 
+					    spectator);
+	}
+
+	/* Notify player and mark transit as done */
+	transit_player_event(name, GGZ_TRANSIT_LEAVE_SPECTATOR, status, 0);
+
+	/* Free strdup'd player name */
+	free(table->transit_name);
+
+	table->transit = 0;
+	table->transit_name = NULL;
+	table->transit_seat = -1;
+
+	/* If the game has set the KillWhenEmpty option, we kill it
+	   when the last player leaves.  If not, we rely on the game
+	   to halt itself. */
+	if (empty && game_types[table->type].kill_when_empty)
+		(void)ggzdmod_disconnect(ggzdmod);
+}
+
 
 static void table_handle_state(GGZdMod *mod, GGZdModEvent event, void *data)
 {
@@ -956,6 +1107,28 @@ int table_find_player(int room, int inde
 	return seat;
 }
 
+/* Find a player at a table */
+int table_find_spectator(int room, int index, char *name)
+{
+	int i, spectators, spectator = -1;
+	GGZTable *table;
+
+	/* grab handle to table (along with write lock) */
+	table = table_lookup(room, index);
+	if(table != NULL) {
+		spectators  = spectators_count(table);
+		for (i = 0; i < spectators; i++)
+			if (table->spectators[i]
+			    && strcasecmp(table->spectators[i], name) == 0) {
+				spectator = i;
+				break;
+			}
+		pthread_rwlock_unlock(&table->lock);
+	}
+
+	return spectator;
+}
+
 
 static int table_event_enqueue(GGZTable* table, GGZUpdateOpcode opcode)
 {
@@ -998,7 +1171,7 @@ static int table_seat_event_enqueue(GGZT
 	struct GGZSeatChange *data;
 
 	if ( (data = malloc(sizeof(struct GGZSeatChange))) == NULL)
-		err_sys_exit("malloc failed in transit_pack");
+		err_sys_exit("malloc failed in table_seat_event_enqueue");
 
 	/* Copy seat data into structure for passing to event */
 	data->seat.index = seat_num;
@@ -1013,6 +1186,27 @@ static int table_seat_event_enqueue(GGZT
 	return status;
 }
 
+static int table_spectator_event_enqueue(GGZTable *table, GGZUpdateOpcode opcode,
+	unsigned int spectator_num)
+{
+	int status;
+	struct GGZSpectatorChange *data;
+
+	if ( (data = malloc(sizeof(struct GGZSpectatorChange))) == NULL)
+		err_sys_exit("malloc failed in table_spectator_event_enqueue");
+
+	/* Copy seat data into structure for passing to event */
+	data->spectator.index = spectator_num;
+	strcpy(data->spectator.name, table->spectators[spectator_num]);
+	data->table = table->index;
+	data->num_spectators = spectators_count(table);
+
+	/* Queue table event for whole room */
+	status = event_room_enqueue(table->room, table_spectator_event_callback, sizeof(data), data);
+	
+	return status;
+}
+
 
 static int table_pack(void** data, unsigned char opcode, GGZTable* table)
 {
@@ -1168,6 +1362,26 @@ static GGZEventFuncReturn table_seat_eve
 	return GGZ_EVENT_OK;
 }
 
+/* Event callback for delivering table list update to a player */
+static GGZEventFuncReturn table_spectator_event_callback(void* target, int size,
+	void* data)
+{
+	GGZTable info;
+	GGZPlayer* player = (GGZPlayer*)target;
+	struct GGZSpectatorChange *spectator_change = data;
+	struct GGZTableSpectator *spectator = &(spectator_change->spectator);
+
+	info.index = spectator_change->table;
+	strcpy(info.spectators[spectator->index], spectator->name);
+	
+	dbg_msg(GGZ_DBG_UPDATE, "%s sees spectator %d change to 'spectator' (%s) at table %d", 
+		player->name, spectator->index, spectator->name, info.index);
+
+	if (net_send_table_update(player->client->net, GGZ_UPDATE_SPECTATOR, &info, spectator->index) < 0)
+		return GGZ_EVENT_ERROR;
+	
+	return GGZ_EVENT_OK;
+}
 
 static int table_launch_event(char* name, int status, int index)
 {
Index: ggzd/table.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/table.h,v
retrieving revision 1.25
diff -u -3 -p -r1.25 table.h
--- ggzd/table.h	5 May 2002 18:43:52 -0000	1.25
+++ ggzd/table.h	20 May 2002 17:21:06 -0000
@@ -80,6 +80,9 @@ struct GGZTable {
 	GGZSeatType seat_types[MAX_TABLE_SIZE];
 	char seat_names[MAX_TABLE_SIZE][MAX_USER_NAME_LEN + 1];
 
+	/* Spectator assignments */
+	char spectators[MAX_TABLE_SIZE][MAX_USER_NAME_LEN + 1];
+
 	/* Client-provided description of this table */
 	char desc[MAX_GAME_DESC_LEN + 1];
 
@@ -111,6 +114,9 @@ int table_search(char* name, int room, i
 
 /* Find a player at a table */
 int table_find_player(int room, int index, char *name);
+
+/* Find a spectator */
+int table_find_spectator(int room, int index, char *name);
 
 
 /*
Index: ggzd/transit.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/transit.c,v
retrieving revision 1.38
diff -u -3 -p -r1.38 transit.c
--- ggzd/transit.c	5 May 2002 18:43:52 -0000	1.38
+++ ggzd/transit.c	20 May 2002 17:21:06 -0000
@@ -54,6 +54,12 @@ struct GGZSeatEvent {
 	char caller[MAX_USER_NAME_LEN + 1];
 };
 
+/* Packaging for spectator events */
+struct GGZSpectatorEvent {
+	struct GGZTableSpectator spectator;
+	char caller[MAX_USER_NAME_LEN + 1];
+};
+
 
 /* Local functions for handling transits */
 static GGZEventFuncReturn transit_player_event_callback(void* target,
@@ -62,17 +68,22 @@ static GGZEventFuncReturn transit_player
 static GGZEventFuncReturn transit_seat_event_callback(void* target,
 						      int size,
 						      void* data);
+static GGZEventFuncReturn transit_spectator_event_callback(void* target,
+	int size, void* data);
 
 static int transit_send_seat_to_game(GGZTable* table, struct GGZSeatEvent *event);
 static int transit_find_seat(GGZTable *table, char *name);
 
+static int transit_send_spectator_to_game(GGZTable* table, struct GGZSpectatorEvent *event);
+static int transit_find_spectator(GGZTable *table, char *name);
+
 int transit_seat_event(int room, int index, struct GGZTableSeat seat, char *caller)
 {
 	int status;
 	struct GGZSeatEvent *data;
 
 	if ( (data = malloc(sizeof(struct GGZSeatEvent))) == NULL)
-		err_sys_exit("malloc failed in transit_pack");
+		err_sys_exit("malloc failed in transit_seat_event");
 
 	data->seat = seat;
 	strcpy(data->caller, caller);
@@ -82,7 +93,22 @@ int transit_seat_event(int room, int ind
 	return status;
 }
 
-    
+int transit_spectator_event(int room, int index, struct GGZTableSpectator spectator, char *caller)
+{
+	int status;
+	struct GGZSpectatorEvent *data;
+
+	if ( (data = malloc(sizeof(struct GGZSpectatorEvent))) == NULL)
+		err_sys_exit("malloc failed in transit_spectator_event");
+
+	data->spectator = spectator;
+	strcpy(data->caller, caller);
+	
+	status = event_table_enqueue(room, index, transit_spectator_event_callback,
+				     sizeof(data), data);
+	return status;
+}
+
 int transit_player_event(char* name, char opcode, int status, int index)
 {
 	int size;
@@ -92,7 +118,7 @@ int transit_player_event(char* name, cha
 	size = sizeof(char) + sizeof(int);
 	
 	/* We pass back the table index and fd if a join was successful */
-	if (opcode == GGZ_TRANSIT_JOIN && status == 0)
+	if ((opcode == GGZ_TRANSIT_JOIN || opcode == GGZ_TRANSIT_JOIN_SPECTATOR) && status == 0)
 		size += sizeof(int);
 
 	if ( (data = malloc(size)) == NULL)
@@ -107,7 +133,7 @@ int transit_player_event(char* name, cha
 	*(int*)current = status;
 	current += sizeof(int);
 
-	if (opcode == GGZ_TRANSIT_JOIN && status == 0) {
+	if ((opcode == GGZ_TRANSIT_JOIN || opcode == GGZ_TRANSIT_JOIN_SPECTATOR) && status == 0) {
 		*(int*)current = index;
 		current += sizeof(int);
 	}
@@ -184,7 +210,70 @@ static GGZEventFuncReturn transit_seat_e
 
 	return status;
 }
+
+/* Executed by table hander thread */
+static GGZEventFuncReturn transit_spectator_event_callback(void* target, 
+	int size, void* data)
+{
+	int status;
+	char action;
+	GGZTable *table = target;
+	struct GGZSpectatorEvent *event = data;
+	struct GGZTableSpectator *spectator = &(event->spectator);
+
+	dbg_msg(GGZ_DBG_TABLE, 
+		"%s requested spectator change on table %d: Spectator %d to 'spectator' (%s) with fd %d", 
+		event->caller, table->index, spectator->index, 
+		spectator->name, spectator->fd);
+
+	action = GGZ_TRANSIT_JOIN_SPECTATOR;
+	if (table->spectators[spectator->index][0])
+		action = GGZ_TRANSIT_JOIN_SPECTATOR;
+
+
+	/* If this table is already in transit, defer event until later */
+	if (table->transit) {
+		dbg_msg(GGZ_DBG_TABLE, 
+			"Deferring transit for table %d in room %d",
+			table->index, table->room);
+		return GGZ_EVENT_DEFER;
+	}
+
+	/* Make sure table is in an acceptable state */
+	if (table->state == GGZ_TABLE_ERROR || table->state == GGZ_TABLE_DONE) {
+		/* Notify player that transit failed */
+		/* Don't care if this fails, we aren't transiting anyway */
+		transit_player_event(event->caller, action, E_BAD_OPTIONS, 0);
+		return GGZ_EVENT_OK;
+	}
+
+
+	/* Try to find a seat if one isn't specified */
+	if (action == GGZ_TRANSIT_JOIN_SPECTATOR && spectator->index == GGZ_SEATNUM_ANY) {
+		if ( (spectator->index = transit_find_spectator(table, event->caller)) < 0) {
+			/* Don't care if this fails, we aren't transiting anyway */
+fprintf(stderr, "XXX transit/ggz_transit_join_spectator\n");
+			transit_player_event(event->caller, action, E_TABLE_FULL, 0);
+			return GGZ_EVENT_OK;
+		}
+	}
 		
+	status = transit_send_spectator_to_game(table, event);
+fprintf(stderr, "XXX transit_send_spectator: %i\n", status);
+
+	/* If we sent it successfully, mark this table as in transit */
+	if (status == 0) {
+		table->transit = 1;
+		status = GGZ_EVENT_OK;
+	}
+	/* Otherwise send an error message back to the player */
+	else {
+		transit_player_event(event->caller, action, E_SEAT_ASSIGN_FAIL, 0);
+		status = GGZ_EVENT_ERROR;
+	}
+
+	return status;
+}
 
 static GGZEventFuncReturn transit_player_event_callback(void* target,
                                                         int size,
@@ -204,7 +293,7 @@ static GGZEventFuncReturn transit_player
 	status = *(int*)(current);
 	current += sizeof(int);
 
-	if (opcode == GGZ_TRANSIT_JOIN && status == 0) {
+	if ((opcode == GGZ_TRANSIT_JOIN || (opcode == GGZ_TRANSIT_JOIN_SPECTATOR)) && status == 0) {
 		index = *(int*)(current);
 		current += sizeof(int);
 	}
@@ -234,6 +323,17 @@ static GGZEventFuncReturn transit_player
 		if (net_send_table_join(player->client->net, (char)status) < 0)
 			return GGZ_EVENT_ERROR;
 		break;
+	case GGZ_TRANSIT_JOIN_SPECTATOR:
+		pthread_rwlock_wrlock(&player->lock);
+		player->transit = 0;
+		if (status == 0) {
+			player->table = index;
+		}
+		pthread_rwlock_unlock(&player->lock);
+
+		if (net_send_table_join_spectator(player->client->net, (char)status) < 0)
+			return GGZ_EVENT_ERROR;
+		break;
 	case GGZ_TRANSIT_SEAT:
 		if (net_send_update_result(player->client->net, (char)status) < 0)
 			return GGZ_EVENT_ERROR;
@@ -288,6 +388,49 @@ static int transit_send_seat_to_game(GGZ
 	return status;
 }
 
+/*
+ * transit_send_spectator_to_game sets the spectator on ggzdmod
+ *
+ * Returns 0 on success, -1 on failure (in which case the
+ * player should be sent an failure notice).
+ */
+static int transit_send_spectator_to_game(GGZTable* table, struct GGZSpectatorEvent *event)
+{
+	GGZSpectator spectator;
+	int status = 0;
+
+	dbg_msg(GGZ_DBG_TABLE, "Sending spectator for table %d in room %d",
+		table->index, table->room);
+	
+	/* Save transit info so we have it when game module responds */
+	table->transit_name = strdup(event->caller);
+	table->transit_seat = event->spectator.index;
+
+	/* Assemble seat structure */
+	spectator.num = event->spectator.index;
+	spectator.fd = event->spectator.fd;
+	/* Only dup name if it's not empty */
+	if (event->spectator.name[0] != '\0')
+		spectator.name = strdup(event->spectator.name);
+	else
+		spectator.name = NULL;
+
+fprintf(stderr, "XXX spectator data: name=%s, num=%i, fd=%i\n", spectator.name, spectator.num, spectator.fd);
+
+	if (ggzdmod_set_spectator(table->ggzdmod, &spectator) < 0) {
+		dbg_msg(GGZ_DBG_TABLE, "ERROR: transit_send_spectator_to_game: failed ggzdmod_set_spectator() call.");
+		status = -1;
+	}
+
+	if (spectator.name)
+		free(spectator.name);
+	
+	/* Must close remote end of socketpair */
+	close(spectator.fd);
+	
+	return status;
+}
+
 
 static int transit_find_seat(GGZTable *table, char *name)
 {
@@ -306,3 +449,19 @@ static int transit_find_seat(GGZTable *t
 
 	return -1;
 }
+
+static int transit_find_spectator(GGZTable *table, char *name)
+{
+	int i, num_spectators = spectators_count(table);
+
+fprintf(stderr, "XXX We have %i spectator places, let's find an open one...\n", num_spectators);
+fprintf(stderr, "XXX First one is: %s\n", table->spectators[0]);
+
+	/* If that failed, look for first open spectator. */
+	for (i = 0; i < num_spectators; i++)
+		if (!table->spectators[i][0])
+			return i;
+
+	return -1;
+}
+
Index: ggzd/transit.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzd/transit.h,v
retrieving revision 1.5
diff -u -3 -p -r1.5 transit.h
--- ggzd/transit.h	5 May 2002 18:43:52 -0000	1.5
+++ ggzd/transit.h	20 May 2002 17:21:06 -0000
@@ -29,9 +29,12 @@
 #define GGZ_TRANSIT_JOIN   0x01  /* %0000 0001 */
 #define GGZ_TRANSIT_LEAVE  0x02  /* %0000 0010 */
 #define GGZ_TRANSIT_SEAT   0x04
+#define GGZ_TRANSIT_JOIN_SPECTATOR 0x08
+#define GGZ_TRANSIT_LEAVE_SPECTATOR 0x10
 
 int transit_table_event(int room, int index, char opcode, char* name);
 
 int transit_seat_event(int room, int index, struct GGZTableSeat seat, char *caller);
+int transit_spectator_event(int room, int index, struct GGZTableSpectator spectator, char *caller);
 
 int transit_player_event(char* name, char opcode, int status, int index);
Index: ggzdmod/ggzdmod.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/ggzdmod.c,v
retrieving revision 1.84
diff -u -3 -p -r1.84 ggzdmod.c
--- ggzdmod/ggzdmod.c	5 May 2002 00:22:08 -0000	1.84
+++ ggzdmod/ggzdmod.c	20 May 2002 17:21:07 -0000
@@ -64,6 +64,7 @@ static void call_handler(GGZdMod *ggzdmo
 static int get_fd_max(GGZdMod * ggzdmod);
 static fd_set get_active_fd_set(GGZdMod * ggzdmod);
 static void _ggzdmod_set_num_seats(GGZdMod * ggzdmod, int num_seats);
+static void _ggzdmod_set_num_spectators(GGZdMod * ggzdmod, int num_spectators);
 static int strings_differ(char *s1, char *s2);
 static void set_state(GGZdMod * ggzdmod, GGZdModState state);
 static int handle_event(GGZdMod * ggzdmod, fd_set read_fds);
@@ -76,6 +77,12 @@ static int seat_compare(GGZSeat *a, GGZS
 static int seat_find_player(GGZSeat *a, GGZSeat *b);
 static void seat_free(GGZSeat *seat);
 
+/* Functions for manipulating spectators */
+static GGZSpectator* spectator_copy(GGZSpectator *orig);
+static int spectator_compare(GGZSpectator *a, GGZSpectator *b);
+static int spectator_find_player(GGZSpectator *a, GGZSpectator *b);
+static void spectator_free(GGZSpectator *spectator);
+
 /* Debugging function (see also ggzdmod_check) */
 static void seat_print(GGZdMod * ggzdmod, GGZSeat *seat);
 
@@ -97,8 +104,8 @@ static void call_handler(GGZdMod * ggzdm
 				    event, which);
 		else
 			fprintf(stderr,
-				"GGZDMOD: unhandled event %d by %s.\n",
-				event, which);
+				"GGZDMOD: unhandled error event %d by %s: %s\n",
+				event, which, (char*)data);
 	}
 }
 
@@ -179,6 +186,12 @@ GGZdMod *ggzdmod_new(GGZdModType type)
 					 (ggzEntryCreate)seat_copy,
 					 (ggzEntryDestroy)seat_free,
 					 GGZ_LIST_REPLACE_DUPS);
+	ggzdmod->spectators = ggz_list_create((ggzEntryCompare)spectator_compare,
+					(ggzEntryCreate)spectator_copy,
+					(ggzEntryDestroy)spectator_free,
+					GGZ_LIST_REPLACE_DUPS);
+	ggzdmod->num_seats = 0;
+	ggzdmod->num_spectators = 0;
 
 	for (i = 0; i < GGZDMOD_NUM_HANDLERS; i++)
 		ggzdmod->handlers[i] = NULL;
@@ -208,6 +221,8 @@ void ggzdmod_free(GGZdMod * ggzdmod)
 	
 	ggz_list_free(ggzdmod->seats);
 	ggzdmod->num_seats = 0;
+	ggz_list_free(ggzdmod->spectators);
+	ggzdmod->num_spectators = 0;
 
 	ggzdmod->type = -1;
 
@@ -269,6 +284,16 @@ int ggzdmod_get_num_seats(GGZdMod * ggzd
 }
 
 
+int ggzdmod_get_num_spectators(GGZdMod * ggzdmod)
+{
+	if (!CHECK_GGZDMOD(ggzdmod) || ggzdmod->fd < 0) {
+		return -1;
+	}
+
+	return ggzdmod->num_spectators;
+}
+
+
 GGZSeat ggzdmod_get_seat(GGZdMod * ggzdmod, int num)
 {
 	GGZSeat seat = {num, GGZ_SEAT_NONE, NULL, -1};
@@ -283,6 +308,19 @@ GGZSeat ggzdmod_get_seat(GGZdMod * ggzdm
 }
 
 
+GGZSpectator ggzdmod_get_spectator(GGZdMod * ggzdmod, int num)
+{
+	GGZSpectator spectator = {num, NULL, -1};
+	GGZListEntry *entry;
+
+	if (CHECK_GGZDMOD(ggzdmod) && num >= 0 && num < ggzdmod->num_spectators) {
+		if ((entry = ggz_list_search(ggzdmod->spectators, &spectator)))
+			spectator = *(GGZSpectator*)ggz_list_get_data(entry);
+	}
+
+	return spectator;
+}
+
 void* ggzdmod_get_gamedata(GGZdMod * ggzdmod)
 {
 	if (!CHECK_GGZDMOD(ggzdmod)) {
@@ -318,6 +356,30 @@ static void _ggzdmod_set_num_seats(GGZdM
 }
 
 
+static void _ggzdmod_set_num_spectators(GGZdMod *ggzdmod, int num_spectators)
+{
+	GGZSpectator spectator;
+	int i, old_num;
+
+	old_num = ggzdmod->num_spectators;
+	
+	/* See the appropriate seat function */
+	if (num_spectators > old_num) {
+		for (i = old_num; i < num_spectators; i++) {
+			spectator.num = i;
+			spectator.name = NULL;
+			spectator.fd = -1;
+			ggz_list_insert(ggzdmod->spectators, &spectator);
+		}
+	}
+	else if (num_spectators < old_num) {
+		/* FIXME: delete extra spectators */
+	}
+	
+	ggzdmod->num_spectators = num_spectators;
+}
+
+
 void ggzdmod_set_num_seats(GGZdMod * ggzdmod, int num_seats)
 {
 	/* Check parameters */
@@ -328,7 +390,18 @@ void ggzdmod_set_num_seats(GGZdMod * ggz
 	
 	_ggzdmod_set_num_seats(ggzdmod, num_seats);
 }
-			   
+
+void ggzdmod_set_num_spectators(GGZdMod * ggzdmod, int num_spectators)
+{
+	/* Check parameters */
+	if (!CHECK_GGZDMOD(ggzdmod) || num_spectators < 0
+	    || ggzdmod->type != GGZDMOD_GGZ) {
+		return;		/* not very useful */
+	}
+	
+	_ggzdmod_set_num_spectators(ggzdmod, num_spectators);
+}
+		   
 void ggzdmod_set_module(GGZdMod * ggzdmod,
                         const char *pwd, char **argv)
 {
@@ -488,6 +561,77 @@ int ggzdmod_set_seat(GGZdMod * ggzdmod, 
 	return _ggzdmod_set_seat(ggzdmod, seat);
 }
 
+static int _ggzdmod_set_spectator(GGZdMod * ggzdmod, GGZSpectator *spectator)
+{
+	ggz_debug("GGZDMOD", "Spectator %d set to type 'spectator' (%s)",
+		  spectator->num, spectator->name);
+
+	/* Note, some other parts of the code assume that if
+	   ggzdmod-game changes spectator information, the data is not sent back
+	   to ggzdmod-ggz.  Specifically, the game server is allowed to change
+	   the player FD (if it is -1). */
+
+	/* If we're connected to the game, send a message */
+	if (ggzdmod->type == GGZDMOD_GGZ
+	    && ggzdmod->state != GGZDMOD_STATE_CREATED) {
+		GGZSpectator oldspectator = ggzdmod_get_spectator(ggzdmod, spectator->num);
+		
+		/* Detect join case */
+		if (!oldspectator.name) {
+		        /* We could check the seat name for a reserved seat,
+		           but we trust ggzd to do that instead. */
+			if (_io_send_spectator_join(ggzdmod->fd, spectator) < 0)
+				_ggzdmod_error(ggzdmod,
+					       "Error writing to game");
+
+			/* We (GGZ) don't need the fd now */
+			spectator->fd = -1;
+		}
+
+		/* Detect leave case */
+		else  {
+			if (_io_send_spectator_leave(ggzdmod->fd, &oldspectator) < 0)
+				_ggzdmod_error(ggzdmod,
+					       "Error writing to game");
+		}
+	}
+
+	ggz_list_insert(ggzdmod->spectators, spectator);
+	
+	return 0;
+}
+
+
+int ggzdmod_set_spectator(GGZdMod * ggzdmod, GGZSpectator *spectator)
+{
+	GGZSpectator oldspectator;
+
+	if (!CHECK_GGZDMOD(ggzdmod) || !spectator || spectator->num < 0
+	    || spectator->num >= ggzdmod->num_spectators) {
+		return -2;		
+	}
+
+	/* FIXME: check for correctness, (ie. name not NULL for reserved) */
+
+fprintf(stderr, "YYY set spectator...\n");
+
+	/* If there is already a spectator, return error */
+	oldspectator = ggzdmod_get_spectator(ggzdmod, spectator->num);
+	if (oldspectator.name)
+		return -1;
+
+fprintf(stderr, "YYY check for game restriction\n");
+
+	if (ggzdmod->type == GGZDMOD_GAME) {
+		    if(strings_differ(spectator->name, oldspectator.name))
+			return -1;
+	}
+
+fprintf(stderr, "YYY _set spectator...\n");
+
+	return _ggzdmod_set_spectator(ggzdmod, spectator);
+}
+
 
 /* This information could be tracked every time  a player
    leaves/joins, but that's not really necessary at this point. */
@@ -735,7 +879,7 @@ static int send_game_launch(GGZdMod * gg
 	GGZSeat *seat;
 		
 
-	if (_io_send_launch(ggzdmod->fd, ggzdmod->num_seats) < 0) {
+	if (_io_send_launch(ggzdmod->fd, ggzdmod->num_seats, ggzdmod->num_spectators) < 0) {
 		_ggzdmod_error(ggzdmod, "Error writing to game");
 		return -1;
 	}
@@ -970,6 +1114,24 @@ void _ggzdmod_handle_seat_response(GGZdM
 }
 
 
+void _ggzdmod_handle_spectator_join_response(GGZdMod * ggzdmod, char status)
+{
+	if (status == 0)
+		call_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_JOIN, NULL);
+	else
+		_ggzdmod_error(ggzdmod, "Spectator failed to join");
+}
+
+
+void _ggzdmod_handle_spectator_leave_response(GGZdMod * ggzdmod, char status)
+{
+	if (status == 0)
+		call_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_LEAVE, NULL);
+	else
+		_ggzdmod_error(ggzdmod, "Spectator failed to leave");
+}
+
+
 void _ggzdmod_handle_state(GGZdMod * ggzdmod, GGZdModState state)
 {
 	_io_respond_state(ggzdmod->fd);
@@ -1011,7 +1173,7 @@ void _ggzdmod_handle_log(GGZdMod * ggzdm
 
 
 /* Game-side event: launch event received from ggzd */
-void _ggzdmod_handle_launch_begin(GGZdMod * ggzdmod, int num_seats)
+void _ggzdmod_handle_launch_begin(GGZdMod * ggzdmod, int num_seats, int num_spectators)
 {
 #if 0
 	int bots = 0;
@@ -1021,15 +1183,16 @@ void _ggzdmod_handle_launch_begin(GGZdMo
 	randomize_names(bot_names, rand_bot_names, NUM_BOT_NAMES);
 #endif
 
-	if (num_seats <= 0) {
-		_ggzdmod_error(ggzdmod, "Error: %d seats received from GGZ");
+	if ((num_seats < 0) || (num_spectators < 0) || (num_seats + num_spectators <= 0)) {
+		_ggzdmod_error(ggzdmod, "Error: zero seats and spectators received from GGZ");
 		ggzdmod_log(ggzdmod,
-			    "GGZDMOD: ERROR: %d seats sent upon launch.",
-			    num_seats);
+			    "GGZDMOD: ERROR: %d seats, %d spectators sent upon launch.",
+			    num_seats, num_spectators);
 		return;
 	}
 
 	_ggzdmod_set_num_seats(ggzdmod, num_seats);
+	_ggzdmod_set_num_spectators(ggzdmod, num_spectators);
 }
 
 
@@ -1100,17 +1263,17 @@ void _ggzdmod_handle_join(GGZdMod * ggzd
 	}
 	old_seat = (GGZSeat*)ggz_list_get_data(entry);
 	old_seat = seat_copy(old_seat);
-      
+
 	/* Place the new seat into the list */
 	ggz_list_insert(ggzdmod->seats, &seat);
 	ggzdmod_log(ggzdmod, "GGZDMOD: %s on fd %d in seat %d",
-	seat.name, seat.fd, seat.num);
+		seat.name, seat.fd, seat.num);
 	
 	/* Invoke the handler.  Most games will want to change their
 	   status to PLAYING at this point, but we leave that entirely
 	   up to them (via ggzdmod_set_state()). */
 	call_handler(ggzdmod, GGZDMOD_EVENT_JOIN, old_seat);
-      
+
 	/* Free old_seat */
 	seat_free(old_seat);
 
@@ -1139,12 +1302,12 @@ void _ggzdmod_handle_leave(GGZdMod * ggz
 		               "non-existant player tried to leave.");
 		return;
 	}
-              
+
 	status = 0;
 	seat = *(GGZSeat*)ggz_list_get_data(entry);
 	ggzdmod_log(ggzdmod, "GGZDMOD: Removed %s from seat %d",
 	           seat.name, seat.num);
-              
+
 	/* Copy seat to old_seat. */
 	old_seat = seat_copy(&seat);
 
@@ -1174,7 +1337,6 @@ void _ggzdmod_handle_seat(GGZdMod * ggzd
 	GGZSeat *old_seat;
 	GGZListEntry *entry;
 
-
 	/* Copy current seat to old_seat */
 	entry = ggz_list_search(ggzdmod->seats, &seat);
 	if (!entry) {
@@ -1185,15 +1347,15 @@ void _ggzdmod_handle_seat(GGZdMod * ggzd
 	}
 	old_seat = (GGZSeat*)ggz_list_get_data(entry);
 	old_seat = seat_copy(old_seat);
-      
+
 	/* Place the new seat into the list */
 	ggz_list_insert(ggzdmod->seats, &seat);
 	ggzdmod_log(ggzdmod, "GGZDMOD: %s on fd %d in seat %d",
 	            seat.name, seat.fd, seat.num);
-              
+
 	/* Invoke the handler */
 	call_handler(ggzdmod, GGZDMOD_EVENT_SEAT, old_seat);
-      
+
 	/* Free old_seat */
 	seat_free(old_seat);
  
@@ -1201,6 +1363,83 @@ void _ggzdmod_handle_seat(GGZdMod * ggzd
 		_ggzdmod_error(ggzdmod, "Error sending data to GGZ");
 }
 
+/* game-side event: spectator join event received from ggzd.  */
+void _ggzdmod_handle_spectator_join(GGZdMod * ggzdmod, GGZSpectator spectator)
+{
+	GGZSpectator *old_spectator;
+	GGZListEntry *entry;
+
+	/* Copy current spectator to old_spectator */
+	entry = ggz_list_search(ggzdmod->spectators, &spectator);
+	if (!entry) {
+		_ggzdmod_error(ggzdmod,
+		               "GGZDMOD: Error: "
+		               "non-existant spectator tried to join.");
+		return;
+	}
+	old_spectator = (GGZSpectator*)ggz_list_get_data(entry);
+	old_spectator = spectator_copy(old_spectator);
+
+	/* Place the new spectator into the list */
+	ggz_list_insert(ggzdmod->spectators, &spectator);
+	ggzdmod_log(ggzdmod, "GGZDMOD: %s on fd %d in spectator %d",
+		spectator.name, spectator.fd, spectator.num);
+	
+	/* Invoke the handler.  */
+	call_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_JOIN, old_spectator);
+
+	/* Free old_spectator */
+	spectator_free(old_spectator);
+
+	/* Send response to GGZ */
+	if (_io_respond_spectator_join(ggzdmod->fd) < 0)
+		_ggzdmod_error(ggzdmod, "GGZDMOD: Error sending data to GGZ");
+}
+
+
+/* game-side event: spectator leave received from ggzd */
+void _ggzdmod_handle_spectator_leave(GGZdMod * ggzdmod, char *name)
+{
+	char status = -1;
+	GGZListEntry *entry;
+	GGZSpectator spectator;
+	GGZSpectator *old_seat;
+
+	/* Set spectator name, and see if we find anybody who matches */
+	spectator.name = name;
+	entry = ggz_list_search_alt(ggzdmod->spectators, &spectator,
+		(ggzEntryCompare)spectator_find_player);
+
+	if (!entry) {
+		_ggzdmod_error(ggzdmod,
+		               "GGZDMOD: Error: "
+		               "non-existant spectator tried to leave.");
+		return;
+	}
+
+	status = 0;
+	spectator = *(GGZSpectator*)ggz_list_get_data(entry);
+	ggzdmod_log(ggzdmod, "GGZDMOD: Removed %s from seat %d",
+	           spectator.name, spectator.num);
+
+	/* Copy seat to old_seat. */
+	old_seat = spectator_copy(&spectator);
+
+	/* Reset seat to open state, and reinsert into list */
+	spectator.fd = -1;
+	spectator.name = NULL;
+	ggz_list_insert(ggzdmod->spectators, &spectator);
+
+	/* Invoke the handler. */
+	call_handler(ggzdmod, GGZDMOD_EVENT_SPECTATOR_LEAVE, old_seat);
+
+	/* Delete old_seat */
+	spectator_free(old_seat);
+
+	if (_io_respond_spectator_leave(ggzdmod->fd, status) < 0)
+		_ggzdmod_error(ggzdmod, "Error sending data to GGZ");
+}
+
 
 /* game-side event: game state response received from ggzd */
 void _ggzdmod_handle_state_response(GGZdMod * ggzdmod)
@@ -1265,6 +1504,50 @@ static void seat_print(GGZdMod * ggzdmod
 	char *type = ggz_seattype_to_string(seat->type);
 	ggzdmod_log(ggzdmod, "GGZDMOD: Seat %d is %s (%s) on %d",
 		    seat->num, type, seat->name, seat->fd);
+}
+
+
+/* Create a new copy of a spectator object */
+static GGZSpectator* spectator_copy(GGZSpectator *orig)
+{
+	GGZSpectator *spectator;
+
+	spectator = ggz_malloc(sizeof(GGZSpectator));
+
+	spectator->num = orig->num;
+	spectator->fd = orig->fd;
+	
+	/* The name may be NULL if unknown. */
+	spectator->name = orig->name ? ggz_strdup(orig->name) : NULL;
+	
+	return spectator;
+}
+
+
+static int spectator_compare(GGZSpectator *a, GGZSpectator *b)
+{
+	return a->num - b->num;
+}
+
+
+/* See the appropriate seat function */
+static int spectator_find_player(GGZSpectator *a, GGZSpectator *b)
+{
+	if (!a->name || !b->name)
+		return 1;
+
+	return strcmp(a->name, b->name);
+}
+
+
+static void spectator_free(GGZSpectator *spectator)
+{
+	if (spectator->fd != -1)
+		close(spectator->fd);
+	if (spectator->name)
+		ggz_free(spectator->name);
+
+	ggz_free(spectator);
 }
 
 
Index: ggzdmod/ggzdmod.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/ggzdmod.h,v
retrieving revision 1.47
diff -u -3 -p -r1.47 ggzdmod.h
--- ggzdmod/ggzdmod.h	13 May 2002 18:46:16 -0000	1.47
+++ ggzdmod/ggzdmod.h	20 May 2002 17:21:07 -0000
@@ -233,23 +233,33 @@ typedef enum {
 	 *  state (a GGZdModState*) is passed as the event's data.
 	 *  @see GGZdModState */
 	GGZDMOD_EVENT_STATE,
-	
+
 	/** @brief Player joined
 	 *  This event occurs when a player joins the table.  The
 	 *  old seat (a GGZSeat*) is passed as the event's data.
 	 *  The seat information will be updated before the event
 	 *  is invoked.
 	 *  @note This may be dropped in favor of the SEAT event. */
-	GGZDMOD_EVENT_JOIN,		
-	
+	GGZDMOD_EVENT_JOIN,
+
 	/** @brief Player left
 	 *  This event occurs when a player leaves the table.  The
 	 *  old seat (a GGZSeat*) is passed as the event's data.
 	 *  The seat information will be updated before the event
 	 *  is invoked.
 	 *  @note This may be dropped in favor of the SEAT event */
-	GGZDMOD_EVENT_LEAVE,		
-	
+	GGZDMOD_EVENT_LEAVE,
+
+	/** @brief A spectator joins the game
+	 *  The spectator information is passed as a (GGZSpectator*) with the event
+	 *  data. */
+	GGZDMOD_EVENT_SPECTATOR_JOIN,
+
+	/** @brief A spectator left the game
+	 *  The old spectator data can be obtained via the (GGZSpectator) which is
+	 *  passed as the event data. */
+	GGZDMOD_EVENT_SPECTATOR_LEAVE,
+
 	/** @brief General seat change
 	 *  This event occurs when a seat change other than a player
 	 *  leave/join happens (which is currently impossible).  The
@@ -257,27 +267,27 @@ typedef enum {
 	 *  seat information will be updated before the event is invoked.
 	 *  @note This is currently unused, but may eventually replace JOIN and LEAVE.
 	 */
-	GGZDMOD_EVENT_SEAT,		
-	
+	GGZDMOD_EVENT_SEAT,
+
 	/** @brief Module log request
 	 *  This event occurs when a log request happens.  This will
 	 *  only be used by the GGZ server; the game server should
 	 *  use ggzdmod_log to generate the log. */
-	GGZDMOD_EVENT_LOG,		
-	
+	GGZDMOD_EVENT_LOG,
+
 	/** @brief Data available from player
 	 *  This event occurs when there is data ready to be read from
 	 *  one of the player sockets.  The player number (an int*) is
 	 *  passed as the event's data. */
-	GGZDMOD_EVENT_PLAYER_DATA,	
-	
+	GGZDMOD_EVENT_PLAYER_DATA,
+
 	/** @brief An error has occurred
 	 *  This event occurs when a GGZdMod error has occurred.  An
 	 *  error message (a char*) will be passed as the event's data.
 	 *  GGZdMod may attempt to recover from the error, but it is
 	 *  not guaranteed that the GGZ connection will continue to
 	 *  work after an error has happened. */
-	GGZDMOD_EVENT_ERROR		
+	GGZDMOD_EVENT_ERROR
 } GGZdModEvent;
 
 /** @brief The "type" of ggzdmod.
@@ -309,6 +319,8 @@ typedef struct GGZdMod GGZdMod;
  *    - GGZDMOD_EVENT_JOIN: The old seat (GGZSeat*)
  *    - GGZDMOD_EVENT_LEAVE: The old seat (GGZSeat*)
  *    - GGZDMOD_EVENT_SEAT: The old seat (GGZSeat*)
+ *    - GGZDMOD_EVENT_SPECTATOR_JOIN: The spectator as in (GGZSpectator*)
+ *    - GGZDMOD_EVENT_SPECTATOR_LEAVE: The old spectator's data (GGZSpectator*)
  *    - GGZDMOD_EVENT_LOG: The message string (char*)
  *    - GGZDMOD_EVENT_PLAYER_DATA: The player number (int*)
  *    - GGZDMOD_EVENT_ERROR: An error string (char*)
@@ -326,6 +338,16 @@ typedef struct {
 	int fd;			/**< fd to communicate with seat occupant. */
 } GGZSeat;
 
+/** @brief A game spectator entry
+ *
+ *  Spectators are handles differently from other player types.
+ */
+typedef struct {
+	int num;		/**< Spectator seat index */
+	char *name;		/**< The spectator's name */
+	int fd;			/**< File descriptor for communication */
+} GGZSpectator;
+
 /* 
  * Creation functions
  */
@@ -400,12 +422,32 @@ void * ggzdmod_get_gamedata(GGZdMod * gg
  *  @todo Allow the table to change the number of seats. */
 void ggzdmod_set_num_seats(GGZdMod * ggzdmod, int num_seats);
 
+/** @brief Set the number of spectatorss for the table.
+ *  @param ggzdmod The GGZdMod object.
+ *  @param num_spectators The number of spectators to set.
+ *  @note This will only work for ggzd.
+ *  @todo Allow the table to change the number of spectators. */
+void ggzdmod_set_num_spectators(GGZdMod * ggzdmod, int num_spectators);
+
 /** @brief Set gamedata pointer
  *  @param ggzdmod The GGZdMod object.
  *  @param data The gamedata block (or NULL for none).
  *  @see ggzdmod_get_gamedata */
 void ggzdmod_set_gamedata(GGZdMod * ggzdmod, void * data);
 
+/** @brief Get the number of spectators in the game.
+ *  @return The number of spectators, or -1 on error.
+ *  @note If no connection is present, -1 will be returned.
+ */
+int ggzdmod_get_num_spectators(GGZdMod *ggzdmod);
+
+/** @brief Get a spectator's data.
+ *  @param ggzdmod The GGZdMod object.
+ *  @param spectator The number, between 0 and (number of spectators - 1).
+ *  @return A valid GGZSpectator structure, if arguments are valid.
+ */
+GGZSpectator ggzdmod_get_spectator(GGZdMod * ggzdmod, int spectator);
+
 /** @brief Set a handler for the given event.
  *
  *  As described above, GGZdmod uses an event-driven structure.  Each
@@ -446,6 +488,17 @@ void ggzdmod_set_module(GGZdMod * ggzdmo
  *  @todo The game should be able to kick a player out of the table.
  */
 int ggzdmod_set_seat(GGZdMod * ggzdmod, GGZSeat * seat);
+
+/** @brief Set spectator data.
+ *
+ *  A game server or the ggz server can use this function to set
+ *  data about a spectator.  The game server may only change the following
+ *  things about a spectator:
+ *    - The socket FD (only if the FD is -1).
+ *  @param spectator The new spectator structure (which includes spectator number).
+ *  @return 0 on success, negative on failure.
+ */
+int ggzdmod_set_spectator(GGZdMod * ggzdmod, GGZSpectator * spectator);
 
 /** @brief Count seats of the given type.
  *
Index: ggzdmod/io.c
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/io.c,v
retrieving revision 1.10
diff -u -3 -p -r1.10 io.c
--- ggzdmod/io.c	2 Mar 2002 01:06:30 -0000	1.10
+++ ggzdmod/io.c	20 May 2002 17:21:07 -0000
@@ -44,6 +44,10 @@ static int _io_read_req_join(GGZdMod *gg
 static int _io_read_rsp_join(GGZdMod *ggzdmod);
 static int _io_read_req_leave(GGZdMod *ggzdmod);
 static int _io_read_rsp_leave(GGZdMod *ggzdmod);
+static int _io_read_req_spectator_join(GGZdMod *ggzdmod);
+static int _io_read_rsp_spectator_join(GGZdMod *ggzdmod);
+static int _io_read_req_spectator_leave(GGZdMod *ggzdmod);
+static int _io_read_rsp_spectator_leave(GGZdMod *ggzdmod);
 static int _io_read_req_state(GGZdMod *ggzdmod);
 static int _io_read_msg_log(GGZdMod *ggzdmod);
 static int _io_read_req_seat(GGZdMod * ggzdmod);
@@ -51,10 +55,11 @@ static int _io_read_rsp_seat(GGZdMod *gg
 
 
 /* Functions for sending IO messages */
-int _io_send_launch(int fd, int seats)
+int _io_send_launch(int fd, int seats, int spectators)
 {
 	if (ggz_write_int(fd, MSG_GAME_LAUNCH) < 0 
-	    || ggz_write_int(fd, seats) < 0)
+	    || ggz_write_int(fd, seats) < 0
+		|| ggz_write_int(fd, spectators) < 0)
 		return -1;
 	else
 		return 0;
@@ -108,6 +113,26 @@ int _io_send_leave(int fd, GGZSeat *seat
 		return 0;
 }
 
+int _io_send_spectator_join(int fd, GGZSpectator *spectator)
+{
+	ggz_debug("GGZDMOD", "Sending spectator join");
+	if (ggz_write_int(fd, REQ_GAME_SPECTATOR_JOIN) < 0
+	    || ggz_write_int(fd, spectator->num) < 0
+	    || ggz_write_string(fd, spectator->name) < 0
+	    || ggz_write_fd(fd, spectator->fd) < 0)
+		return -1;
+	else
+		return 0;
+}
+
+int _io_send_spectator_leave(int fd, GGZSpectator *spectator)
+{
+	if (ggz_write_int(fd, REQ_GAME_SPECTATOR_LEAVE) < 0
+	    || ggz_write_string(fd, spectator->name) < 0)
+		return -1;
+	else
+		return 0;
+}
 
 int _io_send_state(int fd, GGZdModState state)
 {
@@ -163,6 +188,24 @@ int _io_respond_leave(int fd, int status
 		return 0;
 }
 
+int _io_respond_spectator_join(int fd)
+{
+	if (ggz_write_int(fd, RSP_GAME_SPECTATOR_JOIN) < 0
+	    || ggz_write_char(fd, 0) < 0)
+		return -1;
+	else
+		return 0;
+}
+
+int _io_respond_spectator_leave(int fd, int status)
+{
+	if (ggz_write_int(fd, RSP_GAME_SPECTATOR_LEAVE) < 0 
+	    || ggz_write_char(fd, status) < 0)
+		return -1;
+	else
+		return 0;
+}
+
 
 int _io_respond_seat(int fd, int status)
 {
@@ -202,6 +245,12 @@ int _io_read_data(GGZdMod * ggzdmod)
 		case REQ_GAME_SEAT:
 			status = _io_read_req_seat(ggzdmod);
 			break;
+		case REQ_GAME_SPECTATOR_JOIN:
+			status = _io_read_req_spectator_join(ggzdmod);
+			break;
+		case REQ_GAME_SPECTATOR_LEAVE:
+			status = _io_read_req_spectator_leave(ggzdmod);
+			break;
 		case RSP_GAME_STATE:
 			_ggzdmod_handle_state_response(ggzdmod);
 			break;
@@ -220,6 +269,12 @@ int _io_read_data(GGZdMod * ggzdmod)
 		case RSP_GAME_SEAT:
 			status = _io_read_rsp_seat(ggzdmod);
 			break;
+		case RSP_GAME_SPECTATOR_JOIN:
+			status = _io_read_rsp_spectator_join(ggzdmod);
+			break;
+		case RSP_GAME_SPECTATOR_LEAVE:
+			status = _io_read_rsp_spectator_leave(ggzdmod);
+			break;
 		case REQ_GAME_STATE:
 			status = _io_read_req_state(ggzdmod);
 			break;
@@ -259,6 +314,30 @@ static int _io_read_rsp_leave(GGZdMod * 
 	return 0;
 }
 
+static int _io_read_rsp_spectator_join(GGZdMod *ggzdmod)
+{
+	char status;
+
+	if (ggz_read_char(ggzdmod->fd, &status) < 0)
+		return -1;
+	else
+		_ggzdmod_handle_spectator_join_response(ggzdmod, status);
+	
+	return 0;
+}
+
+
+static int _io_read_rsp_spectator_leave(GGZdMod * ggzdmod)
+{
+	char status;
+
+	if (ggz_read_char(ggzdmod->fd, &status) < 0)
+		return -1;
+	else
+		_ggzdmod_handle_spectator_leave_response(ggzdmod, status);
+	
+	return 0;
+}
 
 static int _io_read_rsp_seat(GGZdMod *ggzdmod)
 {
@@ -304,13 +383,15 @@ static int _io_read_msg_log(GGZdMod * gg
 
 static int _io_read_req_launch(GGZdMod * ggzdmod)
 {
-	int seats, i;
+	int seats, spectators, i;
 	GGZSeat seat;
 	
 	if (ggz_read_int(ggzdmod->fd, &seats) < 0)
 		return -1;
+	if (ggz_read_int(ggzdmod->fd, &spectators) < 0)
+		return -1;
 
-	_ggzdmod_handle_launch_begin(ggzdmod, seats);
+	_ggzdmod_handle_launch_begin(ggzdmod, seats, spectators);
 
 	for (i = 0; i < seats; i++) {
 		/* Reset seat */
@@ -365,6 +446,34 @@ static int _io_read_req_leave(GGZdMod * 
 		return -1;
 
 	_ggzdmod_handle_leave(ggzdmod, name);
+	ggz_free(name);
+
+	return 0;
+}
+
+static int _io_read_req_spectator_join(GGZdMod * ggzdmod)
+{
+	GGZSpectator spectator;
+	
+	if (ggz_read_int(ggzdmod->fd, &spectator.num) < 0
+	    || ggz_read_string_alloc(ggzdmod->fd, &spectator.name) < 0
+	    || ggz_read_fd(ggzdmod->fd, &spectator.fd) < 0)
+		return -1;
+	else {
+		_ggzdmod_handle_spectator_join(ggzdmod, spectator);
+		ggz_free(spectator.name);
+		return 0;
+	}
+}
+
+static int _io_read_req_spectator_leave(GGZdMod * ggzdmod)
+{
+	char *name;
+
+	if (ggz_read_string_alloc(ggzdmod->fd, &name) < 0)
+		return -1;
+
+	_ggzdmod_handle_spectator_leave(ggzdmod, name);
 	ggz_free(name);
 
 	return 0;
Index: ggzdmod/io.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/io.h,v
retrieving revision 1.4
diff -u -3 -p -r1.4 io.h
--- ggzdmod/io.h	2 Mar 2002 01:06:31 -0000	1.4
+++ ggzdmod/io.h	20 May 2002 17:21:07 -0000
@@ -33,10 +33,12 @@
 #include "mod.h"
 
 /* Functions for sending IO messages */
-int _io_send_launch(int fd, int seats);
+int _io_send_launch(int fd, int seats, int spectators);
 int _io_send_join(int fd, GGZSeat *seat);
 int _io_send_leave(int fd, GGZSeat *seat);
 int _io_send_seat_change(int fd, GGZSeat *seat);
+int _io_send_spectator_join(int fd, GGZSpectator *spectator);
+int _io_send_spectator_leave(int fd, GGZSpectator *spectator);
 int _io_send_state(int fd, GGZdModState state);
 int _io_send_seat(int fd, GGZSeat *seat);
 int _io_send_log(int fd, char *msg);
@@ -48,5 +50,7 @@ int _io_read_data(GGZdMod * ggzdmod);
 int _io_respond_launch(int fd, char status);
 int _io_respond_join(int fd);
 int _io_respond_leave(int fd, int status);
-int _io_respond_seat(int fd, int status);
+int _io_respond_spectator_seat(int fd, int status);
+int _io_respond_spectator_join(int fd);
+int _io_respond_leave(int fd, int status);
 int _io_respond_state(int fd);
Index: ggzdmod/mod.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/mod.h,v
retrieving revision 1.4
diff -u -3 -p -r1.4 mod.h
--- ggzdmod/mod.h	5 May 2002 00:22:08 -0000	1.4
+++ ggzdmod/mod.h	20 May 2002 17:21:07 -0000
@@ -1,5 +1,5 @@
 /* 
- * File: io.h
+ * File: mod.h
  * Author: GGZ Dev Team
  * Project: ggzdmod
  * Date: 11/18/01
@@ -37,7 +37,7 @@
 #include "ggzdmod.h"
 
 /* The number of event handlers there are. */
-#define GGZDMOD_NUM_HANDLERS 7
+#define GGZDMOD_NUM_HANDLERS 9
 
 /* This is the actual structure, but it's only visible internally. */
 struct GGZdMod {
@@ -46,7 +46,9 @@ struct GGZdMod {
 	int fd;			/* file descriptor */
 	int num_seats;
 	int num_open;
+	int num_spectators;
 	GGZList *seats;
+	GGZList *spectators;
 	GGZdModHandler handlers[GGZDMOD_NUM_HANDLERS];
 	void *gamedata;         /* game-specific data */
 
@@ -64,16 +66,20 @@ void _ggzdmod_error(GGZdMod *ggzdmod, ch
 void _ggzdmod_handle_join_response(GGZdMod * ggzdmod, char status);
 void _ggzdmod_handle_leave_response(GGZdMod * ggzdmod, char status);
 void _ggzdmod_handle_seat_response(GGZdMod * ggzdmod, char status);
+void _ggzdmod_handle_spectator_join_response(GGZdMod * ggzdmod, char status);
+void _ggzdmod_handle_spectator_leave_response(GGZdMod * ggzdmod, char status);
 void _ggzdmod_handle_state(GGZdMod * ggzdmod, GGZdModState state);
 void _ggzdmod_handle_log(GGZdMod * ggzdmod, char *msg);
 
 /* Game side functions for handling various messages */
-void _ggzdmod_handle_launch_begin(GGZdMod * ggzdmod, int num_seats);
+void _ggzdmod_handle_launch_begin(GGZdMod * ggzdmod, int num_seats, int num_spectators);
 void _ggzdmod_handle_launch_seat(GGZdMod * ggzdmod, GGZSeat seat);
 void _ggzdmod_handle_launch_end(GGZdMod * ggzdmod);
 void _ggzdmod_handle_join(GGZdMod * ggzdmod, GGZSeat seat);
 void _ggzdmod_handle_leave(GGZdMod * ggzdmod, char *name);
 void _ggzdmod_handle_seat(GGZdMod * ggzdmod, GGZSeat seat);
+void _ggzdmod_handle_spectator_join(GGZdMod * ggzdmod, GGZSpectator spectator);
+void _ggzdmod_handle_spectator_leave(GGZdMod * ggzdmod, char *name);
 void _ggzdmod_handle_state_response(GGZdMod * ggzdmod);
 
 
Index: ggzdmod/protocol.h
===================================================================
RCS file: /cvsroot/ggz/ggzd/ggzdmod/protocol.h,v
retrieving revision 1.7
diff -u -3 -p -r1.7 protocol.h
--- ggzdmod/protocol.h	2 Mar 2002 01:06:32 -0000	1.7
+++ ggzdmod/protocol.h	20 May 2002 17:21:08 -0000
@@ -55,6 +55,9 @@ typedef enum {
 	 */
 	RSP_GAME_LEAVE,
 
+	RSP_GAME_SPECTATOR_JOIN,
+	RSP_GAME_SPECTATOR_LEAVE,
+
 	/** @brief Signals the start of a RSP_GAME_SEAT packet.
 	 *
 	 *  The packet is composed of:
@@ -95,6 +98,7 @@ typedef enum {
 	 *  The packet is composed of:
 	 *    - An integer containing MSG_GAME_LAUNCH.
 	 *    - An integer containing the number of seats at the table.
+	 *    - An integer containing the number of spectators
 	 *    - Seat data for every seat at the table:
 	 *      - An integer containing the seat type (GGZSeatType).
 	 *      - If the seat type is GGZ_SEAT_RESERVED, the name of the
@@ -134,6 +138,9 @@ typedef enum {
 	 *  in response.
 	 */
 	REQ_GAME_LEAVE,
+
+	REQ_GAME_SPECTATOR_JOIN,
+	REQ_GAME_SPECTATOR_LEAVE,
 
 	/** @brief Signals the start of a REQ_GAME_SEAT packet.
 	 *
