diff -Nur -Xdiff_ignore freeciv-1.12.0/Makefile.am freeciv-mod/Makefile.am
--- freeciv-1.12.0/Makefile.am	Sat Jul 14 12:55:26 2001
+++ freeciv-mod/Makefile.am	Sat Apr 13 01:18:23 2002
@@ -18,8 +18,14 @@
 DSUBDIRS =
 endif
 
+if GGZSUPPORT
+GSUBDIRS = ggz
+else
+GSUBDIRS =
+endif
 
-SUBDIRS=	$(DSUBDIRS) intl common $(SSUBDIRS) $(CSUBDIRS) po doc
+
+SUBDIRS=	$(DSUBDIRS) intl common ggz $(SSUBDIRS) $(CSUBDIRS) $(GSUBDIRS) po doc
 
 EXTRA_DIST=	PEOPLE BUGS HOWTOPLAY freeciv_hackers_guide.txt \
 		README.AI README.rulesets README.graphics \
diff -Nur -Xdiff_ignore freeciv-1.12.0/README.GGZ freeciv-mod/README.GGZ
--- freeciv-1.12.0/README.GGZ	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/README.GGZ	Sat Apr 13 14:24:16 2002
@@ -0,0 +1,62 @@
+GGZ:
+----
+
+GGZ is GGZ GAMING ZONE
+http://ggz.sourceforge.net
+
+Patching:
+---------
+If you are reading this, probably you already have your Freeciv patched.
+Anyway, here is the recipe:
+        - Download the patch from GGZ Homepage (http://ggz.sourceforge.net)
+
+        - Appy the patch:
+                $ cd freeciv-1.12.0
+                $ gzip -cd freeciv_with_ggz.patch.gz | patch -p1
+                $ autoheader
+                $ aclocal
+                $ automake --gnu
+                $ autoconf
+
+
+        - Configure and Compile Freeciv in the normal way
+                $ ./configure --enable-ggz=yes
+
+
+        - Install freeciv:
+                $ su
+                # make install
+        
+
+
+
+Running the Game:
+-----------------
+
+The game will run in standard mode (standalone mode) by
+default. And if you want to run in ggz mode, just run the
+ggz client, that it will enable the ggz mode passing the
+--ggz as a command line option.
+
+So to run Freeciv in GGZ mode, run you favourite ggz client:
+        $ ggz-gtk
+
+Log in to any GGZ server, (The available GGZ servers are displayed in 
+the GGZ homepage (bottom-right))
+
+        Launch the Freeciv game,
+        and start the game typing:
+                '/start'  (without the ' )
+        in the chatline of the Freeciv game.
+
+
+Reporting bugs:
+---------------
+DONT mail the FreeCiv developers if you have any bug with this port.
+Instead mail to:
+      riq@corest.com
+or    ggz-dev@lists.sourceforge.net
+
+
+riq.
+
diff -Nur -Xdiff_ignore freeciv-1.12.0/acconfig.h freeciv-mod/acconfig.h
--- freeciv-1.12.0/acconfig.h	Sun Feb 18 13:28:27 2001
+++ freeciv-mod/acconfig.h	Sat Apr 13 04:40:38 2002
@@ -59,6 +59,7 @@
 #undef HAVE_OPENTRANSPORT
 #undef PATH_SEPARATOR
 #undef OPTION_FILE_NAME
+#undef WITH_GGZ
 
 @BOTTOM@
 
diff -Nur -Xdiff_ignore freeciv-1.12.0/client/Makefile.am freeciv-mod/client/Makefile.am
--- freeciv-1.12.0/client/Makefile.am	Sat Jul 14 11:32:25 2001
+++ freeciv-mod/client/Makefile.am	Sat Apr 13 04:44:12 2002
@@ -99,7 +99,7 @@
 
 bin_PROGRAMS = civclient
 
-INCLUDES = -I$(srcdir)/include -I$(top_srcdir)/common -I../intl
+INCLUDES = -I$(srcdir)/include -I$(top_srcdir)/common -I../intl @GGZMOD_INCLUDES@
 
 ## Above, note -I../intl instead of -I$(top_srdir/intl) is deliberate.
 
@@ -126,4 +126,4 @@
 	tilespec.h
 
 civclient_DEPENDENCIES = @gui_sources@/libguiclient.a ../common/libcivcommon.a
-civclient_LDADD        = @gui_sources@/libguiclient.a ../common/libcivcommon.a @INTLLIBS@ @gui_sources@/libguiclient.a ../common/libcivcommon.a @CLIENT_LIBS@
+civclient_LDADD        = @gui_sources@/libguiclient.a ../common/libcivcommon.a @GGZMOD_LDFLAGS@ @LIB_GGZMOD@ @INTLLIBS@ @gui_sources@/libguiclient.a ../common/libcivcommon.a @CLIENT_LIBS@
diff -Nur -Xdiff_ignore freeciv-1.12.0/client/civclient.c freeciv-mod/client/civclient.c
--- freeciv-1.12.0/client/civclient.c	Tue Apr 24 20:39:05 2001
+++ freeciv-mod/client/civclient.c	Sat Apr 13 05:30:23 2002
@@ -59,7 +59,9 @@
 #include "repodlgs_g.h"
 #include "tilespec.h"
 
-#include "civclient.h"
+#ifdef WITH_GGZ
+#include <ggzmod.h>
+#endif
 
 /* this is used in strange places, and is 'extern'd where
    needed (hence, it is not 'extern'd in civclient.h) */
@@ -69,6 +71,7 @@
 char server_host[512];
 char player_name[512];
 int server_port;
+int with_ggz;
 
 enum client_states client_state=CLIENT_BOOT_STATE;
 
@@ -124,6 +127,9 @@
 #else
     fprintf(stderr, _("  -d, --debug NUM\tSet debug log level (0 to 3)\n"));
 #endif
+#ifdef WITH_GGZ
+    fprintf(stderr, _("  -g, --ggz\t\tEnables GGZ mode\n"));
+#endif
     fprintf(stderr, _("  -v, --version\t\tPrint the version number\n"));
    } else if (is_option("--version",argv[i])) {
     fprintf(stderr, "%s\n", freeciv_name_version());
@@ -145,6 +151,11 @@
       }
    } else if ((option = get_option("--tiles",argv,&i,argc)) != NULL) {
       tile_set_name=option;
+
+#ifdef WITH_GGZ
+   } else if (is_option("--ggz",argv[i])) {
+      with_ggz=1;
+#endif
    } else { 
       fprintf(stderr, _("Unrecognized option: \"%s\"\n"), argv[i]);
       exit(1);
@@ -499,8 +510,16 @@
     }
     update_menus();
   }
-  if(client_state==CLIENT_PRE_GAME_STATE)
-    gui_server_connect();
+  if(client_state==CLIENT_PRE_GAME_STATE) {
+
+#ifdef WITH_GGZ
+    if(with_ggz) {
+      char *errbuf[100];
+      connect_to_server("ggz_user", NULL, 0, (char*)errbuf,sizeof(errbuf)-1);
+    } else
+#endif
+      gui_server_connect();
+  }
 }
 
 
diff -Nur -Xdiff_ignore freeciv-1.12.0/client/civclient.h freeciv-mod/client/civclient.h
--- freeciv-1.12.0/client/civclient.h	Tue Apr 24 20:39:05 2001
+++ freeciv-mod/client/civclient.h	Sat Apr 13 00:59:30 2002
@@ -39,5 +39,6 @@
 extern char server_host[512];
 extern char player_name[512];
 extern int server_port;
+extern int with_ggz;
 
 #endif  /* FC__CIVCLIENT_H */
diff -Nur -Xdiff_ignore freeciv-1.12.0/client/clinet.c freeciv-mod/client/clinet.c
--- freeciv-1.12.0/client/clinet.c	Tue Aug  7 10:53:09 2001
+++ freeciv-mod/client/clinet.c	Sat Apr 13 05:21:43 2002
@@ -71,8 +71,13 @@
 #include "plrdlg_g.h"
 #include "repodlgs_g.h"
 
+#ifdef WITH_GGZ
+#include <ggzmod.h>
+#endif
+
 #include "clinet.h"
 
+
 struct connection aconnection;
 
 /**************************************************************************
@@ -139,16 +144,29 @@
   signal (SIGPIPE, SIG_IGN);
 #endif
   
-  if((aconnection.sock = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
-    mystrlcpy(errbuf, mystrerror(errno), n_errbuf);
-    return -1;
-  }
-  
-  if(connect(aconnection.sock, (struct sockaddr *) &src, sizeof (src)) < 0) {
-    mystrlcpy(errbuf, mystrerror(errno), n_errbuf);
-    my_closesocket(aconnection.sock);
-    aconnection.sock = -1;
-    return -1;
+  if(!with_ggz) {
+    if((aconnection.sock = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
+      mystrlcpy(errbuf, mystrerror(errno), n_errbuf);
+      return -1;
+    }
+  
+    if(connect(aconnection.sock, (struct sockaddr *) &src, sizeof (src)) < 0) {
+      mystrlcpy(errbuf, mystrerror(errno), n_errbuf);
+      my_closesocket(aconnection.sock);
+      aconnection.sock = -1;
+      return -1;
+    }
+  } else {
+#ifdef WITH_GGZ
+    /* in ggz mode */
+    aconnection.sock = ggzmod_connect();
+    if( aconnection.sock < 0 ) {
+      fprintf(stderr,_("Only the GGZ client must call civclient in ggz mode!\n"));
+      exit(-1);
+    }
+    /* avoid perdig effect */
+    /* sleep(5); */
+#endif
   }
 
   if (aconnection.buffer) {
diff -Nur -Xdiff_ignore freeciv-1.12.0/configure.in freeciv-mod/configure.in
--- freeciv-1.12.0/configure.in	Fri Aug 10 10:36:42 2001
+++ freeciv-mod/configure.in	Sat Apr 13 05:19:05 2002
@@ -41,6 +41,8 @@
 
 AM_MAINTAINER_MODE
 
+
+
 dnl Evaluate options. Example:
 AC_ARG_ENABLE(debug,
  	[  --enable-debug[=no/minimum/yes] 
@@ -57,6 +59,25 @@
   fi
 fi
 
+dnl
+dnl GGZ stuff
+dnl
+dnl  no=disable ggz support  yes=enable ggz support,  *=error
+AC_ARG_ENABLE(ggz,
+	[  --enable-ggz[=no/yes]   enable ggz support [default=no]],,
+	enable_ggz=no
+)
+
+AM_CONDITIONAL(GGZSUPPORT, test "x$enable_ggz" = "xyes" )
+
+if test "x$enable_ggz" = "xyes"; then
+	AC_DEFINE(WITH_GGZ)
+	AC_GGZ_GGZDMOD
+	AC_GGZ_GGZMOD
+	AC_GGZ_CONFIG
+	AC_GGZ_SERVER
+fi
+
 dnl  no=do not compile server,  yes=compile server,  *=error
 AC_ARG_ENABLE(server,
 [  --disable-server        do not compile the server],
@@ -658,6 +679,9 @@
 	  client/gui-win32/Makefile 
 	  client/gui-stub/Makefile 
 	  server/Makefile 
+	  ggz/Makefile
+	  ggz/freecivclient.dsc
+	  ggz/freeciv.dsc
 	  intl/Makefile
 	  po/Makefile.in
 	  doc/Makefile
diff -Nur -Xdiff_ignore freeciv-1.12.0/ggz/Makefile.am freeciv-mod/ggz/Makefile.am
--- freeciv-1.12.0/ggz/Makefile.am	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/ggz/Makefile.am	Sat Apr 13 00:59:48 2002
@@ -0,0 +1,18 @@
+CLIENT_DSC = freecivclient.dsc
+SERVER_DSC = freeciv.dsc
+SERVER_ROOM = freeciv.room
+
+ggzdgamesdir=$(ggzdconfdir)/games
+ggzdroomsdir=$(ggzdconfdir)/rooms
+
+install-data-local:
+	-$(GGZ_CONFIG) -D --force --install --modfile=$(CLIENT_DSC)
+	-$(INSTALL_DATA) $(SERVER_DSC) $(ggzdgamesdir)
+	-$(INSTALL_DATA) $(SERVER_ROOM) $(ggzdroomsdir)
+
+uninstall:
+	-$(GGZ_CONFIG) --remove --modfile=$(CLIENT_DSC)
+	-rm -f $(ggzdgamesdir)/$(SERVER_DSC)
+	-rm -f $(ggzdroomsdir)/$(SERVER_ROOM)
+
+EXTRA_DIST= $(SERVER_DSC).in $(SERVER_ROOM) $(CLIENT_DSC).in README
diff -Nur -Xdiff_ignore freeciv-1.12.0/ggz/README freeciv-mod/ggz/README
--- freeciv-1.12.0/ggz/README	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/ggz/README	Sat Apr 13 14:22:12 2002
@@ -0,0 +1,4 @@
+Stuff related to GGZ.
+
+For more info read:
+Please read ../README.GGZ
diff -Nur -Xdiff_ignore freeciv-1.12.0/ggz/freeciv.dsc.in freeciv-mod/ggz/freeciv.dsc.in
--- freeciv-1.12.0/ggz/freeciv.dsc.in	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/ggz/freeciv.dsc.in	Sat Apr 13 00:59:48 2002
@@ -0,0 +1,18 @@
+[GameInfo]
+Author = Freeciv devel team
+Description = Freeciv, a clone of Civilization I and II
+Homepage = http://www.freeciv.org
+Name = Freeciv
+Version = @VERSION@
+
+[LaunchInfo]
+ExecutablePath = @prefix@/bin/civserver --ggz
+
+[Protocol]
+Engine = Freeciv
+Version = 1.12.0
+
+[TableOptions]
+AllowLeave = 1
+BotsAllowed = 0 1 2 3 4 5
+PlayersAllowed = 2 3 4 5 6
diff -Nur -Xdiff_ignore freeciv-1.12.0/ggz/freeciv.room freeciv-mod/ggz/freeciv.room
--- freeciv-1.12.0/ggz/freeciv.room	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/ggz/freeciv.room	Sat Apr 13 14:34:12 2002
@@ -0,0 +1,10 @@
+[RoomInfo]
+# This is the short name for the room
+Name = Freeciv
+# This is the long descriptive name for the room
+Description = Freeciv is a multiplayer strategy game, released under the GNU General Public License. It is generally comparable with Civilization II, published by Microprose.
+# The gametype should match up to the Name of an added game
+GameType = Freeciv
+# These set maximum values for this room
+MaxPlayers = 150
+MaxTables = 45
diff -Nur -Xdiff_ignore freeciv-1.12.0/ggz/freecivclient.dsc.in freeciv-mod/ggz/freecivclient.dsc.in
--- freeciv-1.12.0/ggz/freecivclient.dsc.in	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/ggz/freecivclient.dsc.in	Sat Apr 13 00:59:48 2002
@@ -0,0 +1,11 @@
+# Freeciv description file
+[ModuleInfo]
+Game = Freeciv
+Author = Freeciv devel team
+CommandLine = @prefix@/bin/civclient --ggz
+Frontend = gtk
+Homepage = http://www.freeciv.org
+Name = Freeciv
+ProtocolEngine = Freeciv
+ProtocolVersion = 1.12.0
+Version = 1.12.0
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/Makefile.am freeciv-mod/server/Makefile.am
--- freeciv-1.12.0/server/Makefile.am	Fri Jun 15 20:12:59 2001
+++ freeciv-mod/server/Makefile.am	Sat Apr 13 04:44:30 2002
@@ -2,7 +2,8 @@
 
 bin_PROGRAMS = civserver
 noinst_LIBRARIES = libcivserver.a
-INCLUDES = -I$(srcdir)/../common -I$(srcdir)/../ai -I../intl
+
+INCLUDES = -I$(srcdir)/../common -I$(srcdir)/../ai -I../intl @GGZDMOD_INCLUDES@
 
 ## Above, note -I../intl instead of -I$(top_srdir/intl) is deliberate.
 
@@ -66,8 +67,10 @@
 		unithand.c	\
 		unithand.h	\
 		unittools.c	\
-		unittools.h
+		unittools.h	\
+		civggz.c	\
+		civggz.h
 
 
 civserver_DEPENDENCIES = ../common/libcivcommon.a ../ai/libcivai.a ./libcivserver.a
-civserver_LDADD        = ../common/libcivcommon.a ../ai/libcivai.a ./libcivserver.a @INTLLIBS@ ../common/libcivcommon.a ../ai/libcivai.a ./libcivserver.a $(SERVER_LIBS)
+civserver_LDADD        = ../common/libcivcommon.a ../ai/libcivai.a ./libcivserver.a @INTLLIBS@ ../common/libcivcommon.a ../ai/libcivai.a ./libcivserver.a $(SERVER_LIBS) @GGZDMOD_LDFLAGS@ @LIB_GGZDMOD@
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/civggz.c freeciv-mod/server/civggz.c
--- freeciv-1.12.0/server/civggz.c	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/server/civggz.c	Sat Apr 13 14:09:01 2002
@@ -0,0 +1,268 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+/**********************************************************************
+ Are you having problems with the GGZ port ?
+ email: riq@corest.com or ggz-dev@lists.sourceforge.net
+***********************************************************************/
+
+#include <config.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <errno.h>
+
+#include "stdinhand.h"
+#include "sernet.h"
+
+
+#ifdef WITH_GGZ
+
+#include "civggz.h"
+
+#include <ggzdmod.h>
+
+static GGZdMod *g_ggzdmod = NULL;
+
+static void _handle_ggz_state(GGZdMod *ggz, GGZdModEvent event, void *data);
+static void _handle_ggz_join(GGZdMod *ggz, GGZdModEvent event, void *data);
+static void _handle_ggz_leave(GGZdMod *ggz, GGZdModEvent event, void *data);
+#if 0
+static void _handle_ggz_log(GGZdMod *ggz, GGZdModEvent event, void *data);
+static void _handle_ggz_error(GGZdMod *ggz, GGZdModEvent event, void *data);
+#endif
+
+
+/* some ugly globals */
+static int g_new_fd = -1;
+static int g_event_status = 0;
+
+/* argh... GGZ leave event sucks... fix for that */
+#define SEATFD_MAX	(32)
+static int _seatfd_map[ SEATFD_MAX ];
+static int seatfd_init()
+{
+	int i;
+	for(i=0;i<SEATFD_MAX;i++)
+		_seatfd_map[i] = -1;
+
+	return 0;
+}
+
+static int seatfd_add_map( int seatnum, int fd )
+{
+	if( seatnum < 0 || seatnum >= SEATFD_MAX )
+		return -1;
+
+	_seatfd_map[ seatnum ] = fd;
+	return 0;
+}
+
+static int seatfd_del_map( int seatnum )
+{
+	if( seatnum < 0 || seatnum >= SEATFD_MAX )
+		return -1;
+
+	_seatfd_map[ seatnum ] = -1;
+	return 0;
+}
+
+static int seatfd_get_map( int seatnum )
+{
+	if( seatnum < 0 || seatnum >= SEATFD_MAX )
+		return -1;
+
+	return _seatfd_map[ seatnum ];
+}
+
+
+int civggz_launch_bot()
+{
+	static int idx=0;
+	char botname[100];
+
+	sprintf(botname,"create bot_%d",++idx);
+	handle_stdin_input(NULL,botname);
+	return 0;
+}
+
+/* Setup game state and board */
+int civggz_init()
+{
+	seatfd_init();
+
+	g_ggzdmod = ggzdmod_new(GGZDMOD_GAME);
+	if( ! g_ggzdmod )
+		return -1;
+
+	/* Setup GGZ game module */
+	ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_STATE, &_handle_ggz_state);
+	ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_JOIN, &_handle_ggz_join);
+	ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_LEAVE, &_handle_ggz_leave);
+#if 0
+	ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_PLAYER_DATA, &_handle_ggz_player);
+        ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_LOG, &_handle_ggz_log);
+	ggzdmod_set_handler(g_ggzdmod, GGZDMOD_EVENT_ERROR, &_handle_ggz_error);
+#endif
+
+	/* Connect to GGZ server; main loop */
+	if (ggzdmod_connect( g_ggzdmod) < 0)
+		return -1;
+
+	return civggz_giveme_sock();
+}
+
+/* Callback for GGZDMOD_EVENT_STATE */
+static void _handle_ggz_state(GGZdMod *ggz, GGZdModEvent event, void *data)
+{
+	switch(ggzdmod_get_state(ggz)) {
+	case GGZDMOD_STATE_PLAYING:
+		break;
+	case GGZDMOD_STATE_WAITING:
+	{
+		GGZSeat seat;
+		int i;
+		int max = ggzdmod_get_num_seats( g_ggzdmod );
+
+		/* launch robots if necesary */
+		for (i = 0; i < max; i++) {
+			seat = ggzdmod_get_seat( g_ggzdmod, i );
+			if( seat.type == GGZ_SEAT_BOT )
+				civggz_launch_bot();
+		}
+		break;
+	}
+	case GGZDMOD_STATE_DONE:
+		break;
+	default:
+		break;
+	}
+}
+
+static int seats_full(void)
+{
+	return ggzdmod_count_seats(g_ggzdmod, GGZ_SEAT_OPEN)
+		+ ggzdmod_count_seats(g_ggzdmod, GGZ_SEAT_RESERVED) == 0;
+}
+
+/* Callback for GGZDMOD_EVENT_JOIN */
+static void _handle_ggz_join(GGZdMod *ggz, GGZdModEvent event, void *data)
+{
+	GGZSeat seat;
+	int numseat = *(int*)data;
+
+	seat = ggzdmod_get_seat(ggz, numseat);
+
+	seatfd_add_map( numseat, seat.fd );
+
+	/* XXX: We start playing only when there are no open seats. */
+	if (seats_full())
+		ggzdmod_set_state( g_ggzdmod, GGZDMOD_STATE_PLAYING);
+
+	g_new_fd = seat.fd;
+	g_event_status = 1;
+}
+
+/* Callback for GGZDMOD_EVENT_LEAVE */
+static void _handle_ggz_leave(GGZdMod *ggz, GGZdModEvent event, void *data)
+{
+	int fd;
+	int numseat = *(int*)data;
+
+	fd = seatfd_get_map( numseat );
+	if( fd == -1 ) {
+		fprintf(stderr,"Cant find fd from GGZSeat number\n");
+		return;
+	}
+	seatfd_del_map( numseat );
+
+	close_connection_by_fd( fd );
+
+	g_event_status = 2;
+}
+
+int civggz_find_ggzname( int fd, char *n, int len )
+{
+	int i;
+	int max;
+	GGZSeat seat;
+
+	if(!n)
+		return -1;
+
+	max = ggzdmod_get_num_seats( g_ggzdmod );
+
+
+	for (i = 0; i < max; i++) {
+		seat = ggzdmod_get_seat( g_ggzdmod, i );
+		if( seat.fd == fd ) {
+
+			/* dont update robot's names */
+			if( seat.type == GGZ_SEAT_BOT )
+				return -1;
+
+			if( seat.name ) {
+				strncpy(n,seat.name,len);
+				n[len]=0;
+				return 0;
+			} else
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int civggz_exit()
+{
+	ggzdmod_disconnect( g_ggzdmod );
+	ggzdmod_free( g_ggzdmod );
+
+	g_ggzdmod = NULL;
+	return 0;
+}
+
+int civggz_giveme_sock(void)
+{
+	return ggzdmod_get_fd( g_ggzdmod );
+}
+
+int civggz_is_sock_set(int *newfd)
+{
+	int i;
+
+	i = ggzdmod_dispatch( g_ggzdmod );
+
+	if( i < 0 )
+		return i;
+
+	if( g_new_fd != -1 ) {
+		*newfd = g_new_fd;
+		g_new_fd = -1;
+		return 1;
+	}
+
+	return 0;
+}
+
+char *civggz_givme_address( int fd )
+{
+    static char *address = "GGZ Address";
+    return address;
+}
+
+#endif /* WITH_GGZ */
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/civggz.h freeciv-mod/server/civggz.h
--- freeciv-1.12.0/server/civggz.h	Wed Dec 31 21:00:00 1969
+++ freeciv-mod/server/civggz.h	Sat Apr 13 05:38:41 2002
@@ -0,0 +1,30 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+/**********************************************************************
+ Functions needed to support the GGZ mode
+***********************************************************************/
+
+#ifndef __CIVS_CIVGGZ_H
+#define __CIVS_CIVGGZ_H
+
+int civggz_main_loop();
+int civggz_init();
+int civggz_find_ggzname( int fd, char *n, int len );
+int civggz_is_sock_set(int *newfd);
+int civggz_exit();
+int civggz_avoid_perdig_effect(int new_sock);
+int civggz_giveme_sock(void);
+char *civggz_givme_address( int fd );
+
+#endif /* __CIVS_CIVGGZ_H */
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/civserver.c freeciv-mod/server/civserver.c
--- freeciv-1.12.0/server/civserver.c	Sun Feb 25 13:52:11 2001
+++ freeciv-mod/server/civserver.c	Sat Apr 13 00:59:30 2002
@@ -104,7 +104,11 @@
       }
     } else if (is_option("--version", argv[inx]))
       showvers = 1;
-    else {
+    else if( is_option("--ggz",argv[inx])) {
+      srvarg.with_ggz = 1;
+      srvarg.with_console = 0;
+			fprintf(stdout,_("Freeciv is in GGZ mode. The console is disabled\n"));
+    } else {
       fprintf(stderr, _("Error: unknown option '%s'\n"), argv[inx]);
       showhelp = 1;
       break;
@@ -138,6 +142,7 @@
 #else
     fprintf(stderr, _("  -d, --debug NUM\tSet debug log level (0 to 3)\n"));
 #endif
+    fprintf(stderr, _("      --ggz\t\tEnables GGZ mode\n"));
     fprintf(stderr, _("  -v, --version\t\tPrint the version number\n"));
     fprintf(stderr, _("Report bugs to <%s>.\n"), BUG_EMAIL_ADDRESS);
     exit(0);
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/console.c freeciv-mod/server/console.c
--- freeciv-1.12.0/server/console.c	Fri Jul 27 20:57:58 2001
+++ freeciv-mod/server/console.c	Sat Apr 13 00:59:30 2002
@@ -43,6 +43,9 @@
 ************************************************************************/
 static void con_handle_log(int level, char *message)
 {
+  if(!srvarg.with_console)
+	  return;
+
   if(console_rfcstyle) {
     con_write(C_LOG_BASE+level, "%s", message);
   } else {
@@ -129,6 +132,11 @@
 ************************************************************************/
 void con_puts(int i, char *str)
 {
+  if(!srvarg.with_console) {
+    fprintf(stderr,"%s\n",str);
+    return;
+  }
+
   if(console_prompt_is_showing) {
     printf("\n");
   }
@@ -194,6 +202,7 @@
 void con_prompt_init(void)
 {
   static int first = 1;
+
   if (first) {
     con_puts(C_COMMENT, "");
     con_puts(C_COMMENT, _("For introductory help, type 'help'."));
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/sernet.c freeciv-mod/server/sernet.c
--- freeciv-1.12.0/server/sernet.c	Mon Jul 23 16:45:39 2001
+++ freeciv-mod/server/sernet.c	Sat Apr 13 14:18:01 2002
@@ -79,6 +79,10 @@
 #include "srv_main.h"
 #include "stdinhand.h"
 
+#ifdef WITH_GGZ
+#include "civggz.h"
+#endif
+
 #include "sernet.h"
 
 struct connection connections[MAX_NUM_CONNECTIONS];
@@ -139,13 +143,13 @@
 static void handle_readline_input_callback(char *line)
 {
   if (!line) {
-    handle_stdin_close();	/* maybe print an 'are you sure?' message? */
+    handle_stdin_close(); /* maybe print an 'are you sure?' message? */
   }
 
   if (*line)
     add_history(line);
 
-  con_prompt_enter();		/* just got an 'Enter' hit */
+  con_prompt_enter();   /* just got an 'Enter' hit */
   handle_stdin_input((struct connection*)NULL, line);
 
   readline_handled_input = 1;
@@ -207,6 +211,26 @@
   close_connection(pc);
 }
 
+/*****************************************************************************
+ Helper function for GGZ that disconnect a client when it disconnects
+*****************************************************************************/
+#ifdef WITH_GGZ
+void close_connection_by_fd( int fd )
+{
+  int i;
+
+  if( fd < 1 )
+    return;
+
+  for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
+    if(connections[i].used && connections[i].sock == fd ) {
+      close_socket_callback( &connections[i] );
+    }
+  }
+}
+#endif /* WITH_GGZ */
+
+
 /****************************************************************************
   Attempt to flush all information in the send buffers for upto 'netwait'
   seconds.
@@ -235,9 +259,9 @@
     for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
       struct connection *pconn = &connections[i];
       if(pconn->used && pconn->send_buffer->ndata) {
-	FD_SET(pconn->sock, &writefs);
-	FD_SET(pconn->sock, &exceptfs);
-	max_desc=MAX(pconn->sock, max_desc);
+  FD_SET(pconn->sock, &writefs);
+  FD_SET(pconn->sock, &exceptfs);
+  max_desc=MAX(pconn->sock, max_desc);
       }
     }
 
@@ -253,22 +277,22 @@
       struct connection *pconn = &connections[i];
       if(pconn->used) {
         if(FD_ISSET(pconn->sock, &exceptfs)) {
-	  freelog(LOG_NORMAL, "cut connection %s due to exception data",
-		  conn_description(pconn));
-	  close_socket_callback(pconn);
+    freelog(LOG_NORMAL, "cut connection %s due to exception data",
+      conn_description(pconn));
+    close_socket_callback(pconn);
         } else {
-	  if(pconn->send_buffer && pconn->send_buffer->ndata) {
-	    if(FD_ISSET(pconn->sock, &writefs)) {
-	      flush_connection_send_buffer_all(pconn);
-	    } else {
-	      if(game.tcptimeout && pconn->last_write
-		 && (time(NULL)>pconn->last_write + game.tcptimeout)) {
-	        freelog(LOG_NORMAL, "cut connection %s due to lagging player",
-			conn_description(pconn));
-		close_socket_callback(pconn);
-	      }
-	    }
-	  }
+    if(pconn->send_buffer && pconn->send_buffer->ndata) {
+      if(FD_ISSET(pconn->sock, &writefs)) {
+        flush_connection_send_buffer_all(pconn);
+      } else {
+        if(game.tcptimeout && pconn->last_write
+     && (time(NULL)>pconn->last_write + game.tcptimeout)) {
+          freelog(LOG_NORMAL, "cut connection %s due to lagging player",
+      conn_description(pconn));
+    close_socket_callback(pconn);
+        }
+      }
+    }
         }
       }
     }
@@ -304,18 +328,18 @@
   {
     static int readline_initialized = 0;
 
-    if (!readline_initialized) {
+    if (srvarg.with_console && !readline_initialized) {
       char *home_dir = user_home_dir();
       if (home_dir) {
-	history_file =
-	  fc_malloc(strlen(home_dir) + 1 + strlen(HISTORY_FILENAME) + 1);
-	if (history_file) {
-	  strcpy(history_file, home_dir);
-	  strcat(history_file, "/");
-	  strcat(history_file, HISTORY_FILENAME);
-	  using_history();
-	  read_history(history_file);
-	}
+  history_file =
+    fc_malloc(strlen(home_dir) + 1 + strlen(HISTORY_FILENAME) + 1);
+  if (history_file) {
+    strcpy(history_file, home_dir);
+    strcat(history_file, "/");
+    strcat(history_file, HISTORY_FILENAME);
+    using_history();
+    read_history(history_file);
+  }
       }
 
       rl_initialize();
@@ -334,7 +358,7 @@
     game.turn_start = time(NULL);
   
   while(1) {
-    con_prompt_on();		/* accepting new input */
+    con_prompt_on();    /* accepting new input */
     
     if(force_end_of_sniff) {
       force_end_of_sniff=0;
@@ -347,25 +371,25 @@
     if (srvarg.quitidle && server_state != PRE_GAME_STATE) {
       static time_t last_noplayers;
       if(conn_list_size(&game.est_connections) == 0) {
-	if (last_noplayers) {
-	  if (time(NULL)>last_noplayers + srvarg.quitidle) {
-	    sz_strlcpy(srvarg.metaserver_info_line,
-		       "restarting for lack of players");
-	    freelog(LOG_NORMAL, srvarg.metaserver_info_line);
-	    send_server_info_to_metaserver(1,0);
-
-	    quit_game(NULL);
-	  }
-	} else {
-	  last_noplayers = time(NULL);
-	  
-	  my_snprintf(srvarg.metaserver_info_line,
-		      sizeof(srvarg.metaserver_info_line),
-		      "restarting in %d seconds for lack of players",
-		      srvarg.quitidle);
-	  freelog(LOG_NORMAL, srvarg.metaserver_info_line);
-	  send_server_info_to_metaserver(1,0);
-	}
+  if (last_noplayers) {
+    if (time(NULL)>last_noplayers + srvarg.quitidle) {
+      sz_strlcpy(srvarg.metaserver_info_line,
+           "restarting for lack of players");
+      freelog(LOG_NORMAL, srvarg.metaserver_info_line);
+      send_server_info_to_metaserver(1,0);
+
+      quit_game(NULL);
+    }
+  } else {
+    last_noplayers = time(NULL);
+    
+    my_snprintf(srvarg.metaserver_info_line,
+          sizeof(srvarg.metaserver_info_line),
+          "restarting in %d seconds for lack of players",
+          srvarg.quitidle);
+    freelog(LOG_NORMAL, srvarg.metaserver_info_line);
+    send_server_info_to_metaserver(1,0);
+  }
       } else {
         last_noplayers = 0;
       }
@@ -374,18 +398,18 @@
     /* send PACKET_CONN_PING & cut mute players */
     if ((time(NULL)>game.last_ping + game.pingtimeout)) {
       for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
-	struct connection *pconn = &connections[i];
-	if (pconn->used) {
-	  send_packet_generic_empty(pconn, PACKET_CONN_PING);
-
-	  if (pconn->ponged) {
-	    pconn->ponged = 0;
-	  } else {
-	    freelog(LOG_NORMAL, "cut connection %s due to ping timeout",
-		    conn_description(pconn));
-	    close_socket_callback(pconn);
-	  }
-	}
+  struct connection *pconn = &connections[i];
+  if (pconn->used) {
+    send_packet_generic_empty(pconn, PACKET_CONN_PING);
+
+    if (pconn->ponged) {
+      pconn->ponged = 0;
+    } else {
+      freelog(LOG_NORMAL, "cut connection %s due to ping timeout",
+        conn_description(pconn));
+      close_socket_callback(pconn);
+    }
+  }
       }
       game.last_ping = time(NULL);
     }
@@ -402,7 +426,7 @@
 #else
 #   if !defined(__VMS)
       FD_SET(0, &readfs);
-#   endif	
+#   endif 
 #endif
     FD_SET(sock, &readfs);
     FD_SET(sock, &exceptfs);
@@ -410,35 +434,35 @@
 
     for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
       if(connections[i].used) {
-	FD_SET(connections[i].sock, &readfs);
-	if(connections[i].send_buffer->ndata) {
-	  FD_SET(connections[i].sock, &writefs);
-	}
-	FD_SET(connections[i].sock, &exceptfs);
+  FD_SET(connections[i].sock, &readfs);
+  if(connections[i].send_buffer->ndata) {
+    FD_SET(connections[i].sock, &writefs);
+  }
+  FD_SET(connections[i].sock, &exceptfs);
         max_desc=MAX(connections[i].sock, max_desc);
       }
     }
-    con_prompt_off();		/* output doesn't generate a new prompt */
+    con_prompt_off();   /* output doesn't generate a new prompt */
 
     if(select(max_desc+1, &readfs, &writefs, &exceptfs, &tv)==0) { /* timeout */
       send_server_info_to_metaserver(0,0);
       if((game.timeout) 
-	&& (time(NULL)>game.turn_start + game.timeout)
-	&& (server_state == RUN_GAME_STATE)){
-	con_prompt_off();
-	return 0;
+  && (time(NULL)>game.turn_start + game.timeout)
+  && (server_state == RUN_GAME_STATE)){
+  con_prompt_off();
+  return 0;
       }
 #if defined(__VMS)
       {
-	struct { short numchars; char firstchar; char reserved; int reserved2; } ttchar;
-	unsigned long status;
-	status = sys$qiow(EFN$C_ENF,tt_chan,IO$_SENSEMODE|IO$M_TYPEAHDCNT,0,0,0,
-			  &ttchar,sizeof(ttchar),0,0,0,0);
-	if (!$VMS_STATUS_SUCCESS(status)) lib$stop(status);
-	if (ttchar.numchars)
-	  FD_SET(0, &readfs);
-	else
-	  continue;
+  struct { short numchars; char firstchar; char reserved; int reserved2; } ttchar;
+  unsigned long status;
+  status = sys$qiow(EFN$C_ENF,tt_chan,IO$_SENSEMODE|IO$M_TYPEAHDCNT,0,0,0,
+        &ttchar,sizeof(ttchar),0,0,0,0);
+  if (!$VMS_STATUS_SUCCESS(status)) lib$stop(status);
+  if (ttchar.numchars)
+    FD_SET(0, &readfs);
+  else
+    continue;
       }
 #else  /* !__VMS */
 #ifndef SOCKET_ZERO_ISNT_STDIN
@@ -449,35 +473,49 @@
     if (!game.timeout)
       game.turn_start = time(NULL);
 
-    if(FD_ISSET(sock, &exceptfs)) {	     /* handle Ctrl-Z suspend/resume */
+    if(FD_ISSET(sock, &exceptfs)) {      /* handle Ctrl-Z suspend/resume */
       continue;
     }
-    if(FD_ISSET(sock, &readfs)) {	     /* new players connects */
+    if(FD_ISSET(sock, &readfs)) {      /* new players connects */
       freelog(LOG_VERBOSE, "got new connection");
-      if(server_accept_connection(sock)==-1) {
-	freelog(LOG_ERROR, "failed accepting connection");
+      if( srvarg.with_ggz ) {
+        /* in GGZ mode */
+#ifdef WITH_GGZ
+        int new_sock;
+        if( civggz_is_sock_set(&new_sock) == 1 ) {
+          if(server_accept_connection(new_sock)==-1) {
+            freelog(LOG_ERROR, "failed accepting connection");
+          }
+/*          civggz_avoid_perdig_effect(new_sock); */
+        }
+#endif /* WITH_GGZ */
+      } else {
+        if(server_accept_connection(sock)==-1) {
+          freelog(LOG_ERROR, "failed accepting connection");
+        }
       }
     }
     for(i=0; i<MAX_NUM_CONNECTIONS; i++) {   /* check for freaky players */
       struct connection *pconn = &connections[i];
       if(pconn->used && FD_ISSET(pconn->sock, &exceptfs)) {
- 	freelog(LOG_ERROR, "cut connection %s due to exception data",
-		conn_description(pconn));
-	close_socket_callback(pconn);
+  freelog(LOG_ERROR, "cut connection %s due to exception data",
+    conn_description(pconn));
+  close_socket_callback(pconn);
       }
     }
+
 #ifdef SOCKET_ZERO_ISNT_STDIN
-    if ((bufptr = my_read_console())) {
-      con_prompt_enter();	/* will need a new prompt, regardless */
+    if(srvarg.with_console && bufptr = my_read_console()) {
+      con_prompt_enter(); /* will need a new prompt, regardless */
       handle_stdin_input((struct connection *)NULL, bufptr);
     }
 #else  /* !SOCKET_ZERO_ISNT_STDIN */
-    if(FD_ISSET(0, &readfs)) {    /* input from server operator */
+    if(srvarg.with_console && FD_ISSET(0, &readfs)) {    /* input from server operator */
 #ifdef HAVE_LIBREADLINE
       rl_callback_read_char();
       if (readline_handled_input) {
-	readline_handled_input = 0;
-	con_prompt_enter_clear();
+        readline_handled_input = 0;
+        con_prompt_enter_clear();
       }
       continue;
 #else  /* !HAVE_LIBREADLINE */
@@ -485,8 +523,8 @@
       char buf[BUF_SIZE+1];
       
       if((didget=read(0, buf, BUF_SIZE))==-1) {
-	freelog(LOG_FATAL, "read from stdin failed");
-	exit(1);
+        freelog(LOG_FATAL, "read from stdin failed");
+        exit(1);
       }
 
       if(didget==0) {
@@ -494,7 +532,7 @@
       }
 
       *(buf+didget)='\0';
-      con_prompt_enter();	/* will need a new prompt, regardless */
+      con_prompt_enter(); /* will need a new prompt, regardless */
       handle_stdin_input((struct connection *)NULL, buf);
 #endif /* !HAVE_LIBREADLINE */
     }
@@ -503,38 +541,38 @@
      
     {                             /* input from a player */
       for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
-  	struct connection *pconn = &connections[i];
-	if(pconn->used && FD_ISSET(pconn->sock, &readfs)) {
-	  if(read_socket_data(pconn->sock, pconn->buffer)>=0) {
-	    char *packet;
-	    int type, result;
-	    while (1) {
-	      packet = get_packet_from_connection(pconn, &type, &result);
-	      if (result) {
-		handle_packet_input(pconn, packet, type);
-	      } else {
-		break;
-	      }
-	    }
-	  } else {
-	    close_socket_callback(pconn);
-	  }
-	}
+    struct connection *pconn = &connections[i];
+  if(pconn->used && FD_ISSET(pconn->sock, &readfs)) {
+    if(read_socket_data(pconn->sock, pconn->buffer)>=0) {
+      char *packet;
+      int type, result;
+      while (1) {
+        packet = get_packet_from_connection(pconn, &type, &result);
+        if (result) {
+    handle_packet_input(pconn, packet, type);
+        } else {
+    break;
+        }
+      }
+    } else {
+      close_socket_callback(pconn);
+    }
+  }
       }
 
       for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
         struct connection *pconn = &connections[i];
         if(pconn->used && pconn->send_buffer && pconn->send_buffer->ndata) {
-	  if(FD_ISSET(pconn->sock, &writefs)) {
-	    flush_connection_send_buffer_all(pconn);
-	  } else {
-	    if(game.tcptimeout && pconn->last_write
-	       && (time(NULL)>pconn->last_write + game.tcptimeout)) {
-	      freelog(LOG_NORMAL, "cut connection %s due to lagging player",
-		      conn_description(pconn));
-	      close_socket_callback(pconn);
-	    }
-	  }
+    if(FD_ISSET(pconn->sock, &writefs)) {
+      flush_connection_send_buffer_all(pconn);
+    } else {
+      if(game.tcptimeout && pconn->last_write
+         && (time(NULL)>pconn->last_write + game.tcptimeout)) {
+        freelog(LOG_NORMAL, "cut connection %s due to lagging player",
+          conn_description(pconn));
+        close_socket_callback(pconn);
+      }
+    }
         }
       }
     }
@@ -565,9 +603,9 @@
     if (i==(unsigned short)-1) i++;              /* don't use 0 */
     my_snprintf(name, sizeof(name), "c%u", (unsigned int)++i);
     if (!find_player_by_name(name)
-	&& !find_player_by_user(name)
-	&& !find_conn_by_id(i)
-	&& !find_conn_by_name(name)) {
+  && !find_player_by_user(name)
+  && !find_conn_by_id(i)
+  && !find_conn_by_name(name)) {
       *id = i;
       return name;
     }
@@ -596,16 +634,26 @@
 
   fromlen = sizeof(fromend);
 
-  if ((new_sock=accept(sockfd, (struct sockaddr *) &fromend, &fromlen)) == -1) {
-    freelog(LOG_ERROR, "accept failed: %s", mystrerror(errno));
-    return -1;
+  if( !srvarg.with_ggz ) {
+    /* in standard mode */
+    if ((new_sock=accept(sockfd, (struct sockaddr *) &fromend, &fromlen)) == -1) {
+      freelog(LOG_ERROR, "accept failed: %s", mystrerror(errno));
+      return -1;
+    }
+
+    from=gethostbyaddr((char*)&fromend.sin_addr, sizeof(fromend.sin_addr),
+         AF_INET);
+  } else {
+#ifdef WITH_GGZ
+    /* in GGZ mode */
+    from = NULL;
+    fromend.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
+    new_sock = sockfd;
+#endif
   }
 
   my_nonblock(new_sock);
 
-  from=gethostbyaddr((char*)&fromend.sin_addr, sizeof(fromend.sin_addr),
-		     AF_INET);
-
   for(i=0; i<MAX_NUM_CONNECTIONS; i++) {
     struct connection *pconn = &connections[i];
     if (!pconn->used) {
@@ -621,12 +669,15 @@
       pconn->first_packet = 1;
       pconn->byte_swap = 0;
       pconn->capability[0] = '\0';
-      pconn->access_level = access_level_for_next_connection();
+      if( srvarg.with_console )
+        pconn->access_level = access_level_for_next_connection();
+      else
+        pconn->access_level = ALLOW_CTRL;
       pconn->delayed_disconnect = 0;
 
       sz_strlcpy(pconn->name, makeup_connection_name(&pconn->id));
       sz_strlcpy(pconn->addr,
-		 (from ? from->h_name : inet_ntoa(fromend.sin_addr)));
+     (from ? from->h_name : inet_ntoa(fromend.sin_addr)));
 
       conn_list_insert_back(&game.all_connections, pconn);
   
@@ -653,30 +704,40 @@
   signal (SIGPIPE, SIG_IGN);
 #endif
 
-  if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
-    freelog(LOG_FATAL, "socket failed: %s", mystrerror(errno));
-    exit(1);
-  }
-
-  opt=1; 
-  if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, 
-		(char*)&opt, sizeof(opt)) == -1) {
-    freelog(LOG_ERROR, "SO_REUSEADDR failed: %s", mystrerror(errno));
-  }
-
-  memset(&src, 0, sizeof(src));
-  src.sin_family = AF_INET;
-  src.sin_addr.s_addr = htonl(INADDR_ANY);
-  src.sin_port = htons(srvarg.port);
-
-  if(bind(sock, (struct sockaddr *) &src, sizeof (src)) == -1) {
-    freelog(LOG_FATAL, "bind failed: %s", mystrerror(errno));
-    exit(1);
-  }
-
-  if(listen(sock, MAX_NUM_CONNECTIONS) == -1) {
-    freelog(LOG_FATAL, "listen failed: %s", mystrerror(errno));
-    exit(1);
+  if( srvarg.with_ggz ) {
+#ifdef WITH_GGZ
+    /* in GGZ mode */
+    sock = civggz_init();
+    if( sock < 0 )
+  exit(1);
+#endif /* WITH_GGZ */
+  } else {
+    /* standard mode */
+    if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+      freelog(LOG_FATAL, "socket failed: %s", mystrerror(errno));
+      exit(1);
+    }
+
+    opt=1; 
+    if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, 
+    (char*)&opt, sizeof(opt)) == -1) {
+      freelog(LOG_ERROR, "SO_REUSEADDR failed: %s", mystrerror(errno));
+    }
+
+    memset(&src, 0, sizeof(src));
+    src.sin_family = AF_INET;
+    src.sin_addr.s_addr = htonl(INADDR_ANY);
+    src.sin_port = htons(srvarg.port);
+
+    if(bind(sock, (struct sockaddr *) &src, sizeof (src)) == -1) {
+      freelog(LOG_FATAL, "bind failed: %s", mystrerror(errno));
+      exit(1);
+    }
+
+    if(listen(sock, MAX_NUM_CONNECTIONS) == -1) {
+      freelog(LOG_FATAL, "listen failed: %s", mystrerror(errno));
+      exit(1);
+    }
   }
 
   close_socket_set_callback(close_socket_callback);
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/sernet.h freeciv-mod/server/sernet.h
--- freeciv-1.12.0/server/sernet.h	Mon Sep 18 17:36:15 2000
+++ freeciv-mod/server/sernet.h	Sat Apr 13 13:13:32 2002
@@ -26,4 +26,8 @@
 void init_connections(void);
 void close_connection(struct connection *pconn);
 
+#ifdef WITH_GGZ
+void close_connection_by_fd( int fd );
+#endif
+
 #endif  /* FC__SERNET_H */
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/srv_main.c freeciv-mod/server/srv_main.c
--- freeciv-1.12.0/server/srv_main.c	Fri Jul 27 16:51:56 2001
+++ freeciv-mod/server/srv_main.c	Sat Apr 13 14:12:50 2002
@@ -92,9 +92,12 @@
 #include "advmilitary.h"
 #include "aihand.h"
 
+#include "civggz.h"
+
 #include "srv_main.h"
 
 
+
 static void begin_turn(void);
 static void before_end_year(void);
 static int end_turn(void);
@@ -175,9 +178,13 @@
 
   *(srvarg.metaserver_servername) = '\0';
 
+  srvarg.with_ggz = 0;
+  srvarg.with_console = 1;
+
   /* mark as initialized */
   has_been_srv_init = 1;
 
+
   /* done */
   return;
 }
@@ -1190,7 +1197,14 @@
   char msg[MAX_LEN_MSG];
   char orig_name[MAX_LEN_NAME];
   const char *allow;		/* pointer into game.allow_connect */
-  
+
+#ifdef WITH_GGZ
+  if( srvarg.with_ggz ) {
+    civggz_find_ggzname(pconn->sock,req->name,sizeof(req->name)-1);
+    civggz_find_ggzname(pconn->sock,req->short_name,sizeof(req->short_name)-1);
+  }
+#endif
+
   sz_strlcpy(orig_name, req->name);
   remove_leading_trailing_spaces(req->name);
 
@@ -1685,8 +1699,10 @@
      * autosave happens effectively "at the same time" as manual
      * saves, from the point of view of restarting and AI players.
      * Post-increment so we don't count the first loop.
+     *
+     * Dont save the game in GGZ mode
      */
-    if(save_counter >= game.save_nturns && game.save_nturns>0) {
+    if( ! srvarg.with_ggz && save_counter >= game.save_nturns && game.save_nturns>0) {
       save_counter=0;
       save_game_auto();
     }
diff -Nur -Xdiff_ignore freeciv-1.12.0/server/srv_main.h freeciv-mod/server/srv_main.h
--- freeciv-1.12.0/server/srv_main.h	Sun Feb 25 13:52:12 2001
+++ freeciv-mod/server/srv_main.h	Sat Apr 13 00:59:30 2002
@@ -38,6 +38,8 @@
   char metaserver_servername[64];
   /* quit if there no players after a given time interval */
   int quitidle;
+  int with_ggz;
+  int with_console;
 };
 
 void srv_init(void);
