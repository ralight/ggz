#!/usr/bin/env python
#
# Metacle - Aggregation of metaservers
# Copyright (C) 2006 Josef Spillner <josef@ggzgamingzone.org>
# Published under GNU GPL conditions

import xml.dom.minidom
import imp
import glob
import threading

import socket
import time

try:
	import pg
	global_database = True
except:
	global_database = False

global_verbose = True

def status(s):
	if global_verbose:
		print "||", s

class MetaConf:
	def __init__(self, configfile):
		self.metaservers = {}

		try:
			f = file(configfile)
		except:
			print "Error: Could not load configuration file %s." % configfile
			return

		lines = f.readlines()
		f.close()

		for line in lines:
			line = line.strip()

			if not line or line[0] == "#":
				continue

			#print ">>>", line
			entry = line.split("|")
			if len(entry) != 2:
				print "Warning: invalid entry %s." % line
				continue

			(service, url) = entry
			self.metaservers[url] = service

class MetaLoader:
	def __init__(self):
		self.loaders = []

		searchpaths = []
		searchpaths.append("protocols")

		for path in searchpaths:
			protocolfiles = glob.glob(path + "/*.py")

			for protocolfile in protocolfiles:
				protocolfile = protocolfile.split("/")[-1]
				protocolfile = protocolfile[:-3]

				(fileobj, filename, desc) = imp.find_module(protocolfile, [path])
				mod = imp.load_module("protocol", fileobj, filename, desc)
				fileobj.close()

				#print "MOD", mod
				protocol = mod.MetaProtocol()
				#print "->", protocol.services
				self.loaders.append(protocol)
	
	def load(self, service, url):
		for loader in self.loaders:
			if service in loader.services:
				return loader.load(url)
		print "Warning: no handler available for %s." % service
		return None

def ghash(gameserver):
	#s = gameserver["host"]
	#s += str(gameserver["port"])
	s = gameserver["uri"]
	return hash(s)

class MetaBase:
	def __init__(self):
		self.conn = None
		self.metaservers = {}
		self.gameservers = {}

	def connect(self):
		if not global_database:
			return
		status("using database persistence")
		self.conn = pg.DB(host="localhost", dbname="meta", user="meta", passwd="meta")

		q = self.conn.query("SELECT key, url FROM metaservers")
		for row in q.dictresult():
			key = row['key']
			url = row['url']
			self.metaservers[url] = key

		query = "SELECT key, uri, title, version, state, topic, players, available "
		query += "FROM gameservers"
		q = self.conn.query(query)
		for row in q.dictresult():
			row["gamename"] = row["key"]
			del row["key"]
			gameserver = row
			self.gameservers[ghash(gameserver)] = gameserver

		status("database persistence loaded")

	def store(self, gameserver):
		if not self.conn:
			return
		if self.gameservers.has_key(ghash(gameserver)):
			return
		#print "*store*", gameserver

		if not gameserver.has_key("gamename"):
			print "Warning: invalid game server entry found."

		key = gameserver.get("gamename")
		uri = gameserver.get("uri", "")
		version = gameserver.get("version", "")
		state = gameserver.get("state", "")
		topic = gameserver.get("topic", "")
		players = gameserver.get("players", "0")
		available = gameserver.get("available", "-1")

		try:
			players = int(players)
		except:
			players = 0
		try:
			available = int(available)
		except:
			available = -1

		key = key.replace("\'", "\\\'")
		uri = uri.replace("\'", "\\\'")
		version = version.replace("\'", "\\\'")
		state = state.replace("\'", "\\\'")
		topic = topic.replace("\'", "\\\'")

		tuple = (key, uri, version, state, topic, players, available)

		query = "INSERT INTO gameservers "
		query += "(key, uri, version, state, topic, players, available) VALUES "
		query += "('%s', '%s', '%s', '%s', '%s', '%i', '%i')" % tuple
		q = self.conn.query(query)

	def storemeta(self, service, url):
		if not self.conn:
			return
		if self.metaservers.has_key(url):
			return
		service = self.quote(service)
		url = self.quote(url)
		query = "INSERT INTO metaservers (key, url) VALUES ('%s', '%s')" % (service, url)
		q = self.conn.query(query)

	def quote(self, s):
		return s.replace("'", "\\'")

class MetaRunner(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.terminate = 0
		self.lock = threading.Lock()

	def check(self, gamename, timestamp):
		print "--metarunner-- check", gamename, timestamp

	def run(self):
		print "--metarunner--"
		#status("...")
		while not self.terminate:
			pass

class MetaMeta:
	def __init__(self):
		self.config = MetaConf("metacle.conf")
		self.base = MetaBase()
		self.loader = MetaLoader()
		self.runner = MetaRunner()

		self.base.connect()

		allgameservers = {}

		# FIXME: use runner (especially since cache might still be hot)
		status("start query")
		for url, service in self.config.metaservers.iteritems():
			#print ">>> check", url

			gameservers = self.loader.load(service, url)

			self.base.storemeta(service, url)

			if gameservers:
				#print "== list"
				for g in gameservers:
					#print g, "=>", ghash(g)
					allgameservers[ghash(g)] = g

		for h, g in allgameservers.iteritems():
			print "##", h
			self.base.store(g)

		status("done")

	def output(self, gamename):
		s = ""
		s += "<metacle>\n"
		for h, gameserver in self.base.gameservers.iteritems():
			if gamename and gamename != gameserver["gamename"]:
				continue
			s += "<gameserver gamename='" + gameserver["gamename"] + "'>\n"
			s += "<uri>" + gameserver["uri"] + "</uri>\n";
			if gameserver["version"]:
				s += "<version>" + gameserver["version"] + "</version>\n";
			if gameserver["state"]:
				s += "<state>" + gameserver["state"] + "</state>\n";
			if gameserver["topic"]:
				s += "<topic>" + gameserver["topic"] + "</topic>\n";
			if gameserver["players"] != 0:
				s += "<players>" + str(gameserver["players"]) + "</players>\n";
			if gameserver["available"] != -1:
				s += "<available>" + str(gameserver["available"]) + "</available>\n";
			s += "</gameserver>\n"

		# FIXME:
		# finish DOM either if no permanent connections are allowed
		# or on error of some sort
		# otherwise, leave open and publish updates
		# attribute delete="true" for deletion of items (and only uri)

		# FIXME 2:
		# timestamps into gameserver entries?

		s += "</metacle>\n"

		return s

	def cleanup(self):
		self.runner.terminate = 1
		self.runner.join()

	def run(self):
		port = 12012

		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		sock.bind(("", port))
		sock.listen(5)

		self.runner.start()

		while 1:
			client = None
			address = None
			try:
				(client, address) = sock.accept()
			except:
				print "Error: network error."
				return

			# FIXME: use threading

			starttime = time.time()
			client.setblocking(0)

			while 1:
				packet = None
				try:
					packet = client.recv(16384)
				except:
					nowtime = time.time()
					if nowtime > starttime + 10:
						break

				if packet == "":
					break
				if packet is not None:
					packet = packet.strip()

					try:
						dom = xml.dom.minidom.parseString(packet)
					except:
						print "Error: XML malformed."
						client.close()
						break

					root = dom.documentElement

					if root.tagName == "list":
						gamename = root.getAttribute("gamename")
						timestamp = root.getAttribute("timestamp")
						if gamename == "":
							gamename = None
						if timestamp != "":
							try:
								timestamp = int(timestamp)
							except:
								print "Error: bogus timestamp option."
								client.close()
								break

						self.runner.lock.acquire()
						self.runner.check(gamename, timestamp)
						self.runner.lock.release()

						# FIXME: use data from runner
						s = self.output(gamename)

						try:
							client.send(s)
							# FIXME: register for incremental updates
						except:
							print "Warning: client interruption."
					else:
						print "Unknown command '" + root.tagName + "'."
						client.close()
						break

status("starting up")
m = MetaMeta()
m.run()
m.cleanup()

