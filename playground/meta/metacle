#!/usr/bin/env python
#
# Metacle - Aggregation of metaservers
# Copyright (C) 2006 Josef Spillner <josef@ggzgamingzone.org>
# Published under GNU GPL conditions

import xml.dom.minidom
import imp
import glob
import threading

import socket
import select
import time
import sys
import atexit

try:
	import pg
	try:
		import passwd
		global_database = True
	except:
		print "Error: database persistence requested but not configured"
		global_database = False
except:
	print "Warning: no database persistence possible"
	global_database = False

global_verbose = True

def status(s):
	if global_verbose:
		print "||", s

class MetaConf:
	def __init__(self, configfile):
		self.metaservers = {}

		try:
			f = file(configfile)
		except:
			print "Error: Could not load configuration file %s." % configfile
			return

		lines = f.readlines()
		f.close()

		for line in lines:
			line = line.strip()

			if not line or line[0] == "#":
				continue

			#print ">>>", line
			entry = line.split("|")
			if len(entry) != 2:
				print "Warning: invalid entry %s." % line
				continue

			(service, url) = entry
			self.metaservers[url] = service

class MetaLoader:
	def __init__(self):
		self.loaders = []

		searchpaths = []
		searchpaths.append("protocols")

		for path in searchpaths:
			protocolfiles = glob.glob(path + "/*.py")

			for protocolfile in protocolfiles:
				protocolfile = protocolfile.split("/")[-1]
				protocolfile = protocolfile[:-3]

				(fileobj, filename, desc) = imp.find_module(protocolfile, [path])
				mod = imp.load_module("protocol", fileobj, filename, desc)
				fileobj.close()

				#print "MOD", mod
				protocol = mod.MetaProtocol()
				#print "->", protocol.services
				self.loaders.append(protocol)
	
	def load(self, service, url):
		for loader in self.loaders:
			if service in loader.services:
				return loader.load(url)
		print "Warning: no handler available for %s." % service
		return None

def ghash(gameserver):
	#s = gameserver["host"]
	#s += str(gameserver["port"])
	s = gameserver["uri"]
	return hash(s)

class MetaBase:
	def __init__(self):
		self.conn = None
		self.metaservers = {}
		self.gameservers = {}

	def connect(self):
		if not global_database:
			return
		status("using database persistence")
		host = passwd.host
		dbname = passwd.dbname
		user = passwd.user
		password = passwd.passwd
		self.conn = pg.DB(host=host, dbname=dbname, user=user, passwd=password)

		q = self.conn.query("SELECT key, url FROM metaservers")
		for row in q.dictresult():
			key = row['key']
			url = row['url']
			self.metaservers[url] = key

		query = "SELECT key, uri, title, version, state, topic, players, available "
		query += "FROM gameservers"
		q = self.conn.query(query)
		for row in q.dictresult():
			row["gamename"] = row["key"]
			del row["key"]
			gameserver = row
			self.gameservers[ghash(gameserver)] = gameserver

		status("database persistence loaded")

	def store(self, gameserver):
		if not self.conn:
			return
		if self.gameservers.has_key(ghash(gameserver)):
			return
		#print "*store*", gameserver

		if not gameserver.has_key("gamename"):
			print "Warning: invalid game server entry found."

		key = gameserver.get("gamename")
		uri = gameserver.get("uri", "")
		version = gameserver.get("version", "")
		state = gameserver.get("state", "")
		topic = gameserver.get("topic", "")
		players = gameserver.get("players", "0")
		available = gameserver.get("available", "-1")

		try:
			players = int(players)
		except:
			players = 0
		try:
			available = int(available)
		except:
			available = -1

		key = key.replace("\'", "\\\'")
		uri = uri.replace("\'", "\\\'")
		version = version.replace("\'", "\\\'")
		state = state.replace("\'", "\\\'")
		topic = topic.replace("\'", "\\\'")

		tuple = (key, uri, version, state, topic, players, available)

		query = "INSERT INTO gameservers "
		query += "(key, uri, version, state, topic, players, available) VALUES "
		query += "('%s', '%s', '%s', '%s', '%s', '%i', '%i')" % tuple
		q = self.conn.query(query)

	def storemeta(self, service, url):
		if not self.conn:
			return
		if self.metaservers.has_key(url):
			return
		service = self.quote(service)
		url = self.quote(url)
		query = "INSERT INTO metaservers (key, url) VALUES ('%s', '%s')" % (service, url)
		q = self.conn.query(query)

	def quote(self, s):
		return s.replace("'", "\\'")

class MetaRunner(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.terminate = 0
		self.lock = threading.Lock()

	def check(self, gamename, timestamp):
		print "--metarunner-- check", gamename, timestamp

	def run(self):
		print "--metarunner-- startup"
		#status("...")
		while not self.terminate:
			pass

class Connection:
	def __init__(self):
		self.client = None
		self.host = None
		self.subscribed = False
		self.starttime = 0

class MetaMeta:
	def __init__(self):
		self.config = MetaConf("metacle.conf")
		self.base = MetaBase()
		self.loader = MetaLoader()
		self.runner = MetaRunner()

		self.base.connect()

		allgameservers = {}

		# FIXME: use runner (especially since cache might still be hot)
		status("start query")
		for url, service in self.config.metaservers.iteritems():
			#print ">>> check", url

			gameservers = self.loader.load(service, url)

			self.base.storemeta(service, url)

			if gameservers:
				#print "== list"
				for g in gameservers:
					#print g, "=>", ghash(g)
					allgameservers[ghash(g)] = g

		for h, g in allgameservers.iteritems():
			print "##", h
			self.base.store(g)

		status("done")

	def output(self, gamename):
		timestamp = int(time.time())

		s = ""
		s += "<metacle timestamp='" + str(timestamp) + "'>\n"
		for h, gameserver in self.base.gameservers.iteritems():
			if gamename and gamename != gameserver["gamename"]:
				continue
			s += "<gameserver gamename='" + gameserver["gamename"] + "'>\n"
			s += "<uri>" + gameserver["uri"] + "</uri>\n";
			if gameserver["version"]:
				s += "<version>" + gameserver["version"] + "</version>\n";
			if gameserver["state"]:
				s += "<state>" + gameserver["state"] + "</state>\n";
			if gameserver["topic"]:
				s += "<topic>" + gameserver["topic"] + "</topic>\n";
			if gameserver["players"] != 0:
				s += "<players>" + str(gameserver["players"]) + "</players>\n";
			if gameserver["available"] != -1:
				s += "<available>" + str(gameserver["available"]) + "</available>\n";
			s += "</gameserver>\n"

		# FIXME:
		# finish DOM either if no permanent connections are allowed
		# or on error of some sort
		# otherwise, leave open and publish updates
		# attribute delete="true" for deletion of items (and only uri)

		# FIXME 2:
		# timestamps into gameserver entries?

		s += "</metacle>\n"

		return s

	def cleanup(self):
		print "|| cleanup"
		self.runner.terminate = 1
		self.runner.join()
		print "|| done"

	def run(self):
		port = 12012
		connections = {}
		fds = {}

		self.runner.start()

		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		sock.bind(("", port))
		sock.listen(5)
		sock.setblocking(0)

		p = select.poll()
		p.register(sock)
		while 1:
			actives = p.poll()

			for active in actives:
				(fd, event) = active
				if fd == sock.fileno():
					try:
						(client, address) = sock.accept()
					except:
						print "Error: network error."
						return

					(host, port) = address
					print "// connection from", host

					if connections.has_key(host):
						print "Error: multiple connections from same host."
						client.close()
						continue

					connection = Connection()
					connection.starttime = time.time()
					connection.subscribed = False
					connection.client = client
					connection.host = host
					connections[host] = connection

					client.setblocking(0)
					fds[client.fileno()] = connection

					mask = select.POLLIN
					#mask += select.POLLHUP
					#mask += select.POLLNVAL
					#mask += select.POLLERR
					p.register(client, mask)
				else:
					connection = fds[fd]
					print "// data from client", host

					if event == select.POLLIN:
						ret = self.handle(connection)
						if ret == -1:
							print "// force client disconnection", connection.host
							p.unregister(connection.client)
							connection.client.close()
							del fds[fd]
							del connections[connection.host]
					else:
						print "Error: unknown event on client connection."

	def handle(self, connection):
		client = connection.client

		try:
			packet = client.recv(16384)
		except:
			nowtime = time.time()
			if nowtime > connection.starttime + 10:
				if not connection.subscribed:
					print "Warning: timeout exceeded."
					return -1
			return -1

		if packet == "":
			return -1
		if packet is not None:
			packet = packet.strip()

			try:
				dom = xml.dom.minidom.parseString(packet)
			except:
				print "Error: XML malformed."
				return -1

			root = dom.documentElement

			if root.tagName == "list":
				gamename = root.getAttribute("gamename")
				timestamp = root.getAttribute("timestamp")
				if gamename == "":
					gamename = None
				if timestamp != "":
					try:
						timestamp = int(timestamp)
					except:
						print "Error: bogus timestamp option."
						return -1

				self.runner.lock.acquire()
				self.runner.check(gamename, timestamp)
				self.runner.lock.release()

				# FIXME: use data from runner
				s = self.output(gamename)

				try:
					client.send(s)
				except:
					print "Warning: client interruption."
					# FIXME: and now?

				connection.subscribed = True
			else:
				print "Error: unknown command '" + root.tagName + "'."
				return -1

		return 0

status("starting up")
m = MetaMeta()
atexit.register(m.cleanup)
m.run()

