#!/usr/bin/env ruby
#
# Indent the resulting code with:
# indent -bli0 -i4 -nlp

def part_header(f)
	f.puts "/* File autogenerated by ggzcoregen - do not edit! */"
	f.puts ""
	f.puts "/* ============= File header part ============= */"
	f.puts ""

	f.puts "#define _XOPEN_SOURCE 500"
	f.puts "#include <pthread.h>"
	f.puts ""
	f.puts "#define COREGEN_DEBUG 1"
	f.puts "#define COREGEN_TRACE 1"
	f.puts ""
	f.puts "#ifdef COREGEN_DEBUG"
	f.puts "#include <stdio.h>"
	f.puts "#endif"
	f.puts "#ifdef COREGEN_TRACE"
	f.puts "#include <stdio.h>"
	f.puts "#include <string.h>"
	f.puts "#include <stdlib.h>"
	f.puts "#endif"
end

def part_hash(f)
	f.puts ""
	f.puts "/* ============= Hash functions part ============= */"
	f.puts ""

	f.puts "#ifdef COREGEN_TRACE"
	f.puts "struct hash_t"
	f.puts "{"
	f.puts "pthread_t id;"
	f.puts "const char *role;"
	f.puts "};"
	f.puts "typedef struct hash_t Hash;"
	f.puts ""
	f.puts "static Hash **hash = NULL;"
	f.puts ""
	f.puts "static void coregen_hash_put(pthread_t id, const char *role)"
	f.puts "{"
	f.puts "int size = 0;"
	f.puts "Hash *h;"
	f.puts ""
	f.puts "while((hash) && (hash[size]))"
	f.puts "{"
	f.puts "if(hash[size]->id == id) break;"
	f.puts "size++;"
	f.puts "}"
	f.puts ""
	f.puts "if((!hash) || (!hash[size]))"
	f.puts "{"
	f.puts "hash = (Hash**)realloc(hash, (size + 2) * sizeof(Hash*));"
	f.puts "hash[size + 1] = NULL;"
	f.puts "}"
	f.puts ""
	f.puts "h = (Hash*)malloc(sizeof(Hash));"
	f.puts "h->id = id;"
	f.puts "h->role = strdup(role);"
	f.puts "hash[size] = h;"
	f.puts "}"
	f.puts ""
	f.puts "static const char *coregen_hash_get(pthread_t id)"
	f.puts "{"
	f.puts "int size = 0;"
	f.puts ""
	f.puts "while((hash) && (hash[size]))"
	f.puts "{"
	f.puts "if(hash[size]->id == id) return hash[size]->role;"
	f.puts "size++;"
	f.puts "}"
	f.puts ""
	f.puts "return NULL;"
	f.puts "}"
	f.puts "#endif"
end

def part_data(f, c)
	f.puts ""
	f.puts "/* ============= Data definition part ============= */"
	f.puts ""

	c.structures.each do |structure|
		f.puts "struct " + structure.name + "_t"
		f.puts "{"
		f.puts "/* user-defined */"
		structure.children.each do |child|
			f.puts child.type + " " + child.name + ";"
		end
		f.puts "/* internal */"
		structure.children.each do |child|
			f.puts "pthread_t _" + child.name + "_writer;"
		end
		f.puts "pthread_rwlock_t lock;"
		f.puts "};"
		f.puts "typedef struct " + structure.name + "_t " + structure.name + ";"
		f.puts ""
	end

	c.instances.each do |instance|
		f.puts "static " + instance.type + " " + instance.name + ";"
	end
end

def part_accessors(f, c)
	f.puts ""
	f.puts "/* ============= Accessors part ============= */"
	f.puts ""

	c.instances.each do |instance|
		instance.typeobject.children.each do |child|
			iname = instance.name
			cname = child.name
			ctype = child.type

			f.puts ctype + " coregen_get_" + iname + "_" + cname + "(void)"
			f.puts "{"
			f.puts "int num;"
			f.puts ""
			f.puts "#ifdef COREGEN_TRACE"
			f.puts "printf(\"[%lu/%s] read " + iname + "." + cname + "\","
			f.puts "pthread_self(), coregen_hash_get(pthread_self()));"
			f.puts "if(f._bar_writer == pthread_self())"
			f.puts "printf(\" as authority\\n\");"
			f.puts "else printf(\" (authority=%lu/%s)\\n\","
			f.puts iname + "._" + cname + "_writer,"
			f.puts "coregen_hash_get(" + iname + "._" + cname + "_writer));"
			f.puts "#endif"
			f.puts ""
			f.puts "if(" + iname + "._" + cname + "_writer == pthread_self())"
			f.puts "{"
			f.puts "return " + iname + "." + cname + ";"
			f.puts "}"
			f.puts ""
			f.puts "pthread_rwlock_rdlock(&" + iname + ".lock);"
			f.puts "num = " + iname + "." + cname + ";"
			f.puts "pthread_rwlock_unlock(&" + iname + ".lock);"
			f.puts ""
			f.puts "return num;"
			f.puts "}"
			f.puts ""
			f.puts "void coregen_set_"+ iname + "_" + cname + "(" + ctype + " arg)"
			f.puts "{"
			f.puts "#ifdef COREGEN_TRACE"
			f.puts "printf(\"[%lu/%s] write bar\","
			f.puts "pthread_self(), coregen_hash_get(pthread_self()));"
			f.puts "if(" + iname + "._" + cname + "_writer == pthread_self())"
			f.puts "printf(\" as authority\\n\");"
			f.puts "else printf(\" (authority=%lu/%s)\\n\","
			f.puts iname + "._" + cname + "_writer,"
			f.puts "coregen_hash_get(" + iname + "._" + cname + "_writer));"
			f.puts "#endif"
			f.puts ""
			f.puts "#ifdef COREGEN_DEBUG"
			f.puts "/* FIXME: usage of pthread_equal()? */"
			f.puts "if(" + iname + "._" + cname + "_writer != pthread_self())"
			f.puts "{"
			f.puts "printf(\"Thread police: unauthorized write access to '" + iname + "." + cname + "'\\n\");"
			f.puts "#ifdef COREGEN_TRACE"
			f.puts "printf(\"Thread police: %lu/%s violates %lu/%s\\n\","
			f.puts "pthread_self(), coregen_hash_get(pthread_self()),"
			f.puts iname + "._" + cname + "_writer,"
			f.puts "coregen_hash_get(" + iname + "._" + cname + "_writer));"
			f.puts "#endif"
			f.puts "return;"
			f.puts "}"
			f.puts "#endif"
			f.puts ""
			f.puts "pthread_rwlock_wrlock(&" + iname + ".lock);"
			f.puts iname + "." + cname + " = arg;"
			f.puts "pthread_rwlock_unlock(&" + iname + ".lock);"
			f.puts "}"
			f.puts ""
		end
	end
end

def part_init(f, c)
	f.puts ""
	f.puts "/* ============= Initialization part ============= */"
	f.puts ""

	c.roles.each do |role|
		f.puts "void coregen_" + role.name + "_init(void)"
		f.puts "{"
		f.puts "#ifdef COREGEN_TRACE"
		f.puts "coregen_hash_put(pthread_self(), \"" + role.name + "\");"
		f.puts "printf(\"Thread creation [%lu/%s]\\n\","
		f.puts "pthread_self(), coregen_hash_get(pthread_self()));"
		f.puts "#endif"
		f.puts ""
		c.instances.each do |instance|
			instance.typeobject.children.each do |child|
				if child.writer == role.name
					f.puts instance.name + "._" + child.name + "_writer = pthread_self();"
				end
			end
		end
		f.puts "}"
		f.puts ""
	end

	f.puts "void coregen_init(void)"
	f.puts "{"
	c.instances.each do |instance|
		f.puts "pthread_rwlock_init(&" + instance.name + ".lock, NULL);"
	end
	c.instances.each do |instance|
		instance.typeobject.children.each do |child|
			if child.writer != nil
				f.puts instance.name + "._" + child.name + "_writer = -1;"
			end
		end
	end
	f.puts "}"
end

def part_accessors_header(f, c)
	f.puts "#ifndef COREGEN_DATA_H"
	f.puts "#define COREGEN_DATA_H"
	f.puts ""
	f.puts "/* File autogenerated by ggzcoregen - do not edit! */"
	f.puts ""
	f.puts "/* ============= Accessors part ============= */"
	f.puts ""

	c.instances.each do |instance|
		instance.typeobject.children.each do |child|
			iname = instance.name
			cname = child.name
			ctype = child.type

			f.puts ctype + " coregen_get_" + iname + "_" + cname + "(void);"
			f.puts "void coregen_set_"+ iname + "_" + cname + "(" + ctype + " arg);"
			f.puts ""
		end
	end
end

def part_init_header(f, c)
	f.puts ""
	f.puts "/* ============= Initialization part ============= */"
	f.puts ""

	c.roles.each do |role|
		f.puts "void coregen_" + role.name + "_init(void);"
	end
	f.puts ""

	f.puts "void coregen_init(void);"
	f.puts ""
	f.puts "#endif"
end

require 'xmlparser'

class Variable
	attr_writer :type, :writer
	attr_reader :name, :children, :type, :writer

	def initialize(name)
		@name = name
		@children = Array.new
		@writer = nil
		@type = nil
	end

	#def children
	#	return @children
	#end

	def to_s
		n = @name ? @name : "no-name"
		t = @type ? @type : "no-type"
		w = @writer ? @writer : "no-writer"
		return "Variable[" + n + "](" + t + ", " + w + ")"
	end
end

class Instance
	attr_reader :name, :type, :typeobject
	attr_writer :typeobject

	def initialize(name, type)
		@name = name
		@type = type
		@typeobject = nil
	end
end

class Role
	attr_reader :name, :number

	def initialize(name, number)
		@name = name
		@number = number
	end
end

class Core
	attr_reader :instances, :roles, :structures

	def initialize(instances, roles, structures)
		@instances = instances
		@roles = roles
		@structures = structures
	end
end

parser = XMLParser.new
f = File.new("data.xml")

def error(s)
	puts s
	exit -1
end

section = ""
laststruct = nil
instances = Array.new
roles = Array.new
structures = Array.new

while input = f.read
	if input == "" then break end

	parser.parse input do |type, name, data|
		#puts "!", type, name, data
		case type
			when XMLParser::START_ELEM
				case name
					when "roles"
						#puts "!roles"
						section = "roles"
					when "role"
						#puts "!role"
						if section != "roles" then error "Role not in role section" end
						n = nil
						number = nil
						data.each do |key, value|
							case key
								when "name"
									n = value
								when "number"
									number = value
							end
						end
						r = Role.new(n, number)
						roles << r
					when "structure"
						#puts "!structure"
						section = "structure"
						n = nil
						data.each do |key, value|
							case key
								when "name"
									n = value
							end
						end
						laststruct = Variable.new(n)
						structures << laststruct
					when "data"
						#puts "!data"
						if section != "structure" then error "Data not in structure section" end
						n = nil
						w = nil
						t = nil
						data.each do |key, value|
							#puts "key", key, "value", value
							case key
								when "name"
									n = value
								when "writer"
									w = value
								when "type"
									t = value
							end
						end
						v = Variable.new(n)
						v.writer = w
						v.type = t
						laststruct.children << v
					when "instance"
						#puts "!instance"
						section = "instance"
						n = nil
						t = nil
						data.each do |key, value|
							#puts "key", key, "value", value
							case key
								when "name"
									n = value
								when "type"
									t = value
							end
						end
						i = Instance.new(n, t)
						instances << i
				end
			when XMLParser::END_ELEM
		end
	end
end

instances.each do |instance|
	structures.each do |structure|
		if instance.type == structure.name
			instance.typeobject = structure
		end
	end
end

c = Core.new(instances, roles, structures)

f = File.new("data.c", "w")
part_header f
part_hash f
part_data(f, c)
part_accessors(f, c)
part_init(f, c)
f.close

f = File.new("data.h", "w")
part_accessors_header(f, c)
part_init_header(f, c)
f.close

