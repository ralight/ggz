/* Generated by GGZComm/ruby version 0.4 */
/* Protocol 'tictactoe', version '4' */
/* Do NOT edit this file! */

#include "net.h"
#include <stdlib.h>
#include <ggz.h>

#define ggz__seat_open 1

typedef struct ggzcommio_t {
	int fd;
} GGZCommIO;

static notifier_func_type notifier_func = NULL;
static error_func_type error_func = NULL;
static int ret;
static int requirelink = 0;
static int nextlink;
static GGZCommIO *io = NULL;

static void ggzcomm_error(void);

GGZCommIO *ggzcomm_io_allocate(int fd);
void ggzcomm_io_free(GGZCommIO * io);

void ggzcomm_sndmove(void)
{
	ret = ggz_write_int(io->fd, sndmove);
	if(ret < 0)
		ggzcomm_error();
	ret = ggz_write_int(io->fd, variables.move_c);
	if(ret < 0)
		ggzcomm_error();
}

void ggzcomm_reqsync(void)
{
	ret = ggz_write_int(io->fd, reqsync);
	if(ret < 0)
		ggzcomm_error();
}

static void ggzcomm_msgseat(void)
{
	ret = ggz_read_int(io->fd, &variables.num);
	if(ret < 0)
		ggzcomm_error();
	if(notifier_func)
		(notifier_func) (msgseat);
}

static void ggzcomm_msgplayers(void)
{
	int i1;

	for(i1 = 0; i1 < 2; i1++)
	{
		ret = ggz_read_int(io->fd, &variables.seat[i1]);
		if(ret < 0)
			ggzcomm_error();
		if((variables.seat[i1] != ggz__seat_open))
		{
			ret =
			    ggz_read_string_alloc(io->fd,
						  &variables.name[i1]);
			if(ret < 0)
				ggzcomm_error();
		}
	}
	if(notifier_func)
		(notifier_func) (msgplayers);
}

static void ggzcomm_reqmove(void)
{
	if(notifier_func)
		(notifier_func) (reqmove);
}

static void ggzcomm_rspmove(void)
{
	ret = ggz_read_char(io->fd, &variables.status);
	if(ret < 0)
		ggzcomm_error();
	if(notifier_func)
		(notifier_func) (rspmove);
}

static void ggzcomm_msgmove(void)
{
	ret = ggz_read_int(io->fd, &variables.player);
	if(ret < 0)
		ggzcomm_error();
	ret = ggz_read_int(io->fd, &variables.move);
	if(ret < 0)
		ggzcomm_error();
	if(notifier_func)
		(notifier_func) (msgmove);
}

static void ggzcomm_sndsync(void)
{
	int i1;

	ret = ggz_read_char(io->fd, &variables.turn);
	if(ret < 0)
		ggzcomm_error();
	for(i1 = 0; i1 < 9; i1++)
	{
		ret = ggz_read_char(io->fd, &variables.space[i1]);
		if(ret < 0)
			ggzcomm_error();
	}
	if(notifier_func)
		(notifier_func) (sndsync);
}

static void ggzcomm_msggameover(void)
{
	ret = ggz_read_char(io->fd, &variables.winner);
	if(ret < 0)
		ggzcomm_error();
	if(notifier_func)
		(notifier_func) (msggameover);
}

void ggzcomm_network_main(int fd)
{
	int opcode;

	if(!io)
	{
		io = ggzcomm_io_allocate(fd);
	}

	ggz_read_int(io->fd, &opcode);

	if(requirelink)
	{
		if(opcode != nextlink)
			ggzcomm_error();
		requirelink = 0;
	}

	switch (opcode)
	{
		case msgseat:
			ggzcomm_msgseat();
			break;
		case msgplayers:
			ggzcomm_msgplayers();
			break;
		case reqmove:
			ggzcomm_reqmove();
			break;
		case rspmove:
			ggzcomm_rspmove();
			break;
		case msgmove:
			ggzcomm_msgmove();
			break;
		case sndsync:
			ggzcomm_sndsync();
			break;
		case msggameover:
			ggzcomm_msggameover();
			break;
	}
}

void ggzcomm_set_notifier_callback(notifier_func_type f)
{
	notifier_func = f;
}

void ggzcomm_set_error_callback(error_func_type f)
{
	error_func = f;
}

GGZCommIO *ggzcomm_io_allocate(int fd)
{
	GGZCommIO *io = malloc(sizeof(GGZCommIO));
	io->fd = fd;
	return io;
}

void ggzcomm_io_free(GGZCommIO * io)
{
	ggz_free(io);
}

static void ggzcomm_error(void)
{
	if(error_func)
		(error_func) ();
}
