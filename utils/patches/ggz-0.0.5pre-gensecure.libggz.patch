diff -Nur libggz-0.0.5pre/acinclude.tls libggz-0.0.5pre.tls/acinclude.tls
--- libggz-0.0.5pre/acinclude.tls	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/acinclude.tls	Sat Feb 23 03:14:50 2002
@@ -0,0 +1,384 @@
+dnl ======================================
+dnl GGZ Gaming Zone - Configuration Macros
+dnl ======================================
+dnl
+dnl Copyright (C) 2001, 2002 Josef Spillner, dr_maux@users.sourceforge.net
+dnl This file has heavily been inspired by KDE's acinclude :)
+dnl It is published under the conditions of the GNU General Public License.
+dnl
+dnl ======================================
+dnl
+dnl This file contains all autoconf macros needed for any security
+dnl implementation such as TLS/SSL.
+dnl
+dnl ======================================
+dnl
+dnl History:
+dnl 2002-02-10: lookup TLS libraries; taken code from acinclude.ggz
+
+dnl ------------------------------------------------------------------------
+dnl Content of this file:
+dnl ------------------------------------------------------------------------
+dnl AC_GGZ_TLS - find a TLS implementation (support for gnutls, openssl and
+dnl              none)
+dnl AC_PATH_SSL - OpenSSL implementation backend (code from kdelibs)
+dnl AC_GGZ_GNUTLS - GNUTLS implementation backend
+dnl
+
+dnl ------------------------------------------------------------------------
+dnl Find a single file
+dnl ------------------------------------------------------------------------
+dnl
+AC_DEFUN(AC_GGZ_FIND_FILE,
+[
+$3=NO
+for i in $2;
+do
+  for j in $1;
+  do
+    echo "configure: __oline__: $i/$j" >&AC_FD_CC
+    if test -r "$i/$j"; then
+      echo "taking that" >&AC_FD_CC
+      $3=$i
+      break 2
+    fi
+  done
+done
+])
+
+dnl ------------------------------------------------------------------------
+dnl Try to find the SSL headers and libraries.
+dnl $(SSL_LDFLAGS) will be -Lsslliblocation (if needed)
+dnl and $(SSL_INCLUDES) will be -Isslhdrlocation (if needed)
+dnl ------------------------------------------------------------------------
+dnl
+AC_DEFUN(AC_PATH_SSL,
+[
+LIBSSL="-lssl -lcrypto"
+
+ac_ssl_includes=NO ac_ssl_libraries=NO
+ssl_libraries=""
+ssl_includes=""
+AC_ARG_WITH(ssl-dir,
+    [  --with-ssl-dir=DIR      where the root of OpenSSL is installed],
+    [  ac_ssl_includes="$withval"/include
+       ac_ssl_libraries="$withval"/lib
+    ])
+
+want_ssl=yes
+AC_ARG_WITH(ssl,
+    [  --without-ssl           disable SSL checks],
+    [want_ssl=$withval])
+
+if test $want_ssl = yes; then
+
+dnl AC_MSG_CHECKING(for OpenSSL)
+
+AC_CACHE_VAL(ac_cv_have_ssl,
+[#try to guess OpenSSL locations
+  
+  ssl_incdirs="/usr/include /usr/local/include /usr/ssl/include /usr/local/ssl/include $prefix/include $kde_extra_includes"
+  ssl_incdirs="$ac_ssl_includes $ssl_incdirs"
+  AC_GGZ_FIND_FILE(openssl/ssl.h, $ssl_incdirs, ssl_incdir)
+  ac_ssl_includes="$ssl_incdir"
+
+  ssl_libdirs="/usr/lib /usr/local/lib /usr/ssl/lib /usr/local/ssl/lib $prefix/lib $exec_prefix/lib $kde_extra_libs"
+  if test ! "$ac_ssl_libraries" = "NO"; then
+    ssl_libdirs="$ac_ssl_libraries $ssl_libdirs"
+  fi
+
+  test=NONE
+  ssl_libdir=NONE
+  for dir in $ssl_libdirs; do
+    try="ls -1 $dir/libssl*"
+    if test=`eval $try 2> /dev/null`; then ssl_libdir=$dir; break; else echo "tried $dir" >&AC_FD_CC ; fi
+  done
+
+  ac_ssl_libraries="$ssl_libdir"
+
+  AC_LANG_SAVE
+  AC_LANG_C
+
+  ac_cflags_safe="$CFLAGS"
+  ac_ldflags_safe="$LDFLAGS"
+  ac_libs_safe="$LIBS"
+
+  CFLAGS="$CFLAGS -I$ssl_incdir $all_includes"
+  LDFLAGS="-L$ssl_libdir $all_libraries"
+  LIBS="$LIBS $LIBSSL -lRSAglue -lrsaref"
+
+  AC_TRY_LINK(,void RSAPrivateEncrypt(void);RSAPrivateEncrypt();,
+  ac_ssl_rsaref="yes"
+  ,
+  ac_ssl_rsaref="no"
+  )
+
+  CFLAGS="$ac_cflags_safe"
+  LDFLAGS="$ac_ldflags_safe"
+  LIBS="$ac_libs_safe"
+
+  AC_LANG_RESTORE
+
+  if test "$ac_ssl_includes" = NO || test "$ac_ssl_libraries" = NO; then
+    have_ssl=no
+  else
+    have_ssl=yes;
+  fi
+
+  ])
+
+  eval "$ac_cv_have_ssl"
+
+  dnl AC_MSG_RESULT([libraries $ac_ssl_libraries, headers $ac_ssl_includes])
+
+  dnl AC_MSG_CHECKING([whether OpenSSL uses rsaref])
+  dnl AC_MSG_RESULT($ac_ssl_rsaref)
+
+  dnl AC_MSG_CHECKING([for easter eggs])
+  dnl AC_MSG_RESULT([none found])
+
+else
+  have_ssl=no
+fi
+
+if test "$have_ssl" = yes; then
+  dnl AC_MSG_CHECKING(for OpenSSL version)
+  dnl Check for SSL version
+  AC_CACHE_VAL(ac_cv_ssl_version,
+  [
+    AC_LANG_SAVE
+    AC_LANG_C 
+
+    cat >conftest.$ac_ext <<EOF
+#include <openssl/opensslv.h>
+#include <stdio.h>
+    int main() {
+ 
+#ifndef OPENSSL_VERSION_NUMBER
+      printf("ssl_version=\\"error\\"\n");
+#else
+      if (OPENSSL_VERSION_NUMBER < 0x00906000)
+        printf("ssl_version=\\"old\\"\n");
+      else
+        printf("ssl_version=\\"ok\\"\n");
+#endif
+     return (0);
+    }
+EOF
+
+    ac_compile='${CC-gcc} $CFLAGS -I$ac_ssl_includes conftest.$ac_ext -o conftest'
+    if AC_TRY_EVAL(ac_compile); then 
+
+      if eval `./conftest 2>&5`; then
+        if test $ssl_version = error; then
+          dnl AC_MSG_WARN([$ssl_incdir/openssl/opensslv.h doesn't define OPENSSL_VERSION_NUMBER !])
+		  have_ssl=no
+        else
+          if test $ssl_version = old; then
+            dnl AC_MSG_WARN([OpenSSL version too old. Upgrade to 0.9.6 at least, see http://www.openssl.org. SSL support disabled.])
+            have_ssl=no
+          fi
+        fi
+        ac_cv_ssl_version="ssl_version=$ssl_version"
+      else
+        dnl AC_MSG_WARN([Your system couldn't run a small SSL test program.
+        dnl Check config.log, and if you can't figure it out, send a mail to 
+        dnl the GGZ development list <ggz-dev@lists.sourceforge.net>, attaching your config.log])
+		have_ssl=no
+      fi
+
+    else
+      dnl AC_MSG_WARN([Your system couldn't link a small SSL test program.
+      dnl Check config.log, and if you can't figure it out, send a mail to 
+      dnl the GGZ development list <ggz-dev@lists.sourceforge.net>, attaching your config.log])
+	  have_ssl=no
+    fi 
+
+    AC_LANG_RESTORE
+
+  ])
+
+  eval "$ac_cv_ssl_version"
+  dnl AC_MSG_RESULT($ssl_version)
+fi
+
+if test "$have_ssl" != yes; then
+  LIBSSL="";
+else
+  AC_DEFINE(HAVE_SSL, 1, [If we are going to use OpenSSL])
+  ac_cv_have_ssl="have_ssl=yes \
+    ac_ssl_includes=$ac_ssl_includes ac_ssl_libraries=$ac_ssl_libraries ac_ssl_rsaref=$ac_ssl_rsaref"
+  
+  
+  ssl_libraries="$ac_ssl_libraries"
+  ssl_includes="$ac_ssl_includes"
+
+  if test "$ac_ssl_rsaref" = yes; then
+    LIBSSL="-lssl -lcrypto -lRSAglue -lrsaref" 
+  fi
+
+  if test $ssl_version = "old"; then
+    AC_DEFINE(HAVE_OLD_SSL_API, 1, [Define if you have OpenSSL < 0.9.6])
+  fi
+fi
+
+dnl if test "$ssl_includes" = "/usr/include" || test  "$ssl_includes" = "/usr/local/include" || test -z "$ssl_includes"; then
+dnl SSL_INCLUDES="";
+dnl else
+ SSL_INCLUDES="$ssl_includes"
+dnl fi
+
+dnl if test "$ssl_libraries" = "/usr/lib" || test "$ssl_libraries" = "/usr/local/lib" || test -z "$ssl_libraries"; then
+dnl  SSL_LDFLAGS=""
+dnl else
+ SSL_LDFLAGS="$ssl_libraries -R$ssl_libraries"
+dnl fi
+
+AC_SUBST(SSL_INCLUDES)
+AC_SUBST(SSL_LDFLAGS)
+AC_SUBST(LIBSSL)
+])
+
+dnl ------------------------------------------------------------------------
+dnl Try to find the GNUTLS headers and libraries.
+dnl $(GNUTLS_LDFLAGS) will be -L ... (if needed)
+dnl and $(GNUTLS_INCLUDES) will be -I ... (if needed)
+dnl ------------------------------------------------------------------------
+dnl
+AC_DEFUN(AC_GGZ_GNUTLS,
+[
+dnl AC_MSG_CHECKING([for GNUTLS])
+
+ac_gnutls_includes=NO ac_gnutls_libraries=NO
+gnutls_libraries=""
+gnutls_includes=""
+
+AC_ARG_WITH(gnutls-dir,
+    [  --with-gnutls-dir=DIR       gnutls installation prefix ],
+    [  ac_gnutls_includes="$withval"/include
+       ac_gnutls_libraries="$withval"/lib
+    ])
+AC_ARG_WITH(gnutls-includes,
+    [  --with-gnutls-includes=DIR  where the gnutls includes are. ],
+    [  ac_gnutls_includes="$withval"
+    ])
+AC_ARG_WITH(gnutls-libraries,
+    [  --with-gnutls-libraries=DIR where the gnutls libs are. ],
+    [  ac_gnutls_libraries="$withval"
+    ])
+
+AC_CACHE_VAL(ac_cv_have_gnutls,
+[
+if test "x${prefix}" = "xNONE"; then
+   prefix_incdir="${ac_default_prefix}/include"
+   prefix_libdir="${ac_default_prefix}/lib"
+else
+   prefix_incdir="${prefix}/include"
+   prefix_libdir="${prefix}/lib"
+fi
+gnutls_incdirs="$ac_gnutls_includes $prefix_incdir  /usr/local/include /usr/include"
+gnutls_header=gnutls.h
+
+AC_GGZ_FIND_FILE($gnutls_header, $gnutls_incdirs, gnutls_incdir)
+ac_gnutls_includes="$gnutls_incdir"
+
+gnutls_libdirs="$ac_gnutls_libraries $prefix_libdir /usr/local/lib /usr/lib"
+
+test=NONE
+gnutls_libdir=NONE
+for dir in $gnutls_libdirs; do
+  try="ls -1 $dir/libgnutls.*"
+  if test -n "`$try 2> /dev/null`"; then gnutls_libdir=$dir; break; else echo "tried $dir" >&AC_FD_CC ; fi
+done
+
+ac_gnutls_libraries="$gnutls_libdir"
+
+if test "$ac_gnutls_includes" = NO || test "$ac_gnutls_libraries" = NO; then
+  ac_cv_have_gnutls="have_gnutls=no"
+  ac_gnutls_notfound=""
+
+  dnl AC_MSG_ERROR([gnutls not found. Please check your installation! ]);
+else
+  have_gnutls="yes"
+fi
+])
+
+eval "$ac_cv_have_gnutls"
+
+if test "$have_gnutls" != yes; then
+  dnl AC_MSG_RESULT([$have_gnutls]);
+  have_gnutls=no
+else
+  ac_cv_have_gnutls="have_gnutls=yes \
+    ac_gnutls_includes=$ac_gnutls_includes ac_gnutls_libraries=$ac_gnutls_libraries"
+  dnl AC_MSG_RESULT([libraries $ac_gnutls_libraries, headers $ac_gnutls_includes])
+
+  gnutls_libraries="$ac_gnutls_libraries"
+  gnutls_includes="$ac_gnutls_includes"
+fi
+
+AC_SUBST(gnutls_libraries)
+AC_SUBST(gnutls_includes)
+
+GNUTLS_INCLUDES="-I$gnutls_includes"
+GNUTLS_LDFLAGS="-L$gnutls_libraries"
+
+AC_SUBST(GNUTLS_INCLUDES)
+AC_SUBST(GNUTLS_LDFLAGS)
+
+LIB_GGZ='-lggz'
+AC_SUBST(LIB_GGZ)
+
+])
+
+dnl ------------------------------------------------------------------------
+dnl Try to find a suitable TLS implementation.
+dnl $(GGZTLS_LDFLAGS) will be -L ... (if needed)
+dnl and $(GGZTLS_INCLUDES) will be -I ... (if needed)
+dnl $(GGZTLS_SOURCES) is the dynamic list of source files, depending on the
+dnl used implementation
+dnl ------------------------------------------------------------------------
+dnl
+AC_DEFUN(AC_GGZ_TLS,
+[
+AC_MSG_CHECKING([for GGZ TLS implementation])
+
+dnl None (defaults)
+GGZTLS_INCLUDES=""
+GGZTLS_LDFLAGS=""
+LIB_GGZTLS=""
+GGZTLS_SOURCES="none.c"
+
+dnl OpenSSL check
+AC_PATH_SSL
+if test "$have_ssl" != yes; then
+  dnl GNUTLS check
+  AC_GGZ_GNUTLS
+  if test "$have_gnutls" != yes; then
+    AC_MSG_WARN([No TLS implementation found - using 'none'!])
+	AC_DEFINE_UNQUOTED(GGZ_TLS_NONE)
+  else
+    GGZTLS_INCLUDES=$GNUTLS_INCLUDES
+	GGZTLS_LDFLAGS=$GNUTLS_LDFLAGS
+	LIB_GGZTLS="$LIB_GNUTLS -lggz"
+	GGZTLS_SOURCES="gnutls.c"
+    AC_MSG_RESULT([using GNUTLS])
+	AC_DEFINE_UNQUOTED(GGZ_TLS_GNUTLS)
+  fi
+else
+  GGZTLS_INCLUDES=$SSL_INCLUDES
+  GGZTLS_LDFLAGS=$SSL_LDFLAGS
+  LIB_GGZTLS="$LIBSSL -lggz"
+  GGZTLS_SOURCES="openssl.c list.c"
+  AC_MSG_RESULT([using OpenSSL])
+  AC_DEFINE_UNQUOTED(GGZ_TLS_OPENSSL)
+fi
+
+AC_SUBST(GGZTLS_INCLUDES)
+AC_SUBST(GGZTLS_LDFLAGS)
+AC_SUBST(LIB_GGZTLS)
+AC_SUBST(GGZTLS_SOURCES)
+
+])
+
+
diff -Nur libggz-0.0.5pre/configure.in libggz-0.0.5pre.tls/configure.in
--- libggz-0.0.5pre/configure.in	Sat Feb 23 03:18:32 2002
+++ libggz-0.0.5pre.tls/configure.in	Sat Feb 23 03:14:49 2002
@@ -152,9 +152,15 @@
 AC_SUBST(LIBOBJS)
 AC_SUBST(LTLIBOBJS)
 
+dnl TLS implementation
+dnl ==================
+AC_GGZ_TLS
 
+dnl Create makefiles
+dnl ================
 AC_OUTPUT([Makefile 
 	   src/Makefile
+	   tls/Makefile
 	   tests/Makefile])
 
 
@@ -172,4 +178,4 @@
 echo ""
 echo "When complete, type \"make install\""
 echo "to install the library.  You may"
-echo "need to perform this step as root."
\ No newline at end of file
+echo "need to perform this step as root."
diff -Nur libggz-0.0.5pre/tls/.cvsignore libggz-0.0.5pre.tls/tls/.cvsignore
--- libggz-0.0.5pre/tls/.cvsignore	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/.cvsignore	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,11 @@
+Makefile
+Makefile.in
+Makefile.handcrafted
+*.o
+*.lo
+*.la
+.deps
+.libs
+test
+GNATS
+
diff -Nur libggz-0.0.5pre/tls/DESIGN libggz-0.0.5pre.tls/tls/DESIGN
--- libggz-0.0.5pre/tls/DESIGN	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/DESIGN	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,15 @@
+These are the current implementations of libgensecure.
+
+none.c:
+	Dummy wrapper for read/write calls. This implementation does therefore not
+	support encryption, nor authentication.
+
+gnutls.c:
+	GNUTLS support. It provides encryption via DHA, but no authentication
+	either.
+
+openssl.c:
+	OpenSSL doesn't support anon-DH, so a certificate and private key are
+	_essential_. However, both are not really examined, so the statement
+	encryption yes, authentication no applies here as well.
+
diff -Nur libggz-0.0.5pre/tls/GNATS libggz-0.0.5pre.tls/tls/GNATS
--- libggz-0.0.5pre/tls/GNATS	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/GNATS	Sat Feb 23 03:14:49 2002
@@ -0,0 +1,24 @@
+I wanted to created a shared library which consists of a source file which is
+determined dynamically when configuring the package. Let's say the lib is
+libfoo.la, and the source file are bar.c und baz.c.
+Using a dynamic _SOURCE variable doesn't work.
+So I attempted to build a helper library (each uses one of the source files),
+which is then linked to libfoo.la.
+Unfortunately this doesn't work:
+- if the helper library is static, automake complains about non-portability and
+  is right because the helper lib's functions are not included in libfoo.so
+  (tested with nm)
+- if the helper library is a lib_LTLIBRARY, it compiles fine but does not
+  install because there are no .so* and .lai files in .libs for it.
+- if the helper library is a noins_LTLIBRARY,the compilation fails because
+  automake puts in a line which forces noinst_ libs to be compiled after
+  libs_ libs:
+  LTLIBRARIES = $(lib_LTLIBRARIES) $(noinst_LTLIBRARIES)
+	  
+
+It's always possible to repeat that behavior.
+
+It is possible to fix at least one of the two problems described above? If
+nothing else breaks I would recommend to build noinst_ libs before lib_ libs.
+This applies to both 1.4 and 1.5.
+
diff -Nur libggz-0.0.5pre/tls/Makefile.am libggz-0.0.5pre.tls/tls/Makefile.am
--- libggz-0.0.5pre/tls/Makefile.am	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/Makefile.am	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,10 @@
+lib_LTLIBRARIES = libggztls.la
+
+libggztls_la_SOURCES = openssl.c list.c gnutls.c none.c
+libggztls_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+INCLUDES = -I $(top_srcdir) -I $(top_srcdir)/src
+
+noinst_HEADERS = list.h
+include_HEADERS = ggz_tls.h
+
diff -Nur libggz-0.0.5pre/tls/Makefile.am.shared libggz-0.0.5pre.tls/tls/Makefile.am.shared
--- libggz-0.0.5pre/tls/Makefile.am.shared	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/Makefile.am.shared	Sat Feb 23 03:14:49 2002
@@ -0,0 +1,49 @@
+#noinst_LTLIBRARIES = $(GGZTLS_PLUGIN)
+lib_LTLIBRARIES = $(GGZTLS_PLUGIN) libggztls.la
+#lib_LTLIBRARIES = libggztls.la
+EXTRA_LTLIBRARIES = libggztls_openssl.la libggztls_gnutls.la libggztls_none.la
+
+libggztls_openssl_la_SOURCES = openssl.c list.c
+libggztls_openssl_la_INCLUDES = -I $(GGZTLS_INCLUDES)
+libggztls_openssl_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_gnutls_la_SOURCES = gnutls.c
+libggztls_gnutls_la_INCLUDES = -I $(GGZTLS_INCLUDES)
+libggztls_gnutls_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_none_la_SOURCES = none.c
+libggztls_none_la_INCLUDES = -I $(GGZTLS_INCLUDES)
+libggztls_none_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_la_SOURCES =
+#EXTRA_libggztls_la_SOURCES = openssl.c list.c gnutls.c none.c
+#GGZTLS_OBJ +:= (subst .o,.c, $(LIB_GGZTLS))
+#libggztls_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS) $(GGZTLS_OBJ)
+libggztls_la_LIBADD = $(GGZTLS_PLUGIN)
+
+INCLUDES = -I $(top_srcdir)/src
+
+noinst_HEADERS = list.h
+include_HEADERS = ggz_tls.h
+
+#AUTOMAKE_OPTIONS = no-dependencies
+
+###########################################################
+
+#GGZTLS_SOURCES = none.c
+#GGZTLS_INCLUDES =
+#GGZTLS_LDFLAGS =
+#LIB_GGZTLS =
+
+
+#GGZTLS_SOURCES = gnutls.c
+#GGZTLS_INCLUDES = -I/usr/local/include
+#GGZTLS_LDFLAGS = -L/usr/local/lib 
+#LIB_GGZTLS = -lgnutls -lgcrypt -lggz
+
+
+#GGZTLS_SOURCES = openssl.c list.c
+#GGZTLS_INCLUDES = -I/usr/local/ssl/include
+#GGZTLS_LDFLAGS = -L/usr/local/ssl/lib
+#LIB_GGZTLS = -lssl -lcrypt -lggz
+
diff -Nur libggz-0.0.5pre/tls/Makefile.am.static libggz-0.0.5pre.tls/tls/Makefile.am.static
--- libggz-0.0.5pre/tls/Makefile.am.static	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/Makefile.am.static	Sat Feb 23 03:14:49 2002
@@ -0,0 +1,50 @@
+#noinst_LTLIBRARIES = $(GGZTLS_PLUGIN)
+#lib_LTLIBRARIES = $(GGZTLS_PLUGIN) libggztls.la
+noinst_LIBRARIES = @GGZTLS_PLUGIN@
+lib_LTLIBRARIES = libggztls.la
+EXTRA_LIBRARIES = libggztls_openssl.a libggztls_gnutls.a libggztls_none.a
+
+libggztls_openssl_a_SOURCES = openssl.c list.c
+libggztls_openssl_a_INCLUDES = -I $(GGZTLS_INCLUDES)
+#libggztls_openssl_a_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_gnutls_a_SOURCES = gnutls.c
+libggztls_gnutls_a_INCLUDES = -I $(GGZTLS_INCLUDES)
+#libggztls_gnutls_a_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_none_a_SOURCES = none.c
+libggztls_none_a_INCLUDES = -I $(GGZTLS_INCLUDES)
+#libggztls_none_a_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+libggztls_la_SOURCES =
+#EXTRA_libggztls_la_SOURCES = openssl.c list.c gnutls.c none.c
+#GGZTLS_OBJ +:= (subst .o,.c, $(LIB_GGZTLS))
+#libggztls_la_LIBADD = -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS) $(GGZTLS_OBJ)
+libggztls_la_LIBADD = @GGZTLS_PLUGIN@ -L $(GGZTLS_LDFLAGS) $(LIB_GGZTLS)
+
+INCLUDES = -I $(top_srcdir)/src
+
+noinst_HEADERS = list.h
+include_HEADERS = ggz_tls.h
+
+#AUTOMAKE_OPTIONS = no-dependencies
+
+###########################################################
+
+#GGZTLS_SOURCES = none.c
+#GGZTLS_INCLUDES =
+#GGZTLS_LDFLAGS =
+#LIB_GGZTLS =
+
+
+#GGZTLS_SOURCES = gnutls.c
+#GGZTLS_INCLUDES = -I/usr/local/include
+#GGZTLS_LDFLAGS = -L/usr/local/lib 
+#LIB_GGZTLS = -lgnutls -lgcrypt -lggz
+
+
+#GGZTLS_SOURCES = openssl.c list.c
+#GGZTLS_INCLUDES = -I/usr/local/ssl/include
+#GGZTLS_LDFLAGS = -L/usr/local/ssl/lib
+#LIB_GGZTLS = -lssl -lcrypt -lggz
+
diff -Nur libggz-0.0.5pre/tls/Makefile.handcrafted libggz-0.0.5pre.tls/tls/Makefile.handcrafted
--- libggz-0.0.5pre/tls/Makefile.handcrafted	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/Makefile.handcrafted	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,25 @@
+#GGZTLS_SOURCES = none.c
+#GGZTLS_SOURCES = gnutls.c
+GGZTLS_SOURCES = openssl.c list.c
+
+#GGZ_TLS_LIBS = -lgnutls -lgcrypt -lggz
+GGZ_TLS_LIBS = -lssl -lcrypt -lggz
+
+######################
+
+CC = gcc
+CFLAGS = -I ../src
+
+default: all
+
+ggztls_obj := $(subst .c,.o, $(GGZTLS_SOURCES))
+
+all: libggztls.so
+
+libggztls.so: $(ggztls_obj)
+	gcc -shared -o $@ $(ggztls_obj) $(GGZ_TLS_LIBS)
+
+clean:
+	rm -f *.so
+	rm -f *.o
+
diff -Nur libggz-0.0.5pre/tls/ggz_tls.h libggz-0.0.5pre.tls/tls/ggz_tls.h
--- libggz-0.0.5pre/tls/ggz_tls.h	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/ggz_tls.h	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,23 @@
+#ifndef GGZ_TLS_H
+#define GGZ_TLS_H
+
+#include <stddef.h>
+
+typedef enum {
+	GGZ_TLS_CLIENT,
+	GGZ_TLS_SERVER
+} GGZTLSType;
+
+typedef enum {
+	GGZ_TLS_VERIFY_NONE,
+	GGZ_TLS_VERIFY_PEER
+} GGZTLSVerificationType;
+
+int ggz_tls_support_query(void);
+void ggz_tls_enable_fd(int fdes, GGZTLSType whoami, GGZTLSVerificationType verify);
+void ggz_tls_disable_fd(int fdes);
+size_t ggz_tls_write(int fd, void *ptr, size_t n);
+size_t ggz_tls_read(int fd, void *ptr, size_t n);
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/gnutls.c libggz-0.0.5pre.tls/tls/gnutls.c
--- libggz-0.0.5pre/tls/gnutls.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/gnutls.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,183 @@
+/*
+ * File: tls.c
+ * Author: Rich Gade
+ * Project: GGZ Core Client Lib
+ * Date: 10/21/02
+ *
+ * Routines to enable easysock to utilize TLS using gnutls
+ *
+ * Copyright (C) 2002 Brent Hendricks.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#include "config.h"
+#ifdef GGZ_TLS_GNUTLS
+
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <gnutls.h>
+
+#include "ggz_tls.h"
+#include "ggz.h"
+#include "msg.h"
+
+static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
+
+static int state_entries = -1;
+static GNUTLS_STATE **state = NULL;
+static GNUTLS_ANON_SERVER_CREDENTIALS s_cred;
+static GNUTLS_ANON_CLIENT_CREDENTIALS c_cred;
+
+const int protocol_priority[] = {GNUTLS_TLS1, GNUTLS_SSL3, 0};
+const int kx_priority[] = {GNUTLS_KX_ANON_DH, 0};
+const int cipher_priority[] = {GNUTLS_CIPHER_3DES_CBC, GNUTLS_CIPHER_ARCFOUR,0};
+const int comp_priority[] = {GNUTLS_COMP_ZLIB, GNUTLS_COMP_NULL, 0};
+const int mac_priority[] = {GNUTLS_MAC_SHA, GNUTLS_MAC_MD5, 0};
+
+
+int ggz_tls_support_query(void)
+{
+	return 1;
+}
+
+
+void ggz_tls_enable_fd(int fdes, GGZTLSType whoami, GGZTLSVerificationType verify)
+{
+	GNUTLS_STATE *new;
+	int ret;
+
+	/* Check for argument validity */
+	if(verify != GGZ_TLS_VERIFY_NONE)
+		ggz_error_msg_exit("verify_peer is not supported yet\n");
+
+	/* Initialize anon Diffie-Hellman if necessary */
+	pthread_mutex_lock(&mut);
+	if(state_entries == -1) {
+		if(gnutls_global_init() < 0)
+			ggz_error_msg_exit("gnutls_global_init() failure\n");
+		if(whoami == GGZ_TLS_CLIENT) {
+			gnutls_anon_allocate_client_sc(&c_cred);
+		} else {
+			gnutls_anon_allocate_server_sc(&s_cred);
+			gnutls_anon_set_server_cred(s_cred, 1024);/*1024 bits */
+				  /* actually results in a prime of 1035 bits */
+		}
+		state_entries = 0;
+	}
+	pthread_mutex_unlock(&mut);
+
+	new = ggz_malloc(sizeof(GNUTLS_STATE));
+
+	if(whoami == GGZ_TLS_CLIENT)
+		gnutls_init(new, GNUTLS_CLIENT);
+	else
+		gnutls_init(new, GNUTLS_SERVER);
+
+	gnutls_cipher_set_priority(*new, cipher_priority);
+	gnutls_compression_set_priority(*new, comp_priority);
+	gnutls_kx_set_priority(*new, kx_priority);
+	gnutls_protocol_set_priority(*new, protocol_priority);
+	gnutls_mac_set_priority(*new, mac_priority);
+
+	if(whoami == GGZ_TLS_CLIENT)
+		gnutls_cred_set(*new, GNUTLS_ANON, c_cred);
+	else
+		gnutls_cred_set(*new, GNUTLS_ANON, s_cred);
+
+	gnutls_transport_set_ptr(*new, fdes);
+	do {
+		ret = gnutls_handshake(*new);
+	} while(ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN);
+
+	if(ret < 0) {
+		gnutls_deinit(*new);
+		ggz_free(new);
+		ggz_error_msg("TLS handshake failed (%s)\n",
+			      gnutls_strerror(ret));
+		return;
+	}
+
+	/* Expand state table so we can store state for fdes */
+	/* FIXME: This table should probably contract too one day? */
+	/* FIXME: Is there a better way to store this stuff ULTRA fast? */
+	/*        realizing that we have to lookup the state for EVERY  */
+	/*        network read and write that gets performed?           */
+	pthread_mutex_lock(&mut);
+	if(state_entries <= fdes) {
+		state = ggz_realloc(state, (fdes+1)*sizeof(GNUTLS_STATE));
+		state_entries = fdes+1;
+	}
+	pthread_mutex_unlock(&mut);
+
+	state[fdes] = new;
+
+	return;
+}
+
+
+void ggz_tls_disable_fd(int fdes)
+{
+	pthread_mutex_lock(&mut);
+	if(state_entries > fdes)
+		if(state[fdes]) {
+			gnutls_deinit(*state[fdes]);
+			ggz_free(state[fdes]);
+			state[fdes] = NULL;
+		}
+	pthread_mutex_unlock(&mut);
+
+	return;
+}
+
+
+static int check_fd(int fdes)
+{
+	pthread_mutex_lock(&mut);
+	if(state_entries > fdes)
+		if(state[fdes]) {
+			pthread_mutex_unlock(&mut);
+			return 1;
+		}
+	pthread_mutex_unlock(&mut);
+	return 0;
+}
+
+
+size_t ggz_tls_write(int fd, void *ptr, size_t n)
+{
+	if(check_fd(fd))
+		return gnutls_write(*state[fd], ptr, n);
+	else
+		return write(fd, ptr, n);
+}
+
+
+size_t ggz_tls_read(int fd, void *ptr, size_t n)
+{
+	if(check_fd(fd))
+		return gnutls_read(*state[fd], ptr, n);
+	else
+		return read(fd, ptr, n);
+}
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/list.c libggz-0.0.5pre.tls/tls/list.c
--- libggz-0.0.5pre/tls/list.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/list.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,98 @@
+/*************************************************************************
+GenSecure - Transport Layer Security functionality for the GGZ Gaming Zone
+Copyright (C) 2001, 2002 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+**************************************************************************/
+
+#include "config.h"
+#ifdef GGZ_TLS_OPENSSL
+
+#include "list.h"
+
+/* Global variables */
+TLSList *list = NULL;
+TLSList *head = NULL;
+TLSList *el;
+
+/* Add a pair to the list */
+void tls_list_add(int fd, SSL *tls, int active)
+{
+	el = (TLSList*)malloc(sizeof(TLSList));
+	el->fd = fd;
+	el->tls = tls;
+	el->active = active;
+	el->next = NULL;
+	if(head)
+	{
+		head->next = el;
+		el->last = head;
+	}
+	else el->last = NULL;
+	head = el;
+	if(!list) list = el;
+}
+
+/* Remove a pair dynamically from the list */
+void tls_list_remove(int fd)
+{
+	el = list;
+	while(el)
+	{
+		if(el->fd == fd)
+		{
+			if(el->next)
+			{
+				if(el->last)
+				{
+					el->last->next = el->next;
+					el->next->last = el->last;
+				}
+				else
+				{
+					el->next->last = NULL;
+					list = el->next;
+				}
+			}
+			else if(el->last)
+			{
+				el->last->next = NULL;
+				head = el->last;
+			}
+			else
+			{
+				list = NULL;
+				head = NULL;
+			}
+			free(el);
+			return;
+		}
+		else el = el->next;
+	}
+}
+
+/* Try to find a pair, or return NULL */
+SSL *tls_list_get(int fd)
+{
+	el = list;
+	while(el)
+	{
+		if(el->fd == fd) return el->tls;
+		el = el->next;
+	}
+	return NULL;
+}
+
+/* Return whether a connection object is active */
+int tls_list_active(int fd)
+{
+	el = list;
+	while(el)
+	{
+		if(el->fd == fd) return el->active;
+		el = el->next;
+	}
+	return -1;
+}
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/list.h libggz-0.0.5pre.tls/tls/list.h
--- libggz-0.0.5pre/tls/list.h	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/list.h	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,36 @@
+/*************************************************************************
+GenSecure - Transport Layer Security functionality for the GGZ Gaming Zone
+Copyright (C) 2001, 2002 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+**************************************************************************/
+
+#ifndef TLS_LIST_H
+#define TLS_LIST_H
+
+#include "config.h"
+#ifdef GGZ_TLS_OPENSSL
+
+#include <openssl/ssl.h>
+
+/* Structure for mapping on fd's */
+struct tls_list_t
+{
+	SSL *tls;
+	int fd;
+	struct tls_list_t *last;
+	struct tls_list_t *next;
+	int active;
+};
+
+typedef struct tls_list_t TLSList;
+
+/* Functions which handle a list of mappings */
+void tls_list_add(int fd, SSL *tls, int active);
+void tls_list_remove(int fd);
+SSL *tls_list_get(int fd);
+int tls_list_active(int fd);
+
+#endif
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/none.c libggz-0.0.5pre.tls/tls/none.c
--- libggz-0.0.5pre/tls/none.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/none.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,63 @@
+/*
+ * File: tls.c
+ * Author: Rich Gade
+ * Project: GGZ Core Client Lib
+ * Date: 10/21/02
+ *
+ * Routines to enable easysock to utilize TLS using gnutls
+ *
+ * Copyright (C) 2002 Brent Hendricks.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#include "config.h"
+#ifdef GGZ_TLS_NONE
+
+#include "ggz_tls.h"
+#include <unistd.h>
+
+/*****************************
+ * Empty versions of functions
+ * to prevent linkage errors
+ *****************************/
+
+int ggz_tls_support_query(void)
+{
+	return 0;
+}
+
+void ggz_tls_enable_fd(int fdes, GGZTLSType whoami, GGZTLSVerificationType verify)
+{
+	return;
+}
+
+void ggz_tls_disable_fd(int fdes)
+{
+	return;
+}
+
+size_t ggz_tls_write(int fd, void *ptr, size_t n)
+{
+	return write(fd, ptr, n);
+}
+
+size_t ggz_tls_read(int fd, void *ptr, size_t n)
+{
+	return read(fd, ptr, n);
+}
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/openssl.c libggz-0.0.5pre.tls/tls/openssl.c
--- libggz-0.0.5pre/tls/openssl.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/openssl.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,382 @@
+/*************************************************************************
+GenSecure - Transport Layer Security functionality for the GGZ Gaming Zone
+Copyright (C) 2001, 2002 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+**************************************************************************/
+
+#include "config.h"
+#ifdef GGZ_TLS_OPENSSL
+
+/* Include files */
+#include "ggz_tls.h"
+#include "list.h"
+#include <stdio.h>
+#include <string.h>
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <unistd.h>
+
+/* The control structure for TLS */
+static SSL_CTX *_tlsctx = NULL;
+/* Flag to indicate a correct state flow */
+int _state = 0;
+/* The registered callback to decrypt the private key (may be NULL) */
+static pem_password_cb *_callback = NULL;
+/* Location of the certificate */
+static char *_cert = NULL;
+/* Location of the private key */
+static char *_key = NULL;
+
+/* Certificate and private key information */
+#define GENSECURE_CERTIFICATE "/usr/lib/ssl/ggz.pem"
+#define GENSECURE_KEY "/usr/lib/ssl/ggz.pem"
+#define GENSECURE_PASSWORD ""
+
+/* Not everything in OpenSSL is well documented... */
+#define OPENSSLCHECK(x)
+
+/* Output error information */
+#define TLSERROR(x) tls_error(x, __FILE__, __LINE__)
+
+/* Critical error: resets state */
+void tls_error(const char *error, const char *file, int line)
+{
+	printf("*** ERROR! ***\n");
+	printf("(TLS: %s)\n", error);
+	printf("(in %s, line %i)\n", file, line);
+	printf("**************\n");
+	_state = 0;
+}
+
+/* Display extended array information */
+char *tls_exterror(SSL *_tls, int ret)
+{
+	switch(SSL_get_error(_tls, ret))
+	{
+		case SSL_ERROR_NONE:
+			return "SSL_ERROR_NONE";
+			break;
+		case SSL_ERROR_ZERO_RETURN:
+			return "SSL_ERROR_ZERO_RETURN";
+			break;
+		case SSL_ERROR_WANT_READ:
+			return "SSL_ERROR_WANT_READ";
+			break;
+		case SSL_ERROR_WANT_WRITE:
+			return "SSL_ERROR_WANT_WRITE";
+			break;
+		case SSL_ERROR_WANT_X509_LOOKUP:
+			return "SSL_ERROR_WANT_X509_LOOKUP";
+			break;
+		case SSL_ERROR_SYSCALL:
+			return "SSL_ERROR_SYSCALL";
+			break;
+		case SSL_ERROR_SSL:
+			return "SSL_ERROR_SSL";
+			break;
+	}
+	return NULL;
+}
+
+/* Setup certificate arguments */
+void tls_prepare(const char *cert, const char *key, pem_password_cb *callback)
+{
+	_callback = callback;
+	_cert = (char*)cert;
+	_key = (char*)key;
+}
+
+/* Verification callback */
+int tls_verify(int preverify_ok, X509_STORE_CTX *ctx)
+{
+	printf("### VERIFY CALLBACK: %i ###\n", preverify_ok);
+	preverify_ok = 1;
+	return preverify_ok;
+}
+
+/* Simple password callback */
+static int passwordcallback(char *buf, int size, int rwflag, void *userdata)
+{
+	strncpy(buf, GENSECURE_PASSWORD, size);
+	return strlen(GENSECURE_PASSWORD);
+}
+
+/* Initialize the library */
+void tls_init(int verify)
+{
+	if(_tlsctx)
+	{
+		TLSERROR("Library is already initialized!");
+		return;
+	}
+
+	SSL_load_error_strings();
+	SSL_library_init();
+
+	tls_prepare(GENSECURE_CERTIFICATE, GENSECURE_KEY, passwordcallback);
+
+	_tlsctx = SSL_CTX_new(TLSv1_method());
+	if(!_tlsctx) TLSERROR("Couldn't create TLS object.\n");
+	else
+	{
+		OPENSSLCHECK(SSL_CTX_set_quiet_shutdown(_tlsctx, 1));
+		OPENSSLCHECK(SSL_CTX_set_info_callback(_tlsctx, NULL));
+		OPENSSLCHECK(SSL_CTX_load_verify_locations(ctx, CAfile, CApath));
+		OPENSSLCHECK(SSL_CTX_set_default_verify_paths());
+		if(verify == GGZ_TLS_VERIFY_PEER) SSL_CTX_set_verify(_tlsctx, SSL_VERIFY_PEER, tls_verify);
+		else SSL_CTX_set_verify(_tlsctx, SSL_VERIFY_NONE, NULL);
+	}
+}
+
+/* Load certificate and private key */
+void tls_certkey(SSL *_tls)
+{
+	int ret, ret2;
+
+	if(!_tls)
+	{
+		TLSERROR("Certificate cannot be loaded.");
+		return;
+	}
+
+	if((!_key) || (!_cert) || (!_callback))
+	{
+		printf("WARNING: certificates are disabled!\n");
+		return;
+	}
+
+	SSL_CTX_set_default_passwd_cb(_tlsctx, _callback);
+
+	/*ret = SSL_CTX_load_verify_locations(_tlsctx, "/usr/lib/ssl/cacert.pem", NULL);
+	if(ret != 1)
+	{
+		TLSERROR("Couldn't load root CA file!");
+		ret2 = ERR_get_error();
+		printf("EXT: %s\n%s\n%s\n%s\n%s\n", tls_exterror(_tls, ret), ERR_error_string(ret2, NULL),
+		ERR_lib_error_string(ret2), ERR_func_error_string(ret2), ERR_reason_error_string(ret2));
+	}*/
+
+	ret = SSL_use_RSAPrivateKey_file(_tls, _key, SSL_FILETYPE_PEM);
+	if(ret != 1)
+	{
+		TLSERROR("Error loading TLS PEM private key.");
+		ret2 = ERR_get_error();
+		printf("EXT: %s\n%s\n%s\n%s\n%s\n", tls_exterror(_tls, ret), ERR_error_string(ret2, NULL),
+		ERR_lib_error_string(ret2), ERR_func_error_string(ret2), ERR_reason_error_string(ret2));
+	}
+	ret = SSL_use_certificate_file(_tls, _cert, SSL_FILETYPE_PEM);
+	if(ret != 1) TLSERROR("Error loading TLS PEM certificate.");
+	ret = SSL_check_private_key(_tls);
+	if(!ret) TLSERROR("Private key doesn't match certificate public key.");
+	printf("*** certificate loaded ***\n");
+}
+
+/* Switch on a filedescriptor */
+void ggz_tls_enable_fd(int fd, GGZTLSType mode, GGZTLSVerificationType verify)
+{
+	int ret, ret2;
+	STACK_OF(SSL_CIPHER) *stack;
+	SSL_CIPHER *cipher;
+	int bits;
+	char *cipherlist;
+	SSL *_tls;
+	int _tls_active;
+
+	_state = 1;
+	_tls_active = 0;
+	if((mode != GGZ_TLS_CLIENT) && (mode != GGZ_TLS_SERVER))
+	{
+		TLSERROR("Wrong mode.");
+		return;
+	}
+
+	if(!_tlsctx) tls_init(verify);
+		
+	_tls = SSL_new(_tlsctx);
+	if(_tls)
+	{
+		cipherlist = NULL;
+		stack = SSL_get_ciphers(_tls);
+		while((cipher = (SSL_CIPHER*)sk_pop(stack)) != NULL)
+		{
+			printf("* Cipher: %s\n", SSL_CIPHER_get_name(cipher));
+			printf("  Bits: %i\n", SSL_CIPHER_get_bits(cipher, &bits));
+			printf("  Used bits: %i\n", bits);
+			printf("  Version: %s\n", SSL_CIPHER_get_version(cipher));
+			printf("  Description: %s\n", SSL_CIPHER_description(cipher, NULL, 0));
+			if(cipherlist)
+			{
+				cipherlist = (char*)realloc(cipherlist, (strlen(cipherlist) + 1) + strlen(SSL_CIPHER_get_name(cipher)) + 1);
+				strcat(cipherlist, ":");
+				strcat(cipherlist, SSL_CIPHER_get_name(cipher));
+			}
+			else
+			{
+				cipherlist = (char*)malloc(strlen(SSL_CIPHER_get_name(cipher)) + 1);
+				strcpy(cipherlist, SSL_CIPHER_get_name(cipher));
+			}
+		}
+		printf("Available ciphers: %s\n", cipherlist);
+		ret = SSL_set_cipher_list(_tls, cipherlist);
+		if(!ret) TLSERROR("Cipher selection failed.");
+		ret = SSL_set_fd(_tls, fd);
+		if(!ret) TLSERROR("Assignment to connection failed.");
+		else
+		{
+			SSL_set_read_ahead(_tls, 1);
+			if(mode == GGZ_TLS_SERVER)
+			{
+				tls_certkey(_tls);
+				if(_state)
+				{
+					SSL_set_accept_state(_tls);
+					ret = SSL_accept(_tls);
+				}
+			}
+			else
+			{
+				SSL_set_connect_state(_tls);
+				ret = SSL_connect(_tls);
+			}
+			if((ret != 1) || (!_state))
+			{
+				printf("Ret: %i, State: %i\n", ret, _state);
+				TLSERROR("Handshake failed.");
+				ret2 = ERR_get_error();
+				printf("EXT: %s\n%s\n%s\n%s\n%s\n", tls_exterror(_tls, ret), ERR_error_string(ret2, NULL),
+					ERR_lib_error_string(ret2), ERR_func_error_string(ret2), ERR_reason_error_string(ret2));
+			}
+			else
+			{
+				printf(">>>>> Handshake successful.\n");
+				if((mode == GGZ_TLS_SERVER) || (verify == GGZ_TLS_VERIFY_NONE)) _tls_active = 1;
+				else
+				{
+					printf(">>>>> Client side, thus checking Certificate.\n");
+					printf("Negotiated cipher: %s\n", SSL_get_cipher(_tls));
+					printf("Shared ciphers: %s\n", SSL_get_shared_ciphers(_tls, NULL, 0));
+					if(SSL_get_peer_certificate(_tls))
+					{
+						if(SSL_get_verify_result(_tls) == X509_V_OK)
+						{
+							_tls_active = 1;
+						}
+						else
+						{
+							printf("Error code: %li\n", SSL_get_verify_result(_tls));
+							TLSERROR("Invalid certificate, or certificate is not self-signed.");
+						}
+					}
+					else TLSERROR("Couldn't get certificate.");
+				}
+			}
+			tls_list_add(fd, _tls, _tls_active);
+		}
+	}
+}
+
+/* Read from a file descriptor */
+size_t ggz_tls_read(int fd, void *buffer, size_t size)
+{
+	SSL *handler;
+	int ret;
+
+	handler = tls_list_get(fd);
+	if(!handler)
+	{
+		/*TLSERROR("Given fd is not secure.");*/
+		return read(fd, buffer, size);
+	}
+	ret = SSL_read(handler, buffer, size);
+	if(ret <= 0)
+	{
+		switch(SSL_get_error(handler, ret))
+		{
+			case SSL_ERROR_WANT_READ:
+			case SSL_ERROR_WANT_WRITE:
+				break;
+			case SSL_ERROR_SYSCALL:
+				ret = ERR_get_error();
+				if(!ret)
+				{
+					printf("Protocol violation: EOF\n");
+				}
+				else
+				{
+					printf("Unix IO error: %i\n", errno);
+				}
+				break;
+			default:
+				/*printf("SSL read error (%i) on fd %i!\n", ret, fd);
+				printf("SSL: %s\n", tls_exterror(handler, ret));*/
+		}
+	}
+	return ret;
+}
+
+/* Write to a file descriptor */
+size_t ggz_tls_write(int fd, void *s, size_t size)
+{
+	SSL *handler;
+	int ret;
+
+	handler = tls_list_get(fd);
+	if(!handler)
+	{
+		/*TLSERROR("Given fd is not secure.");*/
+		return write(fd, s, size);
+	}
+	ret = SSL_write(handler, s, size);
+	if(ret <= 0)
+	{
+		switch(SSL_get_error(handler, ret))
+		{
+			case SSL_ERROR_WANT_READ:
+			case SSL_ERROR_WANT_WRITE:
+				break;
+			case SSL_ERROR_SYSCALL:
+				ret = ERR_get_error();
+				if(!ret)
+				{
+					printf("Protocol violation: EOF\n");
+				}
+				else
+				{
+					printf("Unix IO error: %i\n", errno);
+				}
+				break;
+			default:
+				/*printf("SSL write error (%i) on fd %i!\n", ret, fd);
+				printf("SSL: %s\n", tls_exterror(handler, ret));*/
+		}
+	}
+	return ret;
+}
+
+/*int tls_active(int fd)
+{
+	return (tls_list_active(fd) > 0);
+}*/
+
+/* If an fd is active, deactivate it */
+void ggz_tls_disable_fd(int fd)
+{
+	SSL *handler;
+
+	handler = tls_list_get(fd);
+	if(handler)
+	{
+		SSL_shutdown(handler);
+		SSL_free(handler);
+		tls_list_remove(fd);
+	}
+}
+
+/* Returns a value which indicates that this implementation supports TLS */
+int ggz_tls_support_query()
+{
+	return 1;
+}
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/test/Makefile libggz-0.0.5pre.tls/tls/test/Makefile
--- libggz-0.0.5pre/tls/test/Makefile	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/Makefile	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,17 @@
+CFLAGS = -I ..
+
+all: test server client
+
+test: test.o
+	gcc -o test test.o -L ../.libs -lggztls
+
+server: server.o gensocket.o
+	gcc -o server server.o gensocket.o -L ../.libs -lggztls
+
+client: client.o
+	gcc -o client client.o gensocket.o -L ../.libs -lggztls
+
+clean:
+	rm -f *.o
+	rm -f server client test
+
diff -Nur libggz-0.0.5pre/tls/test/client.c libggz-0.0.5pre.tls/tls/test/client.c
--- libggz-0.0.5pre/tls/test/client.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/client.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "gensocket.h"
+#include "ggz_tls.h"
+#include "configuration.h"
+
+int main(int argc, char *argv[])
+{
+	char tmpbuf[4096];
+	int bytes;
+
+	printf("> Starting generic client...\n");
+
+	socket_connect(GENSECURE_HOST, GENSECURE_PORT);
+	printf("Generic client: connected\n");
+
+	ggz_tls_enable_fd(socket_fd(), GGZ_TLS_CLIENT, GGZ_TLS_VERIFY_NONE);
+	printf("> Client in working state.\n");
+
+	fcntl(0, F_SETFL, O_NONBLOCK);
+	fcntl(socket_fd(), F_SETFL, O_NONBLOCK);
+
+	for(;;)
+	{
+		bytes = ggz_tls_read(socket_fd(), tmpbuf, sizeof(tmpbuf));
+		if(bytes > 0)
+		{
+			if(!strcmp(tmpbuf, "Bye."))
+			{
+				ggz_tls_write(socket_fd(), "Quitting.", strlen("Quitting"));
+				break;
+			}
+			printf("Received: %s\n", tmpbuf);
+		}
+		
+		bytes = read(0, tmpbuf, sizeof(tmpbuf));
+		if(bytes > 0)
+		{
+			tmpbuf[bytes - 1] = 0;
+			ggz_tls_write(socket_fd(), tmpbuf, strlen(tmpbuf));
+		}
+	}
+
+	printf("> Client quit.\n");
+
+	return 0;
+}
+
diff -Nur libggz-0.0.5pre/tls/test/configuration.h libggz-0.0.5pre.tls/tls/test/configuration.h
--- libggz-0.0.5pre/tls/test/configuration.h	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/configuration.h	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,30 @@
+/**************************************************************************
+GenSecure - a generic client/server example of TLS support for a connection
+(C) 2001 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+***************************************************************************/
+
+/* configuration: Default configuration for the gensecure example. */
+
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+/* Client connects to this host */
+#define GENSECURE_HOST "localhost"
+
+/* Port to be used be client and server */
+#define GENSECURE_PORT 9998
+
+/* Location of the server PEM certificate */
+//#define GENSECURE_CERTIFICATE "/usr/local/ssl/certs/server.cert"
+#define GENSECURE_CERTIFICATE "/usr/local/ssl/certs/openssl-example.pem"
+
+/* Location of the server private key */
+//#define GENSECURE_KEY "/usr/local/ssl/certs/server.key"
+#define GENSECURE_KEY "/usr/local/ssl/certs/openssl-example.pem"
+
+/* Password used to decrypt private key */
+#define GENSECURE_PASSWORD "ggz rocks more"
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/test/gensocket.c libggz-0.0.5pre.tls/tls/test/gensocket.c
--- libggz-0.0.5pre/tls/test/gensocket.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/gensocket.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,185 @@
+/**************************************************************************
+GenSecure - a generic client/server example of TLS support for a connection
+(C) 2001 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+***************************************************************************/
+ 
+/* gensocket: generic socket and connection functions */
+
+#include "gensocket.h"
+#include <stdio.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+/* The socket used by server and client */
+int _socket;
+/* Connection file descriptor */
+int _accept;
+/* Saved port */
+int _port;
+
+void socket_error(int quit, const char *file, int line)
+{
+	printf("*** ERROR! ***\n");
+	printf("(%s)\n", strerror(errno));
+	printf("(in %s, line %i)\n", file, line);
+	printf("**************\n");
+	if(quit) exit(-1);
+}
+
+int socket_create_arg(const char *protocol)
+{
+	struct protoent *proto;
+	int sock;
+
+	proto = getprotobyname(protocol);
+	endprotoent();
+	if(proto == NULL)
+	{
+		printf("tcp not supported!\n");
+		GENSOCKERROR(1);
+	}
+	printf("OK: The tcp number is: %i\n", proto->p_proto);
+	sock = socket(AF_INET, SOCK_STREAM, proto->p_proto);
+	if(sock == -1)
+	{
+		printf("Couldn't create socket...\n");
+		GENSOCKERROR(1);
+	}
+	printf("OK: Socket is %i\n", sock);
+
+	_socket = sock;
+	return sock;
+}
+
+int socket_accept(int port)
+{
+	int binder;
+	int newport;
+	struct sockaddr_in sa;
+
+	if(port != _port)
+	{
+		socket_create_arg("tcp");
+
+		_port = port;
+		sa.sin_family = AF_INET;
+		sa.sin_addr.s_addr = htonl(INADDR_ANY);
+		sa.sin_port = htons(port);
+		binder = bind(_socket, (const struct sockaddr*)&sa, sizeof(sa));
+		if(binder != 0)
+		{
+			printf("Couldn't bind...\n");
+			GENSOCKERROR(1);
+		}
+		newport = ntohs(sa.sin_port);
+		printf("OK: Right now we are connected to port %i!\n", newport);
+	}
+
+	_accept = socket_read_arg(_socket);
+	return _accept;
+}
+
+int socket_connect(const char *host, int port)
+{
+	struct sockaddr_in sa;
+	struct hostent *name;
+
+	socket_create_arg("tcp");
+
+	sa.sin_family = AF_INET;
+	sa.sin_port = htons(port);
+
+	name = gethostbyname(host);
+	if(!name)
+	{
+		printf("Host not found!\n");
+		GENSOCKERROR(1);
+	}
+	memcpy(&sa.sin_addr, name->h_addr, name->h_length);
+	_accept = connect(_socket, (const struct sockaddr*)&sa, sizeof(sa));
+	if(_accept != 0)
+	{
+		printf("Connect invoked error!\n");
+		GENSOCKERROR(1);
+	}
+	printf("OK: Right now we are connected to host %s, port %i!\n", host, port);
+
+	_accept = _socket;
+	return _accept;
+}
+
+int socket_read_arg(int sock)
+{
+	struct sockaddr_in newsa;
+	int *size_accept;
+	int in, in_accept;
+
+	in = listen(sock, 4);
+	if(in == -1)
+	{
+		printf("Error while listening!\n");
+		GENSOCKERROR(1);
+	}
+	if(in == 0)
+	{
+		newsa.sin_family = AF_INET;
+		newsa.sin_addr.s_addr = htonl(INADDR_ANY);
+		newsa.sin_port = 7025;
+		size_accept = (int*)sizeof(newsa);
+		in_accept = accept(sock, (struct sockaddr*)&newsa, size_accept);
+		if(in_accept == -1)
+		{
+			printf("Accept invoked error!\n");
+			GENSOCKERROR(1);
+		}
+		return in_accept;
+	}
+	return -1;
+}
+
+void socket_close()
+{
+	socket_close_arg(_accept);
+}
+
+void socket_close_arg(int in_accept)
+{
+	close(in_accept);
+}
+
+int output(const char *s)
+{
+	printf("(debug: write %s)\n", s);
+	return write(_accept, s, strlen(s) + 1);
+}
+
+int input(char *buffer, int size)
+{
+	ssize_t ret;
+
+	ret = read(_accept, buffer, size);
+	if(ret == -1)
+	{
+		if(errno != EAGAIN)
+		{
+			printf("An error occured while reading fd %i!\n", _accept);
+			GENSOCKERROR(1);
+		}
+	}
+	if(ret > 0) buffer[strlen(buffer)] = 0;
+	return ret;
+	/*printf("(debug: read %s)\n", buffer);*/
+}
+
+int socket_fd()
+{
+	return _accept;
+}
diff -Nur libggz-0.0.5pre/tls/test/gensocket.h libggz-0.0.5pre.tls/tls/test/gensocket.h
--- libggz-0.0.5pre/tls/test/gensocket.h	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/gensocket.h	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,40 @@
+/**************************************************************************
+GenSecure - a generic client/server example of TLS support for a connection
+(C) 2001 Josef Spillner, dr_maux@users.sourceforge.net
+Published under GNU GPL conditions
+***************************************************************************/
+
+/* gensocket: generic socket and connection functions */
+
+#ifndef GENSOCKET_H
+#define GENSOCKET_H
+
+#include <sys/types.h>
+
+/* Server only: open a connection on the specified port */
+int socket_accept(int port);
+/* Client only: connect to the given location */
+int socket_connect(const char *host, int port);
+/* Finish a connection */
+void socket_close();
+/* Write some bytes */
+int output(const char *s);
+/* Read some bytes */
+int input(char *buffer, int size);
+
+/* Internal: create a socket */
+int socket_create_arg(const char *protocol);
+/* Internal: wait for socket to come ready */
+int socket_read_arg(int sock);
+/* Internal: close socket */
+void socket_close_arg(int in_accept);
+/* Internal: display an error and quit if requested */
+void socket_error(int quit, const char *file, int line);
+
+/* Return the active file descriptor */
+int socket_fd();
+
+#define GENSOCKERROR(x) socket_error(x, __FILE__, __LINE__)
+
+#endif
+
diff -Nur libggz-0.0.5pre/tls/test/server.c libggz-0.0.5pre.tls/tls/test/server.c
--- libggz-0.0.5pre/tls/test/server.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/server.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,48 @@
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "gensocket.h"
+#include "ggz_tls.h"
+#include "configuration.h"
+
+int main(int argc, char *argv[])
+{
+	char tmpbuf[4096];
+	int bytes;
+
+	printf("> Starting generic server...\n");
+
+	while(1)
+	{
+		socket_accept(GENSECURE_PORT);
+		printf("Generic server: waiting for input\n");
+
+		printf("> Securing connection...\n");
+		ggz_tls_enable_fd(socket_fd(), GGZ_TLS_SERVER, GGZ_TLS_VERIFY_NONE);
+
+		printf("> Server in working state.\n");
+
+		fcntl(socket_fd(), F_SETFL, O_NONBLOCK);
+
+		for(;;)
+		{
+			bytes = ggz_tls_read(socket_fd(), tmpbuf, sizeof(tmpbuf));
+			if(bytes > 0)
+			{
+				tmpbuf[bytes] = 0;
+				if(!strcmp(tmpbuf, "quit"))
+				{
+					ggz_tls_write(socket_fd(), "Bye.", strlen("Bye."));
+					break;
+				}
+				printf("Received: %s\n", tmpbuf);
+			}
+		}
+	}
+
+	printf("> Server quit.\n");
+	
+	return 0;
+}
+
diff -Nur libggz-0.0.5pre/tls/test/test.c libggz-0.0.5pre.tls/tls/test/test.c
--- libggz-0.0.5pre/tls/test/test.c	Thu Jan  1 01:00:00 1970
+++ libggz-0.0.5pre.tls/tls/test/test.c	Sat Feb 23 03:14:48 2002
@@ -0,0 +1,35 @@
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <ggz_tls.h>
+
+int main(int argc, char *argv[])
+{
+	char buffer[1024], buffer2[1024];
+	int fd[2];
+
+	printf("Preparation...\n");
+	strcpy(buffer, "This is a test.");
+	socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
+
+	printf("Enable TLS for the client...\n");
+	ggz_tls_enable_fd(fd[0], GGZ_TLS_CLIENT, GGZ_TLS_VERIFY_NONE);
+	printf("Enable TLS for the server...\n");
+	ggz_tls_enable_fd(fd[1], GGZ_TLS_SERVER, GGZ_TLS_VERIFY_NONE);
+
+	printf("Write a message...\n");
+	ggz_tls_write(fd[0], buffer, strlen(buffer));
+	printf("Read a message...\n");
+	ggz_tls_read(fd[1], buffer2, sizeof(buffer2));
+
+	printf("\n==========================\n");
+	printf("Sent on [%i]: %s\n", fd[0], buffer);
+	printf("Received on [%i]: %s\n", fd[1], buffer2);
+	printf("Did we use encryption? %i\n", ggz_tls_support_query());
+
+	return 0;
+}
+
